<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueSky&#39;s Blog</title>
  
  
  <link href="https://blog.xxsu.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.xxsu.xyz/"/>
  <updated>2024-01-01T13:48:45.287Z</updated>
  <id>https://blog.xxsu.xyz/</id>
  
  <author>
    <name>Xiao Su</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android插件化原理剖析</title>
    <link href="https://blog.xxsu.xyz/article/dd39be9c/"/>
    <id>https://blog.xxsu.xyz/article/dd39be9c/</id>
    <published>2023-12-24T06:58:00.000Z</published>
    <updated>2024-01-01T13:48:45.287Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="Shadow插件原理"><a href="#Shadow插件原理" class="headerlink" title="Shadow插件原理"></a>Shadow插件原理</h2><p>官方地址： https://github.com/Tencent/Shadow</p><p>详细描述内容有点多，下面简化，只体现核心要点：</p><p>交互模式：系统&lt;&#x3D;&gt;宿主&lt;&#x3D;&gt;shadow框架&lt;&#x3D;&gt;插件apk</p><p>宿主只和插件管理器交互，他两在同一进程中。插件管理器依赖核心管理器和动态管理器这两个；</p><br/><p>核心管理器：</p><ul><li>插件的存储、管理</li><li>so、dex的管理</li><li>插件包zip的释放</li></ul><br/><p>动态管理器：</p><ul><li>提供插件res、so、dex的基础api</li><li>负责加载runtime插件和loader插件</li></ul><br/><p>runtime插件和loader插件主要是用来加载插件apk的，和插件apk在同一进程。因此加载插件过程会涉及到IPC的过程。</p><p>每个插件都会对应一个runtime、loader插件，用uuid标识。多个插件也可以共用同一个runtime、loader插件。</p><p>官方有提供无动态管理器的例子，把runtime、loader插件打包到宿主中了。</p><br/><h2 id="Replugin插件原理"><a href="#Replugin插件原理" class="headerlink" title="Replugin插件原理"></a>Replugin插件原理</h2><p>在宿主中注册多个activity，当启动一个A的intent时，hook系统的类加载器，就会取寻找插件对应的activity加载。</p><p>不足之处：宿主中无法实现一个activity注册信息的复用，需要产生大量的坑位；</p><p>除了替换系统PathClassLoader并反射修改API之外，也可以在PathClassLoader上加个parentClassLoader，因为PathClassLoader也是有个正常的双亲委派逻辑，会询问父类加载器加载。</p><p>所有插件拿到activity实例都是，new一个DexClassLoader去加载apk的activity的名字，newInstance后再强转为activity使用。</p><br/><p>思考🤔：都修改了类加载器了，为啥没法实现一个坑位多用？</p><p>因为类加载器在加载类的时候，收到的参数只有一个类名，无法传递更多的参数。</p><p>而代理方式是在收到系统声明周期方法调用时转调插件的声明周期方法，启动代理activity时通过intent传递很多参数，进而实现构造A还是B。</p><br/>]]></content>
    
    
    <summary type="html">Android插件化原理剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="插件化" scheme="https://blog.xxsu.xyz/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>KOOM原理</title>
    <link href="https://blog.xxsu.xyz/article/25d18315/"/>
    <id>https://blog.xxsu.xyz/article/25d18315/</id>
    <published>2023-12-23T06:58:00.000Z</published>
    <updated>2024-01-01T13:49:13.697Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><p>源码地址：https://github.com/KwaiAppTeam/KOOM/tree/master</p><br/><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>java堆泄漏：Copy-on-write 机制 fork 子进程 dump Java Heap，解决了 dump 过程中 app 长时间冻结的问题；</p><p>native堆泄漏：利用Tracing garbage collection机制分析整个 Native Heap，直接输出泄漏内存信息（大小、分配堆栈等）；</p><p>Thread 泄漏：hook 线程的生命周期函数，周期性的上报泄漏线程信息。</p><br/><h2 id="Copy-on-write-机制"><a href="#Copy-on-write-机制" class="headerlink" title="Copy-on-write 机制"></a>Copy-on-write 机制</h2><p>延迟复制操作，即在需要修改数据时才会进行实际的复制，在修改操作发生之前，系统会为要修改的对象创建数据的副本（复制），确保修改操作不会影响其他对象共享的原始数据。这种机制的优势在于，在大部分情况下，多个对象只是读取数据而不进行修改。因此，只有在有写操作发生时才会进行数据的复制，节省了内存开销和复制时间。</p><br/><h2 id="和Leakcanary对比"><a href="#和Leakcanary对比" class="headerlink" title="和Leakcanary对比"></a>和Leakcanary对比</h2><p>Leakcanary利用的是弱引用机制+GC方式来判断是否有泄漏，GC是存在性能损耗的，而koom采用内存阈值检测，无性能损耗；其次Leakcanary的dump在主进程，而KOOM采用fork方式，不会影响主进程，因此可以支持线上使用。</p><br/><br/>]]></content>
    
    
    <summary type="html">KOOM原理</summary>
    
    
    
    <category term="Android" scheme="https://blog.xxsu.xyz/categories/Android/"/>
    
    
    <category term="KOOM" scheme="https://blog.xxsu.xyz/tags/KOOM/"/>
    
  </entry>
  
  <entry>
    <title>Android热更新之Tinker</title>
    <link href="https://blog.xxsu.xyz/article/137f0e62/"/>
    <id>https://blog.xxsu.xyz/article/137f0e62/</id>
    <published>2023-12-22T06:58:00.000Z</published>
    <updated>2024-01-01T13:46:41.883Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>Tinker是Android的热修复解决方案库，它支持dex、库和资源更新，而无需重新安装apk。</p><p>官方网址： https://github.com/Tencent/tinker</p><br/><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>差分包：将提取出的差异内容打包成一个差分包（Patch），包含了需要更新的部分信息，通常以压缩的方式存储，方便传输和应用。Tinker 利用差分包中的信息，对当前 APK 进行动态更新，实现热修复或版本更新的功能。</p><p>动态加载：使用Android 的类加载器和动态链接库加载技术，应用运行过程中动态加载新的代码，实现bug修复、功能更新等操作。</p><p>Tinker 利用差分包来传递变更的信息，最终将这些变更合并到运行中的 Dex 文件中，以实现代码的更新和修复。</p><br/><h2 id="代码修复"><a href="#代码修复" class="headerlink" title="代码修复"></a>代码修复</h2><p>如何确保修复的dex被加载，原来的dex不会影响修复的dex的加载？</p><p>Tinker 会在应用启动时动态创建一个类加载器，并使用这个类加载器来加载修复的 Dex 文件。它会设置这个新创建的类加载器的优先级高于原始的类加载器，且会使用委派机制来控制类的加载顺序，修复的 Dex 文件就能够优先被加载和使用。接着用修复的 Dex 文件中的类，并替换掉原始版本的类。这样，在应用程序运行时，修复的代码会优先被执行。</p><br/><h2 id="资源修复"><a href="#资源修复" class="headerlink" title="资源修复"></a>资源修复</h2><p>Tinker资源修复通过Hook获取APK描述文件loadedApk，设置资源补丁路径mRes，创建新的AssetManager并添加资源补丁路径，修改ResourceManager内的资源缓存以确保加载修复资源，清除TypedArrays缓存池并更新资源，确保应用能正确加载并使用修复的资源文件。</p><br/><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然tinker热更新可以修复 bug、更新功能等，但是如果操作不当也会带来一些麻烦，有一些小细节也是需要注意的，避免造成不必要的麻烦。</p><p>版本兼容性：确保Tinker 支持的 Android Studio 版本和 Gradle 插件版本和当前项目所用的版本兼容；</p><p>代码稳定性：热更新涉及代码的替换和修复，不当的操作可能导致应用崩溃或者出现不可预料的错误，一定要确保更新的代码是稳定的；</p><p>资源文件更新限制：对于资源文件（如布局、图片等）的修改支持有限。一些资源文件的修改可能无法通过 Tinker 实现更新，需要谨慎处理；</p><p>代码混淆：确保在配置混淆和代码压缩时考虑到 Tinker 的需求；</p><p>性能影响：热更新会对应用的性能产生一定的影响，如启动时间、占用存储空间等，要综合评估；</p><p>回滚策略：处理更新失败、快速回滚等情况，以降低因热更新引起的风险。</p><br/>]]></content>
    
    
    <summary type="html">Android热更新之Tinker</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Tinker" scheme="https://blog.xxsu.xyz/tags/Tinker/"/>
    
  </entry>
  
  <entry>
    <title>c++指针归纳总结</title>
    <link href="https://blog.xxsu.xyz/article/4016f0ee/"/>
    <id>https://blog.xxsu.xyz/article/4016f0ee/</id>
    <published>2023-12-21T06:58:00.000Z</published>
    <updated>2024-01-01T13:47:10.163Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="指针介绍"><a href="#指针介绍" class="headerlink" title="指针介绍"></a>指针介绍</h2><p><strong>std::unique_ptr</strong>：代表独占所有权的指针，不能被复制或共享，它提供了一种独占式拥有指向对象的所有权的方法，当 std::unique_ptr 被销毁时，它所指向的对象也会被自动释放。</p><p><strong>std::shared_ptr</strong>：多个 shared_ptr 可以共享同一个对象，直到最后一个 shared_ptr 被销毁时，才会自动释放资源。不足：对象之间相互引用，导致引用计数无法降为零，从而导致内存泄漏（需使用weak_ptr解决）。</p><p><strong>std::weak_ptr</strong>：weak_ptr 是用于解决 shared_ptr 循环引用问题的智能指针。weak_ptr 也可以指向同一个对象，但它不会增加对象的引用计数。当最后一个 shared_ptr 被销毁后，如果只剩下 weak_ptr 引用，那么对象将会被释放。</p><p><strong>scoped_ptr（ Boost 库）</strong>：拥有对象的唯一所有权，当 scoped_ptr 被销毁时，它所拥有的对象也会被自动释放。这意味着 scoped_ptr 不支持多个指针指向同一个对象。</p><p><strong>intrusive_ptr（ Boost 库）</strong>：intrusive_ptr 是一个自引用智能指针，它要求被管理的对象实现 intrusive_ptr_add_ref 和 intrusive_ptr_release 方法来管理引用计数。不需要维护引用计数的开销，因为它是通过对象自身的引用计数来管理资源的。</p><br/><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uniquePtrExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uniquePtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value stored in unique_ptr: &quot;</span> &lt;&lt; *uniquePtr &lt;&lt; std::endl;<br>    <span class="hljs-comment">// unique_ptr 独占所有权，不能被复制</span><br>    <span class="hljs-comment">// std::unique_ptr&lt;int&gt; otherPtr = uniquePtr; // 这行代码会导致编译错误</span><br><br>    <span class="hljs-comment">// 使用 std::move 转移所有权</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; movedPtr = std::<span class="hljs-built_in">move</span>(uniquePtr);<br>    <span class="hljs-keyword">if</span> (!uniquePtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;unique_ptr has been moved and is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125; <span class="hljs-comment">// 在函数结束时，unique_ptr 自动释放其所管理的对象</span><br></code></pre></td></tr></table></figure><br/><h2 id="std-shared-ptr-和-std-weak-ptr"><a href="#std-shared-ptr-和-std-weak-ptr" class="headerlink" title="std::shared_ptr 和 std::weak_ptr"></a>std::shared_ptr 和 std::weak_ptr</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrExample</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weakPtr = sharedPtr; <span class="hljs-comment">// 使用 weak_ptr 监视 shared_ptr 管理的对象</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;shared_ptr use count: &quot;</span> &lt;&lt; sharedPtr.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> lockedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value stored in shared_ptr: &quot;</span> &lt;&lt; *lockedPtr &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource has been released&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 当所有 shared_ptr 释放后，对象被销毁</span><br>    sharedPtr.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> lockedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value stored in shared_ptr: &quot;</span> &lt;&lt; *lockedPtr &lt;&lt; std::endl; <span class="hljs-comment">// weak_ptr 无效</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource has been released&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="scoped-ptr-示例"><a href="#scoped-ptr-示例" class="headerlink" title="scoped_ptr 示例"></a>scoped_ptr 示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/scoped_ptr.hpp&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scopedPtrExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">boost::scoped_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">scopedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">7</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value stored in scoped_ptr: &quot;</span> &lt;&lt; *scopedPtr &lt;&lt; std::endl;<br>    <span class="hljs-comment">// scoped_ptr 不能被复制和赋值</span><br>    <span class="hljs-comment">// boost::scoped_ptr&lt;int&gt; otherScopedPtr = scopedPtr; // 这行代码会导致编译错误</span><br>&#125; <span class="hljs-comment">// 在函数结束时，scoped_ptr 自动释放其所管理的对象</span><br></code></pre></td></tr></table></figure><br/><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>指针是一个很强大但也容易出错的工具。以下是使用指针时需要注意的一些重要事项：</p><ol><li>空指针检查：在使用指针之前，始终检查指针是否为空（nullptr），避免空指针解引用导致的崩溃。</li><li>内存泄漏：手动分配内存后，确保在不再需要时及时释放内存（delete 或 delete[]），避免内存泄漏。</li><li>悬空指针：避免使用已经释放的指针，否则可能导致悬空指针问题，尽量避免在释放指针后仍然引用它。</li><li>野指针：野指针是指指向无效内存的指针，避免使用未初始化的指针或者已经超出作用域的指针。</li><li>数组越界访问：在使用指向数组的指针时，避免越界访问数组元素，这可能导致未知行为和程序崩溃。</li><li>释放已释放的内存：避免对已经释放的内存再次进行释放，这可能导致程序崩溃或者未定义的行为。</li><li>指针类型转换：尽量避免进行不安全的指针类型转换，特别是在 C++ 中使用 reinterpret_cast，这可能导致类型不匹配的问题。</li><li>空间分配与释放的匹配：使用 new 分配内存时，使用 delete 进行释放；使用 new[] 分配数组内存时，使用 delete[] 进行释放。</li><li>指针与引用的区别：指针与引用虽然有相似之处，但具有不同的语义和行为，需要理解二者的区别，如指针可以重新赋值而引用不可以。</li><li>const 修饰符：使用 const 修饰指针，可以避免意外修改指针所指向的内容，提高代码的安全性和可维护性。</li><li>避免混用智能指针和原始指针：尽量避免混合使用智能指针和原始指针，这可能导致所有权和释放内存时的混乱。</li></ol><br/>]]></content>
    
    
    <summary type="html">c++指针归纳总结</summary>
    
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/categories/c/"/>
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL干货总结</title>
    <link href="https://blog.xxsu.xyz/article/7de12c1b/"/>
    <id>https://blog.xxsu.xyz/article/7de12c1b/</id>
    <published>2023-12-20T06:58:00.000Z</published>
    <updated>2024-01-01T13:48:21.718Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h2><p><img src="/article/7de12c1b/image-20231227165141908.png" alt="image-20231227165141908"></p><br/><h2 id="VAO、VBO、IBO-等区别作用"><a href="#VAO、VBO、IBO-等区别作用" class="headerlink" title="VAO、VBO、IBO 等区别作用"></a>VAO、VBO、IBO 等区别作用</h2><p>VAO：顶点数组对象，存储顶点属性指针的配置（如顶点坐标、颜色、纹理坐标等），使得在渲染时可以更有效地切换顶点属性的配置。</p><p>VBO：顶点缓冲对象，存储顶点数据，例如顶点坐标、法线、纹理坐标等。</p><p>EBO&#x2F;IBO：索引缓冲对象，存储图元的索引数据，例如三角形列表或三角形带的索引。</p><p>使用结构数组的方式效率最高。</p><br/><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 顶点数据</span><br><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><br><span class="hljs-comment">// 索引数据</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO, VAO, IBO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;IBO);<br><br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>    <span class="hljs-built_in">processInput</span>(window);<br><br>    <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>    <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br><br>    <span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>    <span class="hljs-built_in">glfwPollEvents</span>();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>x和y轴坐标范围：0到1，超出则采取环绕方式。</p><table><thead><tr><th>环绕方式</th><th>作用</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>默认，重复纹理图像</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>重复，镜像放置</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>重复边缘，边缘被拉伸的效果</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>指定边缘颜色</td></tr></tbody></table><p>纹理过滤：邻近过滤和线性过滤</p><p>远距离物体可以采用多级渐远纹理；</p><p>设置方法：glTexParameteri</p><p>纹理加载方法：stb_image.h</p><p>绑定多个纹理：纹理单元。使用前需激活纹理单元，为每个纹理单元绑定纹理，再通过glUniformli方法将采样器绑定到对应的纹理单元。</p><br/><h2 id="向量、矩阵"><a href="#向量、矩阵" class="headerlink" title="向量、矩阵"></a>向量、矩阵</h2><p>点乘：求向量夹角，即cosθ；</p><p>叉乘：求法线；不满足乘法交换律；</p><p>向量的w分量：齐次坐标。增加的w分量主要方便通过矩阵实现向量的缩放、旋转、平移；</p><p>弧度转角度：角度 &#x3D; 弧度 * (180.0f &#x2F; PI)</p><p>角度转弧度：弧度 &#x3D; 角度 * (PI &#x2F; 180.0f)</p><p>GLM数学库例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">glm::mat4 mat = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>)<br>glm::mat4 trans;<br>glm::<span class="hljs-built_in">translate</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br>glm::<span class="hljs-built_in">rotate</span>(trans, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">90.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>));<br>glm::<span class="hljs-built_in">scale</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>));<br></code></pre></td></tr></table></figure><br/><h2 id="MVP矩阵"><a href="#MVP矩阵" class="headerlink" title="MVP矩阵"></a>MVP矩阵</h2><p>MVP&#x3D;Projection×View×Model</p><p>M：局部坐标到世界坐标</p><p>V：世界坐标到观察坐标</p><p>P：观察坐标到裁剪空间</p><p>透视投影：越远越小</p><p>正交投影：大小一致</p><br/><h2 id="摄像机坐标方向"><a href="#摄像机坐标方向" class="headerlink" title="摄像机坐标方向"></a>摄像机坐标方向</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//相机方向</span><br>glm::vec3 cameraTarget = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>glm::vec3 cameraDirection = glm::<span class="hljs-built_in">normalize</span>(cameraPos - cameraTarget);<br><span class="hljs-comment">//相机右轴</span><br>glm::vec3 up = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>); <br>glm::vec3 cameraRight = glm::<span class="hljs-built_in">normalize</span>(glm::<span class="hljs-built_in">cross</span>(up, cameraDirection));<br><span class="hljs-comment">//上轴</span><br>glm::vec3 cameraUp = glm::<span class="hljs-built_in">cross</span>(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure><p>lookAt矩阵：glm::LookAt函数(位置、目标、上向量）</p><br/><br/><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>https://learnopengl-cn.github.io/</p>]]></content>
    
    
    <summary type="html">OpenGL干货总结</summary>
    
    
    
    <category term="图形API" scheme="https://blog.xxsu.xyz/categories/%E5%9B%BE%E5%BD%A2API/"/>
    
    
    <category term="OpenGL" scheme="https://blog.xxsu.xyz/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Hilt框架介绍</title>
    <link href="https://blog.xxsu.xyz/article/fd33f9e4/"/>
    <id>https://blog.xxsu.xyz/article/fd33f9e4/</id>
    <published>2023-12-19T06:58:00.000Z</published>
    <updated>2023-12-22T07:27:09.511Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><blockquote><p>Hilt是由Google推出的基于Dagger的依赖注入框架，它旨在简化Dagger在Android应用中的使用，并提供更多的便利性和易用性。</p><p>tips:先学习dagger再来看Hilt框架会简单很多。</p></blockquote><br/><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>简化配置和使用：Hilt通过简化Dagger的模板代码，提供了更简单的注入方式，减少了开发者需要编写的代码量。引入了一些默认的配置，使得在大多数情况下无需手动配置模块。</p><p>自动生成代码和更高的抽象层级：Hilt生成一些常见的依赖注入代码，减少了开发者需要手动编写的代码量。引入了一些高级抽象，例如@ViewModelInject注解，用于更方便地注入ViewModel。</p><p>组件化和测试：Hilt鼓励更模块化的设计，使得组件更易于测试和维护。通过更好地支持单元测试，使得测试更容易进行。</p><p>Android特定的优化和集成：Hilt提供了特定于Android的功能，比如支持Android组件的生命周期管理，与ViewModel的集成等。</p><br/><h3 id="Hilt和Dagger对比"><a href="#Hilt和Dagger对比" class="headerlink" title="Hilt和Dagger对比"></a>Hilt和Dagger对比</h3><table><thead><tr><th>简化点</th><th>Hilt</th><th>Dagger</th></tr></thead><tbody><tr><td>模板代码的减少</td><td>引入默认配置和标准化注解，减少模板代码量</td><td>需要手动编写较多的模板代码来配置依赖注入</td></tr><tr><td>Android组件的注入</td><td>使用@AndroidEntryPoint简化Android组件的依赖注入</td><td>需要手动配置每个Android组件的依赖注入</td></tr><tr><td>ViewModel的注入</td><td>使用@HiltViewModel和by viewModels()简化ViewModel注入</td><td>需要手动配置特定Provider来注入ViewModel</td></tr><tr><td>生命周期管理</td><td>自动处理Android组件的生命周期，简化依赖对象的管理</td><td>需要手动管理依赖对象的创建和销毁，处理生命周期可能较繁琐</td></tr><tr><td>默认绑定和作用域</td><td>提供默认的绑定和作用域配置，简化依赖注入的配置</td><td>需要手动配置绑定和作用域，可能容易出错或需要更多的手动设置</td></tr></tbody></table><br/><h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在项目级别的build.gradle文件中添加Hilt插件</span><br>classpath <span class="hljs-string">&#x27;com.google.dagger:hilt-android-gradle-plugin:版本号&#x27;</span><br><br><span class="hljs-comment">//在应用的build.gradle文件中</span><br><span class="hljs-comment">// 应用Hilt插件</span><br>apply plugin: <span class="hljs-string">&#x27;dagger.hilt.android.plugin&#x27;</span><br><br><span class="hljs-comment">// 添加Hilt依赖</span><br>implementation <span class="hljs-string">&#x27;com.google.dagger:hilt-android:版本号&#x27;</span><br>kapt <span class="hljs-string">&#x27;com.google.dagger:hilt-compiler:版本号&#x27;</span><br></code></pre></td></tr></table></figure><br/><h3 id="HiltAndroidApp注解"><a href="#HiltAndroidApp注解" class="headerlink" title="@HiltAndroidApp注解"></a>@HiltAndroidApp注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-title">extends</span> <span class="hljs-title">Application</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="AndroidEntryPoint注解"><a href="#AndroidEntryPoint注解" class="headerlink" title="@AndroidEntryPoint注解"></a>@AndroidEntryPoint注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> <span class="hljs-title">extends</span> <span class="hljs-title">AppCompatActivity</span> &#123;<br>  <br>    <span class="hljs-meta">@Inject</span><br>    SomeDependency someDependency;<br>  <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="HiltViewModel注解"><a href="#HiltViewModel注解" class="headerlink" title="@HiltViewModel注解"></a>@HiltViewModel注解</h3><p>@HiltViewModel 注解被添加到 ViewModel 类上，表示这是一个需要 Hilt 进行依赖注入的 ViewModel。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRepository</span> &#123;<br>    <span class="hljs-comment">// Repository 的具体实现</span><br>&#125;<br><br><span class="hljs-meta">@HiltViewModel</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> <span class="hljs-title">extends</span> <span class="hljs-title">ViewModel</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository repository;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">public</span> MyViewModel(MyRepository repository) &#123;<br>        <span class="hljs-keyword">this</span>.repository = repository;<br>    &#125;<br><br>    <span class="hljs-comment">// ViewModel 的逻辑方法</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Hilt在dagger的基础上专门对Android做了简化，让依赖注入框架使用起来更方便，毕竟dagger是java的依赖注入库。</p>]]></content>
    
    
    <summary type="html">Hilt框架介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg使用总结</title>
    <link href="https://blog.xxsu.xyz/article/4f6e9117/"/>
    <id>https://blog.xxsu.xyz/article/4f6e9117/</id>
    <published>2023-12-18T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.473Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="通用命令格式"><a href="#通用命令格式" class="headerlink" title="通用命令格式"></a>通用命令格式</h2><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">ffmpeg [全局参数] [输入文件参数] -i 输入文件地址 [输出文件参数] 输出文件地址<br></code></pre></td></tr></table></figure><br/><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>音视频格式转换：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 output.avi<br></code></pre></td></tr></table></figure><p>调整视频尺寸：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vf scale=640:480 output.mp4<br></code></pre></td></tr></table></figure><p>裁剪视频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -ss 00:00:10 -to 00:00:30 -c copy output.mp4<br></code></pre></td></tr></table></figure><p>提取音频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vn -acodec copy output.mp3<br></code></pre></td></tr></table></figure><p>合并视频和音频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac -strict experimental output.mp4<br></code></pre></td></tr></table></figure><p>添加水印：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -i watermark.png -filter_complex &quot;overlay=10:10&quot; output.mp4<br></code></pre></td></tr></table></figure><p>调整音量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp3 -af &quot;volume=1.5&quot; output.mp3<br></code></pre></td></tr></table></figure><p>提取视频帧：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vf &quot;select=&#x27;eq(n\,100)&#x27;&quot; -vsync vfr frame_%03d.png<br></code></pre></td></tr></table></figure><p>转gif：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">ffmpeg -i file.mov -r <span class="hljs-number">15</span> file.gif <span class="hljs-comment">//帧率15</span><br></code></pre></td></tr></table></figure><p>更多命令教程： https://wklchris.github.io/blog/FFmpeg/FFmpeg.html</p><br/><h2 id="常用模块库"><a href="#常用模块库" class="headerlink" title="常用模块库"></a>常用模块库</h2><p>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构。</p><p>libavcodec：用于各种类型音视频编解码</p><p>libavutil：包含一些公共的工具函数</p><p>libswscale：用于视频场景比例缩放、色彩映射转换等</p><p>libpostproc：用于后期效果处理等</p><p>libswresample：提供音频重采样功能，包括采样频率、声道格式等</p><p>libavfilter：用于滤波器处理，如音视频倍速、水平翻转、叠加文字等功能</p><p>libavdevice：包含输入输出设备的库，实现音视频数据的抓取或渲染</p><br/><p>命令行工具：</p><p>ffmpeg：编解码小工具，可用于格式转换、解码或电视卡即时编码等</p><p>ffserver：一个HTTP多媒体即时广播串流服务器</p><p>ffplay：一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示</p><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《FFmpeg入门详解–音视频原理及应用》</p>]]></content>
    
    
    <summary type="html">ffmpeg使用总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>apk签名介绍</title>
    <link href="https://blog.xxsu.xyz/article/e77709f1/"/>
    <id>https://blog.xxsu.xyz/article/e77709f1/</id>
    <published>2023-12-17T06:58:00.000Z</published>
    <updated>2024-01-01T13:47:00.772Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="如何确保消息正确？"><a href="#如何确保消息正确？" class="headerlink" title="如何确保消息正确？"></a>如何确保消息正确？</h2><p>客户端利用 Hash 算法针对数据得出一个摘要，使用公钥加密，连同对称加密的数据一起发送过去，服务端收到消息后，先利用对称密钥对内容解密，再进行 Hash 计算得出摘要。使用私钥将摘要内容解密，和再次计算得出的摘要作对比，一致就代表消息无误。</p><h2 id="如何保证公钥的正确性？"><a href="#如何保证公钥的正确性？" class="headerlink" title="如何保证公钥的正确性？"></a>如何保证公钥的正确性？</h2><p>使用数字证书，包含的信息有：</p><p>主体信息：证书的主体是公钥的拥有者</p><p>公钥：证书中包含了公钥的信息，用于进行加密或数字签名验证</p><p>证书颁发者（CA）信息：证书颁发者是证书的签发机构</p><p>证书有效期：包括证书的起始日期和截止日期</p><p>数字签名：证书内容经过 CA 使用私钥进行数字签名，验证方可以使用 CA 的公钥对签名进行验证</p><p>证书序列号：唯一标识证书的序列号，用于区分不同的证书</p><p>扩展信息：包括一些额外的信息，如密钥用途、颁发者策略等</p><h2 id="ADB增量APK安装"><a href="#ADB增量APK安装" class="headerlink" title="ADB增量APK安装"></a>ADB增量APK安装</h2><p>生成差分文件》生成增量补丁》传输并应用增量补丁</p><p>可行性检测： adb install –incremental</p><p>增量安装时，adb 会要求 .apk.idsig 文件存在于 .apk 旁边（APK v4的签名文件.apk.idsig并不会打包进apk文件中）</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>https://blog.csdn.net/chzphoenix/article/details/130130934</p>]]></content>
    
    
    <summary type="html">apk签名介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>JWT认证介绍</title>
    <link href="https://blog.xxsu.xyz/article/881e5f30/"/>
    <id>https://blog.xxsu.xyz/article/881e5f30/</id>
    <published>2023-12-16T06:58:00.000Z</published>
    <updated>2024-01-01T13:42:39.774Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="传统认证流程-Cookie-Session"><a href="#传统认证流程-Cookie-Session" class="headerlink" title="传统认证流程 Cookie + Session"></a>传统认证流程 Cookie + Session</h2><p>基本工作流程：</p><ol><li>用户登录：<ul><li>用户提供用户名和密码进行登录。</li><li>服务器验证用户提供的凭证，如果验证通过，则创建一个 Session。</li></ul></li><li>Session 创建：<ul><li>服务器为该用户创建一个唯一的 Session 对象，并将其标识符（Session ID）存储在服务器端。</li><li>同时，在响应中向用户的浏览器发送一个包含 Session ID 的 Cookie。</li></ul></li><li>Cookie 存储：<ul><li>浏览器收到服务器响应后，将包含 Session ID 的 Cookie 存储在本地。</li></ul></li><li>后续请求：<ul><li>用户在之后的每个请求中都会携带该 Cookie。</li><li>服务器收到请求时，从 Cookie 中提取 Session ID。</li><li>服务器使用提取的 Session ID 来识别用户的 Session，从而验证用户身份和状态。</li></ul></li><li>会话管理：<ul><li>服务器在 Session 中存储用户的状态信息，如登录状态、权限等。</li><li>每次请求都使用 Cookie 中的 Session ID 识别用户，并根据该 Session 获取或更新用户的状态信息。</li></ul></li><li>登出：<ul><li>当用户登出时，服务器会销毁相应的 Session，删除相关信息。</li><li>同时，服务器发送一个指示浏览器删除 Cookie 的响应，从而清除本地保存的 Session ID。</li></ul></li></ol><p>不足：如跨站点请求伪造（CSRF）攻击、服务器端需要存储会话信息等。</p><br/><h2 id="基于-Token-的认证方式"><a href="#基于-Token-的认证方式" class="headerlink" title="基于 Token 的认证方式"></a>基于 Token 的认证方式</h2><p>JWT（JSON Web Token）是一种用于安全传输信息的开放标准（RFC 7519），它通过一种紧凑且自包含的方式在各方之间安全地传递信息。JWT 主要由三部分组成，它们以点号分隔，形成一个字符串，具有如下结构：header.payload.signature</p><ul><li>Header（头部）：包含了关于生成的 Token 类型（JWT）和所使用的签名算法等元数据信息，通常以 JSON 格式表示。</li><li>Payload（载荷）：存放着 Token 的主体信息，如用户的身份信息、权限等数据，也是以 JSON 格式表示。Payload 可以包含一些预定义的声明（Registered Claims），例如过期时间（Expiration Time）等。</li><li>Signature（签名）：使用指定的算法对前面两部分的内容进行签名，确保 Token 没有被篡改。签名部分需要使用一个密钥进行加密，并与 Token 一起发送。</li></ul><p>工作流程：</p><ol><li>生成 Token：在服务端，根据用户提供的信息生成 JWT，包括指定的头部、载荷信息，并使用密钥生成签名部分。</li><li>传递 Token：将生成的 JWT 作为身份验证令牌发送给客户端（通常是通过 HTTP 头部传递），客户端通常将 Token 存储在本地。</li><li>验证和解析 Token：每次客户端发送请求时，都会携带 Token。服务端接收到请求后，解析 Token，验证签名，检查 Token 是否有效和完整。</li><li>处理有效 Token：如果 Token 有效并通过验证，服务端根据载荷中的信息，进行相应的操作，如用户认证、授权等。</li><li>Token 更新和续期：在 Token 过期之前，可以考虑更新 Token，续期用户的会话状态。</li></ol><p>JWT 的优势在于它的轻量、紧凑、自包含性和可扩展性，使得它成为在不同系统之间安全地传递信息的一种流行方式。</p><br/><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>JWT 默认是不加密，但也可以加密：JWT 默认不加密，但可以使用密钥进行签名，也可以选择加密整个令牌。签名是为了确保令牌的完整性和真实性。</li><li>不在 JWT 中存储敏感数据：JWT 可以包含信息，但不应存储敏感数据，特别是不应该在不加密的情况下存储敏感信息。</li><li>JWT 可用于信息交换和减少数据库查询：JWT 可以携带信息，允许客户端与服务器之间传递信息，避免了一些额外的数据库查询。</li><li>无法废止或修改有效期内的 Token：这是 JWT 的一个局限性。一旦签发，JWT 在到期之前都是有效的，服务器不能立即废止或修改其权限。需要额外的逻辑来处理失效的情况。</li><li>泄露可能导致权限被滥用：JWT 一旦泄露，持有者可以使用其中的信息进行认证。因此，建议设置较短的有效期，并对于重要的操作再次进行认证。</li><li>使用 HTTPS 传输 JWT：为了保证安全，不应该在 HTTP 下明文传输 JWT。使用 HTTPS 协议传输可以加密通信，确保令牌安全传输。</li></ol>]]></content>
    
    
    <summary type="html">JWT认证介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Clean架构介绍</title>
    <link href="https://blog.xxsu.xyz/article/857fda5c/"/>
    <id>https://blog.xxsu.xyz/article/857fda5c/</id>
    <published>2023-12-15T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.468Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>项目地址：</p><p>https://github.com/android10/Android-CleanArchitecture</p><p>https://github.com/android10/Android-CleanArchitecture-Kotlin</p><p>该架构主要用于分离业务逻辑和底层的实现，提高项目的可维护性、拓展性。</p><br/><p>Clean 架构是由软件工程师 Robert C. Martin（也被称为 Uncle Bob）提出的。他在他的书籍《Clean Architecture》中详细介绍了这种架构模式，旨在构建易于理解、灵活、可维护和可测试的软件系统。</p><br/><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ol><li>实体层： 包含应用程序的业务实体和核心业务逻辑，是整个架构的核心。这一层不依赖于任何其他层，它定义了应用程序的核心模型和规则。</li><li>用例层： 也称为交互器或业务逻辑层，负责应用程序的具体用例和业务规则。用例层依赖于实体层，但不依赖于任何特定的框架或技术。</li><li>接口适配器层： 这一层包含了外部框架和工具，如数据库、UI、Web 等。它负责将用例层的业务逻辑适配到外部工具，同时也负责将外部数据转换为用例层所需的格式。</li><li>框架与驱动器层： 包含与外部设备、框架或工具的代码，比如 UI、数据库等。这一层依赖于接口适配器层，但并不直接影响核心业务逻辑。</li></ol><br/><h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>Clean Architecture 强调依赖规则，通过依赖倒置原则和单一职责原则来减少各层之间的耦合度：</p><ul><li>依赖倒置原则： 高层模块不应该依赖于底层模块，而是应该依赖于抽象接口。即，抽象不应该依赖于具体实现，具体实现应该依赖于抽象。这一原则使得不同层次的组件之间的依赖更加灵活，易于替换和扩展。</li><li>单一职责原则： 每个模块、类或函数都应该只有一个单一的责任。在 Clean Architecture 中，每一层都有其明确的职责，遵循单一职责原则有助于代码的清晰度和可维护性。</li></ul><br/><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：可维护性高、测试性强、可扩展性、独立性、降低耦合；</p><p>缺点：复杂程度增加、过度设计风险、对小型项目增加不必要的开发成本。</p><br/><h2 id="与MVVM的区别"><a href="#与MVVM的区别" class="headerlink" title="与MVVM的区别"></a>与MVVM的区别</h2><ol><li>关注点不同： Clean Architecture 更侧重于整体应用程序的架构设计和分层，强调业务逻辑和依赖规则的组织；而 MVVM 更专注于界面和数据的绑定、视图模型的设计。</li><li>依赖关系不同： Clean Architecture 强调解耦合，通过分层和依赖规则来降低各部分之间的耦合度；而 MVVM 主要解决视图和业务逻辑的解耦合。</li><li>应用场景不同： Clean Architecture 适用于各种规模的项目，特别是需要长期维护和扩展的大型项目；MVVM 更适用于需要复杂、动态用户界面的应用程序，特别是基于 UI 数据绑定的框架（比如 Android 中的 Data Binding ）。</li></ol>]]></content>
    
    
    <summary type="html">Clean架构优缺点</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket介绍</title>
    <link href="https://blog.xxsu.xyz/article/a0966911/"/>
    <id>https://blog.xxsu.xyz/article/a0966911/</id>
    <published>2023-12-14T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.478Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="WebSocket介绍"><a href="#WebSocket介绍" class="headerlink" title="WebSocket介绍"></a>WebSocket介绍</h2><p>基于TCP协议，客户端和服务端保持长连接，使用帧（Frame）来封装和传输数据，采用事件驱动，使用加密的 WebSocket（wss:&#x2F;&#x2F;）连接，支持跨域通信，常用语聊天、实时协作等需要实时数据推送的场景。</p><br/><h2 id="Android中使用"><a href="#Android中使用" class="headerlink" title="Android中使用"></a>Android中使用</h2><p>借助 OkHttp 可以很轻易的实现 WebSocket，它的 OkHttpClient 中，提供了 newWebSocket() 方法，可以直接建立一个 WebSocket 连接并完成通信。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionWebSockt</span><span class="hljs-params">(hostName:<span class="hljs-type">String</span>,port:<span class="hljs-type">Int</span>)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> httpClient = OkHttpClient.Builder()<br>      .pingInterval(<span class="hljs-number">40</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 设置 PING 帧发送间隔</span><br>      .build()<br>  <span class="hljs-keyword">val</span> webSocketUrl = <span class="hljs-string">&quot;ws://<span class="hljs-subst">$&#123;hostName&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>&quot;</span><br>  <span class="hljs-keyword">val</span> request = Request.Builder()<br>      .url(webSocketUrl)<br>      .build()<br>  httpClient.newWebSocket(request, <span class="hljs-keyword">object</span>:WebSocketListener()&#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onOpen(webSocket, response)<br>      <span class="hljs-comment">// WebSocket 连接建立</span><br>      mWebSocket = webSocket<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, text: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onMessage(webSocket, text)<br>      <span class="hljs-comment">// 收到服务端发送来的 String 类型消息</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosing</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosing(webSocket, code, reason)<br>      <span class="hljs-comment">// 收到服务端发来的 CLOSE 帧消息，准备关闭连接</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosed</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosed(webSocket, code, reason)<br>      <span class="hljs-comment">// WebSocket 连接关闭</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, t: <span class="hljs-type">Throwable</span>, response: <span class="hljs-type">Response</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onFailure(webSocket, t, response)<br>      <span class="hljs-comment">// 出错了</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="MockWebSocket"><a href="#MockWebSocket" class="headerlink" title="MockWebSocket"></a>MockWebSocket</h2><p>有时候为了方便我们测试，OkHttp 还提供了扩展的 MockWebSocket 服务，来模拟服务端。</p><p>MockWebSocket 需要添加额外的 Gradle 引用，最好和 OkHttp 版本保持一致：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">api <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:3.9.1&#x27;</span><br>api <span class="hljs-string">&#x27;com.squareup.okhttp3:mockwebserver:3.9.1&#x27;</span><br></code></pre></td></tr></table></figure><p>MockWebServer 的使用也非常简单，只需要利用 MockWebSocket 类即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> mMockWebSocket: MockWebServer? = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockWebSocket</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (mMockWebSocket != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  mMockWebSocket = MockWebServer()<br>  mMockWebSocket?.enqueue(MockResponse().withWebSocketUpgrade(<span class="hljs-keyword">object</span> : WebSocketListener() &#123;<br>     <span class="hljs-comment">//...</span><br> &#125;))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WebSocket介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="flutter" scheme="https://blog.xxsu.xyz/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>c++锁的使用总结</title>
    <link href="https://blog.xxsu.xyz/article/f80a2866/"/>
    <id>https://blog.xxsu.xyz/article/f80a2866/</id>
    <published>2023-12-13T06:58:00.000Z</published>
    <updated>2024-01-01T13:08:34.321Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h2><p>可以传递参数： 参数是一个枚举值，可以是 std::defer_lock、std::adopt_lock。</p><p>使用 std::adopt_lock 时，std::unique_lock 对象会认为互斥量已经被锁定，因此它不会尝试再次锁定互斥量。而是直接将自己关联到已锁定的互斥量上，然后你可以在合适的地方使用这个 std::unique_lock 对象来解锁。</p><p>std::try_lock 允许一次性尝试锁定多个互斥量，如果无法成功锁定所有互斥量，则不会阻塞线程，并返回适当的结果。</p><p>std::once_flag 和 std::call_once：这些用于实现只执行一次的操作，保证在多线程环境中某个函数只会被执行一次。</p><br/><h2 id="std-shared-lock"><a href="#std-shared-lock" class="headerlink" title="std::shared_lock"></a>std::shared_lock</h2><p> 可以同时被多个线程持有，允许并发的共享访问。</p><p>pthread_rwlock_t 是 POSIX 线程库中提供的一种读写锁（Read-Write Lock）。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。 </p><br/><h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard 是一个轻量级的互斥锁封装，用于在代码块中自动锁定和解锁互斥量。它的锁定和解锁是在构造和析构函数中完成的，适用于需要在作用域内自动管理锁定的场景。 </p><br/><h2 id="std-scoped-lock"><a href="#std-scoped-lock" class="headerlink" title="std::scoped_lock"></a>std::scoped_lock</h2><p>是 C++11 引入的一个锁，用于同时锁定多个互斥量，实现死锁避免和提高代码可读性。与 std::lock 不同，std::scoped_lock 是在构造时锁定互斥量，在析构时解锁互斥量，从而确保在任何情况下都会正确释放锁。 </p><br/><h2 id="递归锁（std-recursive-mutex）"><a href="#递归锁（std-recursive-mutex）" class="headerlink" title="递归锁（std::recursive_mutex）"></a>递归锁（std::recursive_mutex）</h2><p>递归锁（std::recursive_mutex）允许同一个线程多次获取锁，这在某些递归调用的情况下非常有用。 </p><br/><h2 id="自旋锁（std-atomic-flag）"><a href="#自旋锁（std-atomic-flag）" class="headerlink" title="自旋锁（std::atomic_flag）"></a>自旋锁（std::atomic_flag）</h2><p>自旋锁不是标准库提供的，但是可以使用原子标志（std::atomic_flag）实现。它在尝试获得锁失败时，不会进入休眠状态，而是一直在一个循环中自旋等待锁被释放。适用于短时间内锁被占用的情况。</p><br/><h2 id="FIFO支持"><a href="#FIFO支持" class="headerlink" title="FIFO支持"></a>FIFO支持</h2><p>在 C++ 标准库中，std::mutex 和 std::unique_lock 是不支持 FIFO（先来先服务）策略的锁，因为它们的锁定顺序不受先后顺序的限制，而是由操作系统或编译器实现来决定。</p><p>C++17 引入了一种新的锁类型 std::shared_mutex，它在共享锁定时支持 FIFO 策略，这意味着等待共享锁的线程会按照它们请求锁的顺序依次获得锁。</p>]]></content>
    
    
    <summary type="html">c++锁的使用总结</summary>
    
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/categories/c/"/>
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>ViewDragHelper源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/bc17390a/"/>
    <id>https://blog.xxsu.xyz/article/bc17390a/</id>
    <published>2023-12-12T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.476Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="ViewDragHelper源码剖析"><a href="#ViewDragHelper源码剖析" class="headerlink" title="ViewDragHelper源码剖析"></a>ViewDragHelper源码剖析</h2><p>创建方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mHelper = ViewDragHelper.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewDragCallback</span>());<br></code></pre></td></tr></table></figure><p>消息拦截</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mEnable) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onInterceptTouchEvent(ev);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mHelper.shouldInterceptTouchEvent(ev);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>        ignored.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mEnable) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTouchEvent(event);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mHelper.processTouchEvent(event);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>        ignored.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="回调方法详解"><a href="#回调方法详解" class="headerlink" title="回调方法详解"></a>回调方法详解</h2><p>ViewDragHelper 是一个用于处理拖拽和滑动的辅助类，通常用于创建可拖拽的用户界面元素，比如实现拖拽移动或侧滑删除等功能。</p><br/><h3 id="onViewDragStateChanged-int-state"><a href="#onViewDragStateChanged-int-state" class="headerlink" title="onViewDragStateChanged(int state)"></a>onViewDragStateChanged(int state)</h3><p>当拖拽状态改变时调用，参数 state 表示当前的拖拽状态。</p><br/><h3 id="onViewPositionChanged-View-changedView-int-left-int-top-int-dx-int-dy"><a href="#onViewPositionChanged-View-changedView-int-left-int-top-int-dx-int-dy" class="headerlink" title="onViewPositionChanged(View changedView, int left, int top, int dx, int dy)"></a>onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</h3><p>当被拖拽的 View 的位置发生改变时调用，参数包括变化的 View、左上角的新位置坐标、水平和垂直方向上的位移。</p><br/><h3 id="onViewCaptured-View-capturedChild-int-activePointerId"><a href="#onViewCaptured-View-capturedChild-int-activePointerId" class="headerlink" title="onViewCaptured(View capturedChild, int activePointerId)"></a>onViewCaptured(View capturedChild, int activePointerId)</h3><p>当一个 View 被捕获时调用，参数为被捕获的 View 和触摸点的 ID。</p><br/><h3 id="onViewReleased-View-releasedChild-float-xvel-float-yvel"><a href="#onViewReleased-View-releasedChild-float-xvel-float-yvel" class="headerlink" title="onViewReleased(View releasedChild, float xvel, float yvel)"></a>onViewReleased(View releasedChild, float xvel, float yvel)</h3><p>当被捕获的 View 被释放时调用，参数包括被释放的 View 和释放时的水平和垂直速度。</p><br/><h3 id="onEdgeTouched-int-edgeFlags-int-pointerId"><a href="#onEdgeTouched-int-edgeFlags-int-pointerId" class="headerlink" title="onEdgeTouched(int edgeFlags, int pointerId)"></a>onEdgeTouched(int edgeFlags, int pointerId)</h3><p>当触摸到边缘时调用，参数包括边缘标志和触摸点的 ID。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the left edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_LEFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the right edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_RIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the top edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_TOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the bottom edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_BOTTOM</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><br/><h3 id="onEdgeLock-int-edgeFlags"><a href="#onEdgeLock-int-edgeFlags" class="headerlink" title="onEdgeLock(int edgeFlags)"></a>onEdgeLock(int edgeFlags)</h3><p>当边缘锁定时调用，返回一个布尔值表示是否锁定边缘。</p><p>如果锁定了，就不会调用onEdgeDragStarted函数。</p><br/><h3 id="onEdgeDragStarted-int-edgeFlags-int-pointerId"><a href="#onEdgeDragStarted-int-edgeFlags-int-pointerId" class="headerlink" title="onEdgeDragStarted(int edgeFlags, int pointerId)"></a>onEdgeDragStarted(int edgeFlags, int pointerId)</h3><p>当开始拖动边缘时调用，参数包括边缘标志和触摸点的 ID。</p><blockquote><p>需要注意的是，上面的3个回调函数默认都不会通知返回，需要我们额外调用mDragger.setEdgeTrackingEnabled（ViewDragHelper.EDGE_LEFT |ViewDragHelper.EDGE_TOP）来开启边缘捕捉功能。</p></blockquote><br/><h3 id="getOrderedChildIndex-int-index"><a href="#getOrderedChildIndex-int-index" class="headerlink" title="getOrderedChildIndex(int index)"></a>getOrderedChildIndex(int index)</h3><p>获取指定索引位置的子 View 的顺序。</p><br/><h3 id="getViewHorizontalDragRange-View-child"><a href="#getViewHorizontalDragRange-View-child" class="headerlink" title="getViewHorizontalDragRange(View child)"></a>getViewHorizontalDragRange(View child)</h3><p>返回水平方向上允许拖动的范围。</p><br/><h3 id="getViewVerticalDragRange-View-child"><a href="#getViewVerticalDragRange-View-child" class="headerlink" title="getViewVerticalDragRange(View child)"></a>getViewVerticalDragRange(View child)</h3><p>返回垂直方向上允许拖动的范围。</p><br/><h3 id="tryCaptureView-View-child-int-pointerId"><a href="#tryCaptureView-View-child-int-pointerId" class="headerlink" title="tryCaptureView(View child, int pointerId)"></a>tryCaptureView(View child, int pointerId)</h3><p>尝试捕获指定的 View，返回一个布尔值表示是否成功捕获。</p><p>View child：当前用户触摸的子控件的View对象。</p><p>pointerId：当前触摸此控件的手指所对应的pointerId。触摸过程中pointerId不变，但是其索引会改变。</p><p>return boolean：返回值，表示是否对这个View进行各种事件的捕捉。如果返回值为false，那么就表示不对这个View进行捕捉，在手指触摸到这个View及这个View发生变动时，ViewDragHelper.Callback中的回调函数不会有任何反馈。</p><br/><h3 id="clampViewPositionHorizontal-View-child-int-left-int-dx"><a href="#clampViewPositionHorizontal-View-child-int-left-int-dx" class="headerlink" title="clampViewPositionHorizontal(View child, int left, int dx)"></a>clampViewPositionHorizontal(View child, int left, int dx)</h3><p>在水平方向上限制 View 移动的位置。</p><p>View child：当前手指横向移动所在的子View。</p><p>int left：当前子View如果跟随手指移动，那么它即将移动到的位置的left坐标值就是这里的left。</p><p>int dx：手指横向移动的距离。</p><p>return int：返回子View的新left坐标值，系统会把该子View的left坐标移动到这个位置。在代码中如果return left，则是让View横向跟随手指移动。</p><br/><h3 id="clampViewPositionVertical-View-child-int-top-int-dy"><a href="#clampViewPositionVertical-View-child-int-top-int-dy" class="headerlink" title="clampViewPositionVertical(View child, int top, int dy)"></a>clampViewPositionVertical(View child, int top, int dy)</h3><p>在垂直方向上限制 View 移动的位置，和clampViewPositionHorizontal类似。</p><br/><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="captureChildView-View-childView-int-activePointerId"><a href="#captureChildView-View-childView-int-activePointerId" class="headerlink" title="captureChildView(View childView, int activePointerId)"></a>captureChildView(View childView, int activePointerId)</h3><p>绕过tryCaptureView，直接开启对指定View的捕捉功能。</p><p>View childView：要捕捉拖动动作的childView对象。</p><p>int activePointerId：激活当前childView进行捕捉操作的手指id。</p><p><strong>开启的捕捉功能，只会临时开启，当用户松手时，此次捕捉结束，回到初始状态。</strong></p><p><strong>通过captureChildView捕捉的childView，会根据手指的移动轨迹相对于自身的原始位置移动，而不会跑到手指下方来跟随手指移动。</strong></p>]]></content>
    
    
    <summary type="html">ViewDragHelper源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>编辑器之倒计时</title>
    <link href="https://blog.xxsu.xyz/article/eceecfb7/"/>
    <id>https://blog.xxsu.xyz/article/eceecfb7/</id>
    <published>2023-12-11T06:58:00.000Z</published>
    <updated>2024-01-01T14:06:18.940Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>平时写代码可能会忘记时间，于是乎就想着准备开发一个编辑器的倒计时插件，方便提醒自己。</p><br/><h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id(<span class="hljs-string">&quot;java&quot;</span>)<br>    id(<span class="hljs-string">&quot;idea&quot;</span>)<br>    id(<span class="hljs-string">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version <span class="hljs-string">&quot;1.7.10&quot;</span><br>    id(<span class="hljs-string">&quot;org.jetbrains.intellij&quot;</span>) version <span class="hljs-string">&quot;1.8.0&quot;</span><br>&#125;<br><br>group = <span class="hljs-string">&quot;com.xxsu&quot;</span><br>version = <span class="hljs-string">&quot;1.0&quot;</span><br><br>repositories &#123;<br>    google()<br>    mavenCentral()<br>    jcenter()<br>&#125;<br><br>dependencies &#123;<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;</span>)<br><span class="hljs-comment">//    implementation(&quot;com.github.adedayo.intellij.sdk:forms_rt:142.1&quot;)</span><br>    implementation(<span class="hljs-string">&quot;com.intellij:forms_rt:7.0.3&quot;</span>)<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Configure Gradle IntelliJ Plugin</span><br><span class="hljs-comment">// Read more: https://plugins.jetbrains.com/docs/intellij/tools-gradle-intellij-plugin.html</span><br>intellij &#123;<br>    version.set(<span class="hljs-string">&quot;2021.3.3&quot;</span>)<br>    type.set(<span class="hljs-string">&quot;IC&quot;</span>) <span class="hljs-comment">// Target IDE Platform  //IC指IDEA社区版(免费版本)，IU指旗舰版(收费版本)</span><br><br>    plugins.set(listOf(<span class="hljs-string">&quot;com.intellij.java&quot;</span>,<span class="hljs-string">&quot;android&quot;</span>))<br>&#125;<br><br>tasks &#123;<br>    <span class="hljs-comment">// Set the JVM compatibility versions</span><br>    withType&lt;JavaCompile&gt; &#123;<br>        sourceCompatibility = <span class="hljs-string">&quot;11&quot;</span><br>        targetCompatibility = <span class="hljs-string">&quot;11&quot;</span><br>    &#125;<br>    withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt; &#123;<br>        kotlinOptions.jvmTarget = <span class="hljs-string">&quot;11&quot;</span><br>    &#125;<br><br>    patchPluginXml &#123;<br><span class="hljs-comment">// 这里配置sinceBuild=213，表示插件只能被版本号大于等于2021.3版本的IDEA安装，低于这个版本的将抛无法兼容的错误</span><br>        sinceBuild.set(<span class="hljs-string">&quot;213&quot;</span>)<br>        untilBuild.set(<span class="hljs-string">&quot;223.*&quot;</span>)<br>    &#125;<br><br>    signPlugin &#123;<br>        certificateChain.set(System.getenv(<span class="hljs-string">&quot;CERTIFICATE_CHAIN&quot;</span>))<br>        privateKey.set(System.getenv(<span class="hljs-string">&quot;PRIVATE_KEY&quot;</span>))<br>        password.set(System.getenv(<span class="hljs-string">&quot;PRIVATE_KEY_PASSWORD&quot;</span>))<br>    &#125;<br><br>    publishPlugin &#123;<br>        token.set(System.getenv(<span class="hljs-string">&quot;PUBLISH_TOKEN&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h2><p>这里主要是插件的一些配置信息，也包括一些类的注册。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">applicationListeners</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        项目打开关闭监听--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;project_module.ProjectOpenCloseListener&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">topic</span>=<span class="hljs-string">&quot;com.intellij.openapi.project.ProjectManagerListener&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">applicationListeners</span>&gt;</span><br></code></pre></td></tr></table></figure><br/><h2 id="封装一个工具类来创建倒计时UI"><a href="#封装一个工具类来创建倒计时UI" class="headerlink" title="封装一个工具类来创建倒计时UI"></a>封装一个工具类来创建倒计时UI</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> time_module<br><br><span class="hljs-keyword">import</span> com.intellij.openapi.Disposable<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionGroup<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionPlaces<br><span class="hljs-keyword">import</span> com.intellij.openapi.application.ApplicationManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.project.Project<br><span class="hljs-keyword">import</span> com.intellij.openapi.util.Disposer<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.StatusBar<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.WindowManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.impl.status.widget.StatusBarWidgetsActionGroup<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.impl.status.widget.StatusBarWidgetsManager<br><span class="hljs-keyword">import</span> com.intellij.ui.awt.RelativePoint<br><span class="hljs-keyword">import</span> utils.MyPopupHandler<br><span class="hljs-keyword">import</span> utils.ToastUtils<br><span class="hljs-keyword">import</span> java.util.function.Function<br><span class="hljs-keyword">import</span> javax.swing.JComponent<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeHelper</span> : <span class="hljs-type">Disposable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> statusBar: StatusBar<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTimeStatusWidget</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>?)</span></span> &#123;<br>        project ?: <span class="hljs-keyword">return</span><br>        statusBar = WindowManager.getInstance().getStatusBar(project) ?: <span class="hljs-keyword">return</span><br>        statusBar.addWidget(TimeWidget(project), <span class="hljs-keyword">this</span>)<br><br>        <span class="hljs-keyword">val</span> group = Function &#123; am: ActionManager -&gt;<br>            <span class="hljs-keyword">val</span> action = am.getAction(StatusBarWidgetsActionGroup.GROUP_ID)<br>            <span class="hljs-keyword">if</span> (action <span class="hljs-keyword">is</span> ActionGroup) &#123;<br>                <span class="hljs-keyword">return</span><span class="hljs-symbol">@Function</span> action<br>            &#125;<br>            <span class="hljs-literal">null</span><br>        &#125;<br>        MyPopupHandler.installPopupMenu(statusBar <span class="hljs-keyword">as</span> JComponent, group, ActionPlaces.STATUS_BAR_PLACE, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br><br>        <span class="hljs-keyword">val</span> statusBarWidgetsManager: StatusBarWidgetsManager =<br>            project.getService(StatusBarWidgetsManager::<span class="hljs-keyword">class</span>.java) ?: <span class="hljs-keyword">return</span><br>        ApplicationManager.getApplication().invokeLater &#123; statusBarWidgetsManager.installPendingWidgets() &#125;<br>        Disposer.register(statusBar) &#123; statusBarWidgetsManager.disableAllWidgets() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRelativePoint</span><span class="hljs-params">()</span></span>:RelativePoint&#123;<br>        <span class="hljs-keyword">return</span> RelativePoint.getCenterOf(statusBar.component)<br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        Disposer.dispose(statusBar)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="弹框工具类"><a href="#弹框工具类" class="headerlink" title="弹框工具类"></a>弹框工具类</h2><p>用于消息提示</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyPopupHandler &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installPopupMenu</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        component: <span class="hljs-type">JComponent</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        group: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">ActionManager</span>, ActionGroup?&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        place: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        actionManager: <span class="hljs-type">ActionManager</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        menuListener: <span class="hljs-type">PopupMenuListener</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: PopupHandler &#123;<br>        <span class="hljs-keyword">if</span> (ApplicationManager.getApplication() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : PopupHandler() &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokePopup</span><span class="hljs-params">(comp: <span class="hljs-type">Component</span>?, x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> &#123;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">val</span> popupHandler: PopupHandler = <span class="hljs-keyword">object</span> : PopupHandler() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokePopup</span><span class="hljs-params">(comp: <span class="hljs-type">Component</span>?, x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">val</span> manager = actionManager ?: ActionManager.getInstance()<br>                <span class="hljs-keyword">val</span> actionGroup: ActionGroup = manager?.let &#123; group.apply(it) &#125; ?: <span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">val</span> popupMenu = manager.createActionPopupMenu(place, actionGroup)<br>                popupMenu.setTargetComponent(component)<br>                <span class="hljs-keyword">val</span> menu = popupMenu.component<br>                <span class="hljs-keyword">if</span> (menuListener != <span class="hljs-literal">null</span>) &#123;<br>                    menu.addPopupMenuListener(menuListener)<br>                &#125;<br>                menu.show(comp, x, y)<br>            &#125;<br>        &#125;<br>        component.addMouseListener(popupHandler)<br>        <span class="hljs-keyword">return</span> popupHandler<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="自定义UI组件"><a href="#自定义UI组件" class="headerlink" title="自定义UI组件"></a>自定义UI组件</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeWidget</span>(<span class="hljs-keyword">val</span> project: Project) : CustomStatusBarWidget, TextPresentation &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myLabel = JLabel(<span class="hljs-string">&quot;「00:00」&quot;</span>)<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">object</span> : ClickListener() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(e: <span class="hljs-type">MouseEvent</span>, clickCount: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>                <span class="hljs-keyword">val</span> myPopupMenu = JPopupMenu()<br>                myPopupMenu.add(<span class="hljs-keyword">object</span> : AbstractAction(<span class="hljs-string">&quot;设置倒计时&quot;</span>, IconsUtils.settingIcon) &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> &#123;<br>                        AppObserver.getInstance(project).openSettingDialog.increment()<br>                    &#125;<br>                &#125;)<br>                myPopupMenu.addSeparator()<br>                myPopupMenu.add(<span class="hljs-keyword">object</span> : AbstractAction(<span class="hljs-string">&quot;暂停/恢复&quot;</span>, getIconByStatus()) &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> &#123;<br>                        <span class="hljs-keyword">if</span> (CountDownHelper.getInstance(project).isPauseStatus()) &#123;<br>                            <span class="hljs-keyword">if</span> (!CountDownHelper.getInstance(project).resumeCountDown()) &#123;<br>                                ToastUtils.show(project, <span class="hljs-string">&quot;恢复失败,请重启开启~&quot;</span>)<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            CountDownHelper.getInstance(project).pauseCountDown()<br>                        &#125;<br>                        <span class="hljs-keyword">this</span>.putValue(SMALL_ICON, getIconByStatus())<br>                    &#125;<br>                &#125;)<br><br>                <span class="hljs-keyword">val</span> dimension: Dimension = myLabel.preferredSize<br>                <span class="hljs-keyword">val</span> at = Point(<span class="hljs-number">0</span>, -dimension.height)<br>                myPopupMenu.show(e.component, at.x - <span class="hljs-number">20</span>, at.y - <span class="hljs-number">20</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;.installOn(myLabel, <span class="hljs-literal">true</span>)<br><br>        AppObserver.getInstance(project).startCountDown.addObserver &#123;<br>            startCountDown()<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getIconByStatus</span><span class="hljs-params">()</span></span>: Icon &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (CountDownHelper.getInstance(project).isPauseStatus()) &#123;<br>            IconsUtils.stopIcon<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            IconsUtils.runningIcon<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startCountDown</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> totalMinutes = SpUtils.getIntValue(TimeConstants.SpKey.key_minutes) ?: <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (totalMinutes == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        CountDownHelper.getInstance(project).startCountDown(totalMinutes * <span class="hljs-number">60</span>, &#123;<br>            <span class="hljs-keyword">val</span> minutes = it / <span class="hljs-number">60</span><br>            <span class="hljs-keyword">val</span> seconds = it % <span class="hljs-number">60</span><br>            <span class="hljs-keyword">val</span> minutesStr = <span class="hljs-keyword">if</span> (minutes &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-string">&quot;0<span class="hljs-variable">$minutes</span>&quot;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minutes<br>            &#125;<br>            <span class="hljs-keyword">val</span> secondsStr = <span class="hljs-keyword">if</span> (seconds &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-string">&quot;0<span class="hljs-variable">$seconds</span>&quot;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                seconds<br>            &#125;<br>            myLabel.text = <span class="hljs-string">&quot;「<span class="hljs-variable">$minutesStr</span>:<span class="hljs-variable">$secondsStr</span>」&quot;</span><br>        &#125;, &#123;<br>            myLabel.text = <span class="hljs-string">&quot;「00:00」&quot;</span><br>            ToastUtils.show(<br>                project,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;SpUtils.getValue(TimeConstants.SpKey.key_minutes)&#125;</span>分钟的任务已结束，请check:\n &quot;</span><br>                        + SpUtils.getValue(TimeConstants.SpKey.key_task)<br>            )<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ID</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(statusBar: <span class="hljs-type">StatusBar</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getComponent</span><span class="hljs-params">()</span></span>: JComponent &#123;<br>        <span class="hljs-keyword">return</span> myLabel<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPresentation</span><span class="hljs-params">()</span></span>: WidgetPresentation &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTooltipText</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;点击进行更多设置&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getClickConsumer</span><span class="hljs-params">()</span></span>: Consumer&lt;MouseEvent&gt; &#123;<br>        <span class="hljs-keyword">return</span> Consumer &#123; _: MouseEvent? -&gt;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getText</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TimeWidget&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAlignment</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>        <span class="hljs-keyword">return</span> Component.CENTER_ALIGNMENT<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        CountDownHelper.getInstance(project).cancelCountDownTimer()<br>        AppObserver.getInstance(project).startCountDown.removeAllObservers()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是倒计时插件的主要代码，此外还有些小的工具类就不一一粘贴了。下面看下效果吧:)</p><br/><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/./../../images/skill-countdown/countdown.gif" alt="倒计时"></p>]]></content>
    
    
    <summary type="html">代码编辑器里用来倒计时的一个小工具</summary>
    
    
    
    <category term="工具" scheme="https://blog.xxsu.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="计时器" scheme="https://blog.xxsu.xyz/tags/%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>dagger使用总结</title>
    <link href="https://blog.xxsu.xyz/article/e8d0b96f/"/>
    <id>https://blog.xxsu.xyz/article/e8d0b96f/</id>
    <published>2023-12-10T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.471Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>dagger可以在编译时生成代码，创建实例，进行注入，同时对类型进行安全检查。</p><br/><h2 id="常用注解介绍"><a href="#常用注解介绍" class="headerlink" title="常用注解介绍"></a>常用注解介绍</h2><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>标记一个接口或抽象类，用于连接依赖的提供者和需要依赖的消费者。通过@Component注解的接口可以生成一个Dagger组件，该组件负责创建和维护依赖项的实例。</p><br/><h3 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h3><p>标记一个类，用于提供依赖项的实例。@Module注解的类包含一个或多个带有@Provides注解的方法，这些方法返回依赖项的实例。</p><br/><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h3><p>标记一个依赖项，使其成为单例实例。当一个依赖项被标记为@Singleton时，Dagger会确保只有一个实例被创建和共享。</p><br/><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>用于创建自定义的限定符注解。限定符注解允许在具有相同类型的多个依赖项之间进行区分。</p><br/><h3 id="Provides使用"><a href="#Provides使用" class="headerlink" title="@Provides使用"></a>@Provides使用</h3><p>用于标记@Module注解的类中的方法，该方法返回依赖项的实例。Dagger使用这些方法来构建和提供依赖项的实例。</p><p>如果您使用 @Provides 修饰两个方法，两个方法都返回同一个接口的不同实现实例，那么在使用 @Inject 注解进行依赖注入时，您可以通过限定符（Qualifier）来区分不同的实例。</p><br/><p>首先，您需要定义一个限定符注解，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FirstImplementation &#123;<br>&#125;<br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecondImplementation &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，您可以在 @Provides 方法中使用这些限定符注解来标识不同的实现实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Provides</span><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-meta">@FirstImplementation</span><br><span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">provideFirstImplementationA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstImplementationA</span>();<br>&#125;<br><br><span class="hljs-meta">@Provides</span><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-meta">@SecondImplementation</span><br><span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">provideSecondImplementationA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondImplementationA</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在需要注入 InterfaceA 实例的地方，您可以使用相应的限定符注解进行注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-meta">@FirstImplementation</span><br>InterfaceA implementationA;<br></code></pre></td></tr></table></figure><p>这样，Dagger 将根据限定符注解来选择正确的实现实例进行注入。</p><p>请注意，限定符注解应确保在运行时保留（使用 @Retention(RetentionPolicy.RUNTIME) 注解），以便 Dagger 在运行时可以正确解析和匹配限定符注解。</p><br/><h3 id="Binds-使用场景"><a href="#Binds-使用场景" class="headerlink" title="@Binds  使用场景"></a>@Binds  使用场景</h3><p>接口绑定：当你有一个接口，并且想要将其绑定到一个具体的实现类时，可以使用@Binds注解。</p><p>@Binds方法必须是抽象的（abstract）且没有方法体，因为它只是用于建立接口和实现类之间的绑定关系。此外，@Binds方法必须位于抽象类或接口的模块中。</p><br/><h3 id="ContributesAndroidInjector"><a href="#ContributesAndroidInjector" class="headerlink" title="@ContributesAndroidInjector"></a>@ContributesAndroidInjector</h3><ul><li><p>Activity 和 Fragment：当想要在 Activity 或 Fragment 中进行依赖注入时，可以使用 @ContributesAndroidInjector 注解来帮助 Dagger 2 自动生成相应的子组件和注入器代码。</p></li><li><p>模块的子模块：当希望在一个 Dagger 模块中包含其他模块时，可以使用 @ContributesAndroidInjector 注解来简化子模块的配置。</p></li></ul><p>模块的子模块例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentModule</span> &#123;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = [ChildModule::class])</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contributeChildInjector</span><span class="hljs-params">()</span></span>: ChildActivity<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="IntoSet"><a href="#IntoSet" class="headerlink" title="@IntoSet"></a>@IntoSet</h3><p>用于将多个实例绑定到一个 Set 集合中。这对于在依赖注入时提供多个实例的情况很有用，例如在一个接口有多个实现类时，想要将它们统一管理。</p><br/><p>以下是一个简单的例子，展示如何使用 @IntoSet 将多个实例绑定到一个 Set 中：</p><p>假设有两个实现了 Logger 接口的类：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">// 实现文件日志记录</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">// 实现控制台日志输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 Dagger 的模块中使用 @IntoSet 注解将这两个实例添加到 Set 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerModule</span> &#123;<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    Logger <span class="hljs-title function_">provideFileLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLogger</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    Logger <span class="hljs-title function_">provideConsoleLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleLogger</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，当你在依赖注入的地方请求一个 Set<Logger> 时，Dagger 将自动收集这两个实例并提供给你：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br>Set&lt;Logger&gt; loggers; <span class="hljs-comment">// Dagger 将注入包含两个 Logger 实例的 Set</span><br><br><span class="hljs-comment">// 使用 loggers 集合中的实例进行日志记录等操作</span><br></code></pre></td></tr></table></figure><p>这样，你可以将多个实例统一管理，方便地进行依赖注入和使用。</p><br/><h3 id="IntoMap"><a href="#IntoMap" class="headerlink" title="@IntoMap"></a>@IntoMap</h3><p>用于将依赖注入的实例添加到一个 Map 集合中，在 Dagger 中使用它可以方便地将多个实例与特定的键关联起来。</p><p>以下是一个简单的例子，展示如何使用 @IntoMap 将多个实例添加到 Map 中：</p><p>假设有一个接口 Processor，有两个实现类 AddProcessor 和 SubtractProcessor，并且想要将它们关联到一个 Map&lt;String, Processor&gt; 中，其中键为操作类型（”add” 或 “subtract”）。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 Dagger 的模块中使用 @IntoMap 注解将这些实例添加到 Map 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessorModule</span> &#123;<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoMap</span><br>    <span class="hljs-meta">@StringKey(&quot;add&quot;)</span> <span class="hljs-comment">// 键为 &quot;add&quot;</span><br>    Processor <span class="hljs-title function_">provideAddProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddProcessor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoMap</span><br>    <span class="hljs-meta">@StringKey(&quot;subtract&quot;)</span> <span class="hljs-comment">// 键为 &quot;subtract&quot;</span><br>    Processor <span class="hljs-title function_">provideSubtractProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubtractProcessor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，当你在依赖注入的地方请求一个 Map&lt;String, Processor&gt; 时，Dagger 将自动收集这些实例并以特定的键关联起来：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br>Map&lt;String, Processor&gt; processorMap; <span class="hljs-comment">// Dagger 将注入包含键值对的 Map</span><br><br><span class="hljs-comment">// 使用 processorMap 中的实例进行对应操作的处理</span><br><span class="hljs-type">Processor</span> <span class="hljs-variable">addProcessor</span> <span class="hljs-operator">=</span> processorMap.get(<span class="hljs-string">&quot;add&quot;</span>);<br><span class="hljs-type">Processor</span> <span class="hljs-variable">subtractProcessor</span> <span class="hljs-operator">=</span> processorMap.get(<span class="hljs-string">&quot;subtract&quot;</span>);<br></code></pre></td></tr></table></figure><p>这样，你就可以使用键值对来管理和获取不同类型的实例，很方便地进行依赖注入和使用。</p><br/><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>可参考NextCloud开源项目</p><p>https://github.com/nextcloud/talk-android/tree/master</p><p>https://github.com/nextcloud/android</p>]]></content>
    
    
    <summary type="html">dagger使用总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>mockserver部署总结</title>
    <link href="https://blog.xxsu.xyz/article/20276bc2/"/>
    <id>https://blog.xxsu.xyz/article/20276bc2/</id>
    <published>2023-12-09T06:58:00.000Z</published>
    <updated>2023-12-22T14:08:51.700Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>官方网址：https://www.mock-server.com/</p><p>容器部署：https://www.mock-server.com/mock_server&#x2F;running_mock_server.html#docker_container</p><br/><h2 id="命令行添加期望"><a href="#命令行添加期望" class="headerlink" title="命令行添加期望"></a>命令行添加期望</h2><p>官方例子： https://github.com/mock-server/mockserver/blob/master/mockserver-examples/curl_examples.md</p><p>期望添加失败，可能是端口不正确导致；可以用docker ps查看端口；如下图所示，本地访问应该使用32768这个端口；</p><p><img src="/./skill-mockserver/image-20231222133537654.png" alt="image-20231222133537654"></p><p>例子：</p><p>1、实现简单的接口mock：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">curl -X PUT <span class="hljs-string">&#x27;localhost:1090/mockserver/expectation&#x27;</span> \<br>-d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;httpRequest&quot;: &#123;</span><br><span class="hljs-string">    &quot;method&quot;: &quot;GET&quot;,</span><br><span class="hljs-string">    &quot;path&quot;: &quot;/test&quot;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;httpResponse&quot;: &#123;</span><br><span class="hljs-string">    &quot;body&quot;: &quot;OK&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>2、使用自定义的类回调</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">curl -v -X PUT <span class="hljs-string">&quot;http://localhost:1080/mockserver/expectation&quot;</span> -d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    &quot;httpRequest&quot; : &#123;</span><br><span class="hljs-string">        &quot;path&quot; : &quot;/some.*&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;httpResponseClassCallback&quot; : &#123;</span><br><span class="hljs-string">        &quot;callbackClass&quot; : &quot;org.mockserver.examples.mockserver.CallbackActionExamples$TestExpectationResponseCallback&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&#x27;</span> <br></code></pre></td></tr></table></figure><br/><h2 id="代码实现动态返回"><a href="#代码实现动态返回" class="headerlink" title="代码实现动态返回"></a>代码实现动态返回</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">cd mockserver-examples<br>mvn clean <span class="hljs-keyword">package</span>    #打包成mockserver-examples-<span class="hljs-number">5.15</span><span class="hljs-number">.0</span>.jar<br>拷贝 mockserver-examples-<span class="hljs-number">5.15</span><span class="hljs-number">.0</span>.jar 到libs目录下<br><br>docker run --rm -d -p <span class="hljs-number">1080</span>:<span class="hljs-number">1080</span> -v $(pwd)/expectation.json:/tmp/mockserver/expectation.json -v $(pwd)/config:/config -v $(pwd)/libs:/libs -w /tmp/mockserver --name my-mock-server mockserver/mockserver -logLevel INFO -serverPort <span class="hljs-number">1080</span><br><br>请求 http:<span class="hljs-comment">//localhost:1080/mockserver/dashboard</span><br></code></pre></td></tr></table></figure><br/><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>docker run在run后面添加–rm 只要关闭就自动删除。</p><p>查看所有的期望的id：<br> ​curl -X GET http://localhost:1080/mockserver/expectations​​</p><p>删除对应期望id的配置，其他保留：<br> ​curl -X PUT “http://localhost:1080/mockserver/clear" -d '{    "id": "676a5f8a-8b9b-4b79-9a49-b535f54f9e20" }'​​</p><p>列出当前MockServer中的所有请求和期望：result.json  是当前命令的路径：<br> ​curl -X PUT http://localhost:1090/mockserver/retrieve > result.json​​</p><p>put操作失败可能是端口不正确。</p><br/><h2 id="踩坑："><a href="#踩坑：" class="headerlink" title="踩坑："></a>踩坑：</h2><p>config中的mockserver.properties的功能没有仔细参考官网给的例子（https://raw.githubusercontent.com/mock-server/mockserver/master/mockserver.example.properties），参数配置不齐全；重要是这几个参数，导致配置文件一直没有生效；</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">mockserver.persistExpectations=<span class="hljs-literal">true</span><br>mockserver.persistedExpectationsPath=/tmp/mockserver/expectation.json<br>mockserver.initializationJsonPath=/tmp/mockserver/expectation.json<br>mockserver.watchInitializationJson=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><br/><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MockServer 和 EasyMock 都是用于进行测试和模拟的工具，但它们在实现和使用方式上有一些区别。MockServer相对重量级，学习成本较高，如果只是简单的接口测试，那还是使用EasyMock方便些。</p>]]></content>
    
    
    <summary type="html">mockserver部署总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mockserver" scheme="https://blog.xxsu.xyz/tags/mockserver/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用总结</title>
    <link href="https://blog.xxsu.xyz/article/65761caa/"/>
    <id>https://blog.xxsu.xyz/article/65761caa/</id>
    <published>2023-12-08T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.483Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><blockquote><p>Docker 是一个开源的容器化平台，主要用于打包、发布和运行应用程序。它的作用在于提供了一种轻量级、可移植、自包含的环境，使应用程序能够在不同的环境中快速部署和运行。</p></blockquote><br/><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>以下是一些常用的 Docker 命令：</p><ol><li>镜像相关命令：<ul><li>docker images：列出本地所有镜像。</li><li>docker pull &lt;镜像名&gt;：拉取镜像。</li><li>docker rmi &lt;镜像ID&gt;：删除指定镜像。</li></ul></li><li>容器相关命令：<ul><li>docker ps：列出正在运行的容器。</li><li>docker ps -a：列出所有容器，包括已停止的。</li><li>docker inspect <container_name_or_id> 查看容器的详细信息。</li><li>docker run &lt;镜像名&gt;：运行一个容器。</li><li>docker start &lt;容器ID或名称&gt;：启动一个停止的容器。</li><li>docker stop &lt;容器ID或名称&gt;：停止一个运行中的容器。</li><li>docker rm &lt;容器ID或名称&gt;：删除一个容器。</li></ul></li><li>容器日志：<ul><li>docker logs &lt;容器ID或名称&gt;：查看容器日志。</li><li>docker logs -f &lt;容器ID或名称&gt;：实时查看容器日志。</li></ul></li><li>容器操作：<ul><li>docker exec -it &lt;容器ID或名称&gt; &lt;命令&gt;：在运行中的容器中执行命令。</li><li>docker cp &lt;本地路径&gt; &lt;容器ID或名称&gt;:&lt;容器内路径&gt;：将本地文件复制到容器中。</li></ul></li><li>网络相关命令：<ul><li>docker network ls：列出 Docker 网络。</li><li>docker network inspect &lt;网络名称&gt;：查看网络详细信息。</li></ul></li><li>其他命令：<ul><li>docker-compose up&#x2F;down：通过 Docker Compose 启动&#x2F;停止服务。</li><li>docker version：查看 Docker 版本信息。</li><li>docker info：查看 Docker 系统信息。</li></ul></li></ol><br/><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><p>在docker inspect输出结果中，查找 “IPAddress” 和 “HostPort” 字段，分别对应容器的 IP 地址和端口号。</p><p><strong>查看挂载的源文件</strong>： docker inspect my-container | grep Source</p><p><strong>修改容器的名称</strong>： docker rename &lt;容器ID或容器名&gt; &lt;新容器名&gt;   。需要注意的是，容器名不能包含特殊字符（如 &#x2F;、: 等）以及空格。</p><p>为正在运行的容器进行文件挂载：docker exec -it -v &#x2F;path&#x2F;to&#x2F;local&#x2F;file:&#x2F;path&#x2F;to&#x2F;container&#x2F;file CONTAINER COMMAND</p><p><strong>如何保证容器停止后重启内容数据保留？</strong></p><p>使用volume来创建Docker 卷，例如 docker volume create xx-data，并在启动时使用-v 将docker卷关联到本地。</p><br/><h2 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker Compose简介"></a>Docker Compose简介</h2><blockquote><p>Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。它允许您通过一个单独的配置文件来定义和管理多个容器，这些容器可以相互协作组成一个完整的应用程序。</p></blockquote><br/><h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><ol><li>创建一个 docker-compose.yml 文件：在项目目录中创建一个名为 docker-compose.yml 的配置文件。</li><li>定义服务：在 docker-compose.yml 文件中，可以定义每个服务的配置。每个服务通常对应一个容器，可以指定容器的镜像、端口映射、环境变量、数据卷等。</li><li>定义服务间的关系：如果应用程序由多个服务组成，可以在 docker-compose.yml 文件中定义它们之间的依赖关系和通信方式。这样 Docker Compose 就知道如何启动和连接这些服务。</li><li>启动应用程序：使用 docker-compose up 命令，Docker Compose 将根据配置文件创建和启动所有的服务。</li><li>停止应用程序：使用 docker-compose down 命令，Docker Compose 将停止并删除应用程序中的所有服务和相关容器。</li></ol>]]></content>
    
    
    <summary type="html">Docker使用总结</summary>
    
    
    
    <category term="容器" scheme="https://blog.xxsu.xyz/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="Docker" scheme="https://blog.xxsu.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Flutter FFI源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/96ba32cc/"/>
    <id>https://blog.xxsu.xyz/article/96ba32cc/</id>
    <published>2023-12-07T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.480Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="ffi调用原理"><a href="#ffi调用原理" class="headerlink" title="ffi调用原理"></a>ffi调用原理</h2><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> DynamicLibrary nativeAddLib = Platform.isAndroid<br>    ? DynamicLibrary.open(<span class="hljs-string">&#x27;libnative_add.so&#x27;</span>)<br>    : DynamicLibrary.process();<br></code></pre></td></tr></table></figure><p>由此可见，调用方法主要是先加载整个动态链接库，再进一步调用库中对应的方法。</p><p>好在Android studio有提供专门的ffi插件模板，可以自动创建ffi插件，统一对动态链接库进行包装，提供对flutter可以调用的方法。</p><br/><h2 id="ffi插件使用"><a href="#ffi插件使用" class="headerlink" title="ffi插件使用"></a>ffi插件使用</h2><h3 id="普通方法调用"><a href="#普通方法调用" class="headerlink" title="普通方法调用"></a>普通方法调用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sumPtr =<br>    _lookup&lt;ffi.NativeFunction&lt;ffi.IntPtr <span class="hljs-built_in">Function</span>(ffi.IntPtr, ffi.IntPtr)&gt;&gt;(<br>        <span class="hljs-string">&#x27;sum&#x27;</span>);<br><span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sum = _sumPtr.asFunction&lt;<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br></code></pre></td></tr></table></figure><br/><h3 id="异步方法调用"><a href="#异步方法调用" class="headerlink" title="异步方法调用"></a>异步方法调用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">int</span>&gt; sumAsync(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> SendPort helperIsolateSendPort = <span class="hljs-keyword">await</span> _helperIsolateSendPort;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> requestId = _nextSumRequestId++;<br>  <span class="hljs-keyword">final</span> _SumRequest request = _SumRequest(requestId, a, b);<br>  <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">int</span>&gt; completer = Completer&lt;<span class="hljs-built_in">int</span>&gt;();<br>  _sumRequests[requestId] = completer;<br>  helperIsolateSendPort.send(request);<br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;<br></code></pre></td></tr></table></figure><p>开启一个helperIsolate，拿到helperIsolateSendPort，之后可以复用该SendPort。</p><p>_helperIsolateSendPort 是一个在定义时立即执行的异步函数表达式（immediately invoked asynchronous function expression，IIFE），它会在定义时执行一次，然后将结果赋给 _helperIsolateSendPort 变量。代码中巧妙使用了completer，结合final Map&lt;int, Completerint&gt;&gt; _sumRequests &#x3D; &lt;int,Completer<int>&gt;{};实现了请求数据和completer的一一对应。</p><p>源码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">The SendPort belonging to the helper isolate.</span></span><br>Future&lt;SendPort&gt; _helperIsolateSendPort = () <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">// The helper isolate is going to send us back a SendPort, which we want to</span><br>  <span class="hljs-comment">// wait for.</span><br>  <span class="hljs-keyword">final</span> Completer&lt;SendPort&gt; completer = Completer&lt;SendPort&gt;();<br><br>  <span class="hljs-comment">// Receive port on the main isolate to receive messages from the helper.</span><br>  <span class="hljs-comment">// We receive two types of messages:</span><br>  <span class="hljs-comment">// 1. A port to send messages on.</span><br>  <span class="hljs-comment">// 2. Responses to requests we sent.</span><br>  <span class="hljs-keyword">final</span> ReceivePort receivePort = ReceivePort()<br>    ..listen((<span class="hljs-built_in">dynamic</span> data) &#123;<br>      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> SendPort) &#123;<br>        <span class="hljs-comment">// The helper isolate sent us the port on which we can sent it requests.</span><br>        completer.complete(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> _SumResponse) &#123;<br>        <span class="hljs-comment">// The helper isolate sent us a response to a request we sent.</span><br>        <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">int</span>&gt; completer = _sumRequests[data.id]!;<br>        _sumRequests.remove(data.id);<br>        completer.complete(data.result);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">&#x27;Unsupported message type: <span class="hljs-subst">$&#123;data.runtimeType&#125;</span>&#x27;</span>);<br>    &#125;);<br><br>  <span class="hljs-comment">// Start the helper isolate.</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn((SendPort sendPort) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> ReceivePort helperReceivePort = ReceivePort()<br>      ..listen((<span class="hljs-built_in">dynamic</span> data) &#123;<br>        <span class="hljs-comment">// On the helper isolate listen to requests and respond to them.</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> _SumRequest) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> result = _bindings.sum_long_running(data.a, data.b);<br>          <span class="hljs-keyword">final</span> _SumResponse response = _SumResponse(data.id, result);<br>          sendPort.send(response);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">&#x27;Unsupported message type: <span class="hljs-subst">$&#123;data.runtimeType&#125;</span>&#x27;</span>);<br>      &#125;);<br><br>    <span class="hljs-comment">// Send the port to the main isolate on which we can receive requests.</span><br>    sendPort.send(helperReceivePort.sendPort);<br>  &#125;, receivePort.sendPort);<br><br>  <span class="hljs-comment">// Wait until the helper isolate has sent us back the SendPort on which we</span><br>  <span class="hljs-comment">// can start sending requests.</span><br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;();<br></code></pre></td></tr></table></figure><br/><h3 id="ffigen插件"><a href="#ffigen插件" class="headerlink" title="ffigen插件"></a>ffigen插件</h3><p>dart在调用c方法时，是不可以直接通过方法名调用的，需要像jni那样包装下。而ffigen插件主要的功能就是提供自动包装转化功能。</p><p>如下所示，将c的_sum方法转为dart的_sum方法，之后便可以直接调用了。</p><p>插件官网： https://pub.dev/packages/ffigen</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ffi&#x27;</span> <span class="hljs-keyword">as</span> ffi;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeLibrary</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> ffi.Pointer&lt;T&gt; <span class="hljs-built_in">Function</span>&lt;T <span class="hljs-keyword">extends</span> ffi.NativeType&gt;(<span class="hljs-built_in">String</span> symbolName)<br>      _lookup;<br>  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)<br>      : _lookup = dynamicLibrary.lookup;<br>  NativeLibrary.fromLookup(<br>      ffi.Pointer&lt;T&gt; <span class="hljs-built_in">Function</span>&lt;T <span class="hljs-keyword">extends</span> ffi.NativeType&gt;(<span class="hljs-built_in">String</span> symbolName)<br>          lookup)<br>      : _lookup = lookup;<br><br>  <span class="hljs-built_in">int</span> sum(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> _sum(a, b);<br>  &#125;<br><br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sumPtr = _lookup&lt;ffi.NativeFunction&lt;ffi.Int <span class="hljs-built_in">Function</span>(ffi.Int, ffi.Int)&gt;&gt;(<span class="hljs-string">&#x27;sum&#x27;</span>);<br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sum = _sumPtr.asFunction&lt;<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="是否可以调用c-方法呢？"><a href="#是否可以调用c-方法呢？" class="headerlink" title="是否可以调用c++方法呢？"></a>是否可以调用c++方法呢？</h3><p>直接调用是不支持的，不过可以通过c间接调用。方式和JNI类似，需要使用extern “C”包裹C++方法的实现，然后打包成动态链接库，通过DynamicLibrary.open进行加载。</p><p>官方文档：https://flutter.cn/docs/development/platform-integration/android/c-interop</p>]]></content>
    
    
    <summary type="html">FlutterFFI源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Flutter" scheme="https://blog.xxsu.xyz/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>c++ xlog源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/5ee48928/"/>
    <id>https://blog.xxsu.xyz/article/5ee48928/</id>
    <published>2023-12-06T06:58:00.000Z</published>
    <updated>2024-01-01T13:08:23.228Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="库简介"><a href="#库简介" class="headerlink" title="库简介"></a>库简介</h2><p>xlog属于mars项目的一个小组件，主要解决线上程序崩溃后日志消失的问题。崩溃日志往往在内存中，程序crash后，无法记录内存中的日志，导致无法捕获到对应关键的crash日志信息。该库主要采用mmap的方法进行日志系统设计，主要功能包含压缩、加密、写入文件等。</p><p>源码地址：https://github.com/Tencent/mars/tree/49c4bcf49fd8a80bfc8e1efaabdc71202542f4d3/mars/xlog</p><br/><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>开辟一块内存，对文件进行映射，日志到来时通通写入到该内存中，当内存内容达到阈值时，开始将内存中的内容上锁，另一个线程开始工作，将该内存中的日志信息写入到硬盘文件中。这里的内存也叫高速缓冲区，避免了频繁地对文件写操作。</p><br/><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为啥会映射一小块，等到小块满了之后再挨个读取写入到文件中，而不是一开始就对整个文件进行映射呢？或者采用滑动窗口方式，先映射一小块，满了再往后滑动窗口，实现文件分块映射呢？</p><p>看源码发现项目中主要使用的是boost的方法来做内存映射。</p><p>boost库中的文件映射源码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Path&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mapped_file::open</span><span class="hljs-params">(<span class="hljs-type">const</span> basic_mapped_file_params&lt;Path&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123; delegate_.<span class="hljs-built_in">open_impl</span>(p); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Path&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mapped_file::open</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Path&amp; path, mapmode flags, </span></span><br><span class="hljs-params"><span class="hljs-function">    size_type length, stream_offset offset )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">param_type <span class="hljs-title">p</span><span class="hljs-params">(path)</span></span>;<br>    p.flags = flags;<br>    p.length = length;<br>    p.offset = offset;<br>    <span class="hljs-built_in">open</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码来看似乎是可行的，xlog主要是使用第一个open方法进行映射文件，那第二个方法呢？这里我做了个小实验，使用第二个open方法进行文件映射，遗憾的是结果并不成功，会报错。内部是不支持，无论是更改窗口大小或者更改偏移量offset，都是会映射失败的，有感兴趣的朋友可以尝试下。</p>]]></content>
    
    
    <summary type="html">日志库xlog源码剖析</summary>
    
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/categories/c/"/>
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>FlutterBoost源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/a56a3a15/"/>
    <id>https://blog.xxsu.xyz/article/a56a3a15/</id>
    <published>2023-12-04T06:58:00.000Z</published>
    <updated>2024-01-01T13:48:06.133Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><blockquote><p>FlutterBoost 的理念是使用 Flutter 就像使用 WebView 一样简单。FlutterBoost 会为您处理页面分辨率。唯一需要关心的是页面的名称（通常可以是 URL）。</p></blockquote><p>官方源码： https://github.com/alibaba/flutter_boost</p><br/><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ul><li>Flutter SDK升级不需要Boost升级</li><li>简化架构</li><li>简化界面</li><li>双端接口统一设计</li><li>解决了首要问题</li><li>Android不需要区分AndroidX和Support</li></ul><br/><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="FlutterApplication初始化"><a href="#FlutterApplication初始化" class="headerlink" title="FlutterApplication初始化"></a>FlutterApplication初始化</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 1. initialize default engine</span><br><span class="hljs-comment">// 2. set delegate</span><br><span class="hljs-comment">// 3. register ActivityLifecycleCallbacks</span><br></code></pre></td></tr></table></figure><p>声明周期监听，前后台变化isBackForegroundEventOverridden参数控制，只要没有复写前后台方法，那么默认原生的前后台变化和flutter同步，同时解决对外提供的currentActivity方法。</p><p>预加载操作：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (!engine.getDartExecutor().isExecutingDart()) &#123;<br>    <span class="hljs-comment">// Pre-warm the cached FlutterEngine.</span><br>    engine.getNavigationChannel().setInitialRoute(options.initialRoute());<br>    engine.getDartExecutor().executeDartEntrypoint(<span class="hljs-keyword">new</span> DartExecutor.DartEntrypoint(<br>            FlutterMain.findAppBundlePath(), options.dartEntrypoint()), options.dartEntrypointArgs());<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="flutterview构造"><a href="#flutterview构造" class="headerlink" title="flutterview构造"></a>flutterview构造</h3><p>flutterboost在构造flutterview时传入一个surfaceview或者textureview，为啥会传入这两个呢，而不是view？主要的原因还是flutter页面的会有大量的图形渲染的操作，需要一个支持硬件加速的view的来显示。</p><p>将surface进行传入：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Start rendering on the previous surface.</span><br><span class="hljs-comment">// This surface is typically `FlutterSurfaceView` or `FlutterTextureView`.</span><br>renderSurface.attachToRenderer(renderer);<br></code></pre></td></tr></table></figure><p>下面是flutterview的创建过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><br>View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(</span><br><span class="hljs-params">    LayoutInflater inflater,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> ViewGroup container,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> flutterViewId,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> shouldDelayFirstAndroidViewDraw)</span> &#123;<br>  Log.v(TAG, <span class="hljs-string">&quot;Creating FlutterView.&quot;</span>);<br>  ensureAlive();<br><br>  <span class="hljs-keyword">if</span> (host.getRenderMode() == RenderMode.surface) &#123;<br>    <span class="hljs-type">FlutterSurfaceView</span> <span class="hljs-variable">flutterSurfaceView</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterSurfaceView</span>(<br>            host.getContext(), host.getTransparencyMode() == TransparencyMode.transparent);<br><br>    <span class="hljs-comment">// Allow our host to customize FlutterSurfaceView, if desired.</span><br>    host.onFlutterSurfaceViewCreated(flutterSurfaceView);<br><br>    <span class="hljs-comment">// Create the FlutterView that owns the FlutterSurfaceView.</span><br>    flutterView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterView</span>(host.getContext(), flutterSurfaceView);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">FlutterTextureView</span> <span class="hljs-variable">flutterTextureView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterTextureView</span>(host.getContext());<br><br>    flutterTextureView.setOpaque(host.getTransparencyMode() == TransparencyMode.opaque);<br><br>    <span class="hljs-comment">// Allow our host to customize FlutterSurfaceView, if desired.</span><br>    host.onFlutterTextureViewCreated(flutterTextureView);<br><br>    <span class="hljs-comment">// Create the FlutterView that owns the FlutterTextureView.</span><br>    flutterView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterView</span>(host.getContext(), flutterTextureView);<br>  &#125;<br><br>  <span class="hljs-comment">// Add listener to be notified when Flutter renders its first frame.</span><br>  flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener);<br><br>  Log.v(TAG, <span class="hljs-string">&quot;Attaching FlutterEngine to FlutterView.&quot;</span>);<br>  flutterView.attachToFlutterEngine(flutterEngine);<br>  flutterView.setId(flutterViewId);<br><br>  <span class="hljs-type">SplashScreen</span> <span class="hljs-variable">splashScreen</span> <span class="hljs-operator">=</span> host.provideSplashScreen();<br><br>  <span class="hljs-keyword">if</span> (splashScreen != <span class="hljs-literal">null</span>) &#123;<br>    Log.w(<br>        TAG,<br>        <span class="hljs-string">&quot;A splash screen was provided to Flutter, but this is deprecated. See&quot;</span><br>            + <span class="hljs-string">&quot; flutter.dev/go/android-splash-migration for migration steps.&quot;</span>);<br>    <span class="hljs-type">FlutterSplashView</span> <span class="hljs-variable">flutterSplashView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterSplashView</span>(host.getContext());<br>    flutterSplashView.setId(ViewUtils.generateViewId(FLUTTER_SPLASH_VIEW_FALLBACK_ID));<br>    flutterSplashView.displayFlutterViewWithSplash(flutterView, splashScreen);<br><br>    <span class="hljs-keyword">return</span> flutterSplashView;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (shouldDelayFirstAndroidViewDraw) &#123;<br>    delayFirstAndroidViewDraw(flutterView);<br>  &#125;<br>  <span class="hljs-keyword">return</span> flutterView;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="Pigeon插件使用"><a href="#Pigeon插件使用" class="headerlink" title="Pigeon插件使用"></a>Pigeon插件使用</h3><p>通过查看flutterBoost源码可以发现，内部flutter和原生通信的主要借助了一个名叫Pigeon的代码生成器工具。Pigeon是一个flutter插件，主要有以下优点：</p><ul><li>自动生成通信代码：根据开发者定义的数据结构和方法生成相应的Dart和原生平台的通信代码，简化了跨平台通信的实现过程。</li><li>定义消息传递格式： 开发者可以使用Pigeon定义数据结构和方法，包括参数和返回值的类型、方法的名称等，以便在Flutter和原生代码之间进行消息传递。</li><li>支持异步通信：能够处理异步方法调用，允许Flutter与原生代码之间进行异步操作。</li><li>增强了类型安全性： 通过Pigeon生成的代码，可以提供类型安全性，避免在不同平台之间传递数据时的类型错误。</li></ul><p>@HostApi()&#x2F;&#x2F; 用于Flutter调用原生的方法，原生方法实现</p><p>@FlutterApi()&#x2F;&#x2F; 用于原生调用Flutter的方法，Flutter方法实现</p><p>最终自动生成的接口方法等可参考Messages类。</p><blockquote><p>思考：如何自动生成代码的呢？</p><p>build_runner和source_gen</p></blockquote><br/><h3 id="自定义的FlutterBoostPlugin插件"><a href="#自定义的FlutterBoostPlugin插件" class="headerlink" title="自定义的FlutterBoostPlugin插件"></a>自定义的FlutterBoostPlugin插件</h3><p>为何会有flutter插件，主要是允许开发者在 Flutter 应用中集成原生代码或第三方库，调用 flutterEngine.getPlugins() 方法可以获得当前 Flutter 引擎中加载的所有插件的列表。</p><p>插件注册多数情况下是在原生端完成，利用原生平台的特定功能和能力，极少数是在flutter端注册的。</p><p>来看看FlutterBoostPlugin插件的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlutterBoostPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlutterPlugin</span>, NativeRouterApi, ActivityAware &#123;<br></code></pre></td></tr></table></figure><p>NativeRouterApi：主要是原生导航相关的接口方法，用于在flutter端调用；</p><p>ActivityAware：用于在 Flutter 插件中获取和管理 Android Activity 的接口，在Activity 生命周期中接收回调。</p><p>功能作用：</p><p>用于在 Flutter 和原生 Android（或 iOS）之间建立桥接，提供了一种在原生应用中嵌入 Flutter 页面的机制。它的主要功能包括：页面路由管理、混合开发支持、生命周期管理、跨平台支持等。</p><br/><h3 id="FlutterViewContainer"><a href="#FlutterViewContainer" class="headerlink" title="FlutterViewContainer"></a>FlutterViewContainer</h3><p>实现类主要有：FlutterBoostActivity、FlutterBoostFragment、FlutterBoostView；</p><p>其中FlutterBoostView继承于LifecycleView、而LifecycleView继承于FrameLayout；</p><p>ViewContainer的显示过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onContainerAppeared</span><span class="hljs-params">(FlutterViewContainer container, Runnable onPushRouteComplete)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uniqueId</span> <span class="hljs-operator">=</span> container.getUniqueId();<br>    <span class="hljs-keyword">if</span> (isDebugLoggingEnabled()) Log.d(TAG, <span class="hljs-string">&quot;#onContainerAppeared: &quot;</span> + uniqueId + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">this</span>);<br>    FlutterContainerManager.instance().activateContainer(uniqueId, container);<br>    pushRoute(uniqueId, container.getUrl(), container.getUrlParams(), reply -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (FlutterContainerManager.instance().isTopContainer(uniqueId)) &#123;<br>            <span class="hljs-keyword">if</span> (onPushRouteComplete != <span class="hljs-literal">null</span>) &#123;<br>                onPushRouteComplete.run();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//onContainerDisappeared并非异步触发，为了匹配对应，onContainerShow也不做异步</span><br>    onContainerShow(uniqueId);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="BoostInterceptor使用"><a href="#BoostInterceptor使用" class="headerlink" title="BoostInterceptor使用"></a>BoostInterceptor使用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;T&gt; pushWithInterceptor&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>      <span class="hljs-built_in">String?</span> name, <span class="hljs-built_in">bool</span> isFromHost, <span class="hljs-built_in">bool</span> isFlutterPage,<br>      &#123;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;? arguments,<br>      <span class="hljs-built_in">String?</span> uniqueId,<br>      <span class="hljs-built_in">bool?</span> withContainer,<br>      <span class="hljs-built_in">bool</span> opaque = <span class="hljs-keyword">true</span>&#125;) &#123;<br>    Logger.log(<span class="hljs-string">&#x27;pushWithInterceptor, uniqueId=<span class="hljs-subst">$uniqueId</span>, name=<span class="hljs-subst">$name</span>&#x27;</span>);<br>    <span class="hljs-keyword">var</span> pushOption = BoostInterceptorOption(name,<br>        uniqueId: uniqueId,<br>        isFromHost: isFromHost,<br>        arguments: arguments ?? &lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&#123;&#125;);<br>    InterceptorState&lt;BoostInterceptorOption&gt;? state =<br>        InterceptorState&lt;BoostInterceptorOption&gt;(pushOption);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> interceptor <span class="hljs-keyword">in</span> interceptors) &#123;<br>      <span class="hljs-keyword">final</span> pushHandler = PushInterceptorHandler();<br>      interceptor.onPrePush(state!.data, pushHandler);<br><br>      <span class="hljs-comment">// user resolve or do nothing</span><br>      <span class="hljs-keyword">if</span> (pushHandler.state?.type != InterceptorResultType.next) &#123;<br>        Logger.log(<span class="hljs-string">&#x27;The page was intercepted by user. name:<span class="hljs-subst">$name</span>, &#x27;</span><br>            <span class="hljs-string">&#x27;isFromHost=<span class="hljs-subst">$isFromHost</span>, isFlutterPage=<span class="hljs-subst">$isFlutterPage</span>&#x27;</span>);<br>        <span class="hljs-keyword">return</span> Future&lt;T&gt;.value(state.data <span class="hljs-keyword">as</span> T);<br>      &#125;<br>      state = pushHandler.state <span class="hljs-keyword">as</span> InterceptorState&lt;BoostInterceptorOption&gt;?;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (state?.type == InterceptorResultType.next) &#123;<br>      pushOption = state!.data;<br>      <span class="hljs-keyword">if</span> (isFromHost) &#123;<br>        pushContainer(name,<br>            uniqueId: pushOption.uniqueId,<br>            isFromHost: isFromHost,<br>            arguments: pushOption.arguments);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFlutterPage) &#123;<br>          <span class="hljs-keyword">return</span> pushWithResult(pushOption.name,<br>              uniqueId: pushOption.uniqueId,<br>              arguments: pushOption.arguments,<br>              withContainer: withContainer!,<br>              opaque: opaque);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">final</span> params = CommonParams()<br>            ..pageName = pushOption.name<br>            ..arguments = pushOption.arguments;<br>          nativeRouterApi.pushNativeRoute(params);<br>          <span class="hljs-keyword">return</span> pendNativeResult(pushOption.name);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Future&lt;T&gt;.value();<br>  &#125;<br></code></pre></td></tr></table></figure><br/><h3 id="BoostFlutterBinding"><a href="#BoostFlutterBinding" class="headerlink" title="BoostFlutterBinding"></a>BoostFlutterBinding</h3><p>主要作用：接管flutter的生命周期。</p><p>BoostFlutterBinding对WidgetsFlutterBinding进行了扩展，复写了initInstances和handleAppLifecycleStateChanged这两个方法。</p><p>思考：BoostFlutterBinding是如何拦截到生命周期进行处理的呢？</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>  ...<br>  CustomFlutterBinding();<br>  ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFlutterBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WidgetsFlutterBinding</span></span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">BoostFlutterBinding</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>从官方给的demo看必须要new一个FlutterBinding实例才可以，其实原理和WidgetsFlutterBinding的ensureInitialized()方法类似。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> WidgetsBinding ensureInitialized() &#123;<br>  <span class="hljs-keyword">if</span> (WidgetsBinding._instance == <span class="hljs-keyword">null</span>) &#123;<br>    WidgetsFlutterBinding();<br>  &#125;<br>  <span class="hljs-keyword">return</span> WidgetsBinding.instance;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BoostContainer使用"><a href="#BoostContainer使用" class="headerlink" title="BoostContainer使用"></a>BoostContainer使用</h3><br/><h3 id="如何理解BoostContainerWidget"><a href="#如何理解BoostContainerWidget" class="headerlink" title="如何理解BoostContainerWidget"></a>如何理解BoostContainerWidget</h3><p>持有container，小组件所属的container；</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">The Widget build for a [BoostContainer]</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">It overrides the &quot;==&quot; and &quot;hashCode&quot;,</span></span><br><span class="hljs-comment">/// <span class="language-markdown">to avoid rebuilding when its parent element call element.updateChild</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoostContainerWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  BoostContainerWidget(&#123;LocalKey? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.container&#125;)<br>      : <span class="hljs-keyword">super</span>(key: container.key);<br><br>  <span class="hljs-comment">/// <span class="language-markdown">The container this widget belong</span></span><br>  <span class="hljs-keyword">final</span> BoostContainer container;<br></code></pre></td></tr></table></figure><p>BoostContainerWidget外面包裹的是OverlayEntry，源码如下，该OverlayEntry是不透明，且状态保留的，可以进行复用。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerOverlayEntry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OverlayEntry</span> </span>&#123;<br>  ContainerOverlayEntry(BoostContainer container)<br>      : containerUniqueId = container.pageInfo.uniqueId,<br>        <span class="hljs-keyword">super</span>(<br>            builder: (ctx) =&gt; BoostContainerWidget(container: container),<br>            opaque: <span class="hljs-keyword">true</span>,<br>            maintainState: <span class="hljs-keyword">true</span>);<br><br>  <span class="hljs-comment">/// <span class="language-markdown">This overlay&#x27;s id, which is the same as the it&#x27;s related container</span></span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String?</span> containerUniqueId;<br></code></pre></td></tr></table></figure><br/><h3 id="flutter页面核心部分"><a href="#flutter页面核心部分" class="headerlink" title="flutter页面核心部分"></a>flutter页面核心部分</h3><p>页面的父widget是一个Overlay组件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">      child: Listener(<br>          onPointerDown: _handlePointerDown,<br>          onPointerUp: _handlePointerUpOrCancel,<br>          onPointerCancel: _handlePointerUpOrCancel,<br>          child: Overlay(<br>            key: overlayKey,<br>            initialEntries: <span class="hljs-keyword">const</span> &lt;OverlayEntry&gt;[],<br>          ))));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双层路由栈"><a href="#双层路由栈" class="headerlink" title="双层路由栈"></a>双层路由栈</h3><br/><h2 id="路由导航–NavigatorExt"><a href="#路由导航–NavigatorExt" class="headerlink" title="路由导航–NavigatorExt"></a>路由导航–NavigatorExt</h2><p>这个类让用户调用“Navigator.pop()”等于BoostNavigator.instance.pop()</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Future&lt;T?&gt; pushNamed&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<span class="hljs-built_in">String</span> routeName,<br>    &#123;<span class="hljs-built_in">Object?</span> arguments&#125;) &#123;<br>...<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> pop&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;([T? result]) &#123;<br>  <span class="hljs-comment">// Taking over container page</span><br>  <span class="hljs-keyword">if</span> (!canPop()) &#123;<br>    BoostNavigator.instance.pop(result ?? &#123;&#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">super</span>.pop(result);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的源码看出，只是把pop方法复写了，为啥可以实现等价调用呢？是在什么时候调用到BoostNavigator.instance.pop()的呢？</p><p>继续，进入Navigator.of(context)方法查看，可以发现它会调用findAncestorStateOfType来查找，从父节点找最近的State，实现如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> NavigatorState of(<br> BuildContext context, &#123;<br> <span class="hljs-built_in">bool</span> rootNavigator = <span class="hljs-keyword">false</span><br>&#125;) &#123;<br>...<br>navigator = navigator ?? context.findAncestorStateOfType&lt;NavigatorState&gt;();<br></code></pre></td></tr></table></figure><br/><h3 id="BoostContainerState"><a href="#BoostContainerState" class="headerlink" title="BoostContainerState"></a>BoostContainerState</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Widget build(BuildContext context) &#123;<br>  <span class="hljs-keyword">return</span> HeroControllerScope(<br>      controller: HeroController(),<br>      child: NavigatorExt(<br>        key: container._navKey,<br>        pages: <span class="hljs-built_in">List</span>&lt;Page&lt;<span class="hljs-built_in">dynamic</span>&gt;&gt;.of(container.pages),<br>        onPopPage: (route, result) &#123;<br>          <span class="hljs-keyword">if</span> (route.didPop(result)) &#123;<br>            <span class="hljs-keyword">assert</span>(route.settings <span class="hljs-keyword">is</span> BoostPage);<br>            _updatePagesList(route.settings <span class="hljs-keyword">as</span> BoostPage, result);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;,<br>        observers: &lt;NavigatorObserver&gt;[<br>          BoostNavigatorObserver(),<br>        ],<br>      ));<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>flutterboost核心使用单引擎处理flutter，原生页面跳转flutter页面，用到了一个flutteractivity类。</li><li>flutterfragment主要是在fragment中集成flutter，flutteractivity则是在activity中展示完整的flutter页面，而flutterfragmentactivity则是在activity页面中展示部分flutter页面。</li><li>package io.flutter.embedding.android：主要是放一些Android中展示flutter相关的一些工具类或者接口等。例如要在原生页面中展示一个flutterview，则需要把自定义的类写到这个包中；</li><li>flutterview的构造需要一个surfaceview或者textureview来显示flutter内容，为啥一定需要这么两个中的一个，因为他们都支持硬件加速，flutterview会涉及到大量的图像渲染内容，且是在原生中显示，则需要一个view来承接内容。</li><li>flutterboost主要是通过Pigeon插件来实现原生交互，flutter端的页面均继承于OverlayEntry，插件有自定义Navigator，用于对原来的Navigator.pop等方法进行补充。在原生页面中打开flutter页面，本质上是启动一个Activity来承载显示flutter的view，如果是跳转不同的flutter页面，可以通过url来定位，并且flutter端有自定义的拦截器，可以对跳转等操作进行拦截处理。</li></ol>]]></content>
    
    
    <summary type="html">FlutterBoost源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Flutter" scheme="https://blog.xxsu.xyz/tags/Flutter/"/>
    
  </entry>
  
</feed>
