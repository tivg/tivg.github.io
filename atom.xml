<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueSky&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xxsu.xyz/"/>
  <updated>2021-10-19T01:22:44.135Z</updated>
  <id>https://xxsu.xyz/</id>
  
  <author>
    <name>Xiao Su</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>碎片</title>
    <link href="https://xxsu.xyz/article/88d274c3/"/>
    <id>https://xxsu.xyz/article/88d274c3/</id>
    <published>2021-09-25T07:46:00.000Z</published>
    <updated>2021-10-19T01:22:44.135Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h2><p>错误日志：</p><p>Could not inflate Behavior subclass FloatingActionButton</p><p>解决方案：FloatingActionButton的layout_behavior使用完整路径，不要使用相对路径；</p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>setPriority在Thread.start()之前</p><h2 id="merge失败"><a href="#merge失败" class="headerlink" title="merge失败"></a>merge失败</h2><p>如下所示，重复写了，导致merge资源失败，并没有报出具体错误位置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="所有命令失效"><a href="#所有命令失效" class="headerlink" title="所有命令失效"></a>所有命令失效</h2><p>export PATH=”/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin”</p>]]></content>
    
    <summary type="html">
    
      快速提高命令输入效率
    
    </summary>
    
    
      <category term="技巧" scheme="https://xxsu.xyz/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="bat命令" scheme="https://xxsu.xyz/tags/bat%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>字节码插桩</title>
    <link href="https://xxsu.xyz/article/cad98d1c/"/>
    <id>https://xxsu.xyz/article/cad98d1c/</id>
    <published>2021-09-12T07:46:00.000Z</published>
    <updated>2021-10-19T01:33:36.657Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ASM简介"><a href="#ASM简介" class="headerlink" title="ASM简介"></a>ASM简介</h2><p>ASM提供了两种API来生成和转换已编译类:</p><ul><li>核心API，以基于事件形式来表示类；</li><li>树API，以基于对象形式来表示类;</li></ul><p>应用场景：ButterKnife，Dagger、无痕埋点，性能监控等</p><h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p>基于事件的API把类看作是一系列事件来表示，每一个类的事件表示一个类的元素。类似解析XML的SAX。</p><p>基于对象的API将类表示成一棵对象树，每个对象表示类的一部分。类似解析XML的DOM</p><ul><li>事件API内存占用少于对象API，因为事件API不需要在内存中创建和存储对象树</li><li>事件API实现难度比对象API大，因为事件API在任意时刻类中只有一个元素可使用，但是对象API能获得整个类。</li></ul><h2 id="字节代码指令"><a href="#字节代码指令" class="headerlink" title="字节代码指令"></a>字节代码指令</h2><p>字节代码指令由一个标识该指令的操作码和固定数目的参数组成:</p><ul><li>操作码是一个无符号字节值——即字节代码名，由助记符号标识</li><li>参数是静态值，确定了精确的指令行为，在操作码之后给出</li></ul><p><strong>ILOAD</strong>, <strong>LLOAD</strong>, <strong>FLOAD</strong>, <strong>DLOAD</strong> 和 <strong>ALOAD</strong> 指令读取一个局部变量，并将它的值压到操作数栈中。</p><p>它们的参数是必须读取的局部变量的索引 <em>i</em>。</p><p><strong>ILOAD</strong> 用于加载一个 <strong>boolean</strong>、<strong>byte</strong>、 <strong>char</strong>、<strong>short</strong> 或 <strong>int</strong> 局部变量。</p><p><strong>LLOAD</strong>、<strong>FLOAD</strong> 和 <strong>DLOAD</strong> 分别用于加载 <strong>long</strong>、<strong>float</strong> 或 <strong>double</strong> 值。(<strong>LLOAD</strong> 和 <strong>DLOAD</strong> 实际加载两个槽 <em>i</em> 和 <em>i</em>+1)。</p><p>最后，<strong>ALOAD</strong> 用于加载任意非基元值，即对 象和数组引用。</p><p>与之对应，<strong>ISTORE</strong>、<strong>LSTORE</strong>、<strong>FSTORE</strong>、<strong>DSTORE</strong> 和 <strong>ASTORE</strong> 指令从操作数栈 中弹出一个值，并将它存储在由其索引 i 指定的局部变量中。</p><p><strong>POP</strong>弹出栈顶部的值</p><p><strong>DUP</strong>压入顶部栈值的一个副本</p><p><strong>SWAP</strong>弹出两个值，并按逆序压入它们</p><p><strong>ACONST</strong>_<strong>NULL</strong>压入<strong>null</strong> </p><p><strong>ICONST</strong><em><strong>0</strong>压入 <strong>int</strong> 值 0</em></p><p><strong>FCONST</strong>_<strong>0</strong> 压入 <strong>0f</strong></p><p><strong>DCONST_0</strong> 压入 <strong>0d</strong></p><p><strong>BIPUSH</strong> <em>b</em> 压入字节值 <em>b</em></p><p><strong>SIPUSH</strong> <em>s</em> 压入 <strong>short</strong> 值 <em>s</em></p><p><strong>LDC</strong> <em>cst</em> 压入任意 <strong>int</strong>、<strong>float</strong>、<strong>long</strong>、<strong>double</strong>、<strong>String</strong> 或 <strong>class *<em>常量 *</em>cst</strong> </p><p><strong>xADD</strong>、<strong>xSUB</strong>、<strong>xMUL</strong>、<strong>xDIV</strong> 和 <strong>xREM</strong> 对应于<strong>+</strong>、<strong>-</strong>、<strong>***、</strong>/<strong>和</strong>%<strong>运算，其中 **x</strong> 为 <strong>I</strong>、 <strong>L</strong>、<strong>F</strong> 或 <strong>D</strong> 之一</p><p>类似地，还有其他对应于<strong>&lt;&lt;</strong>、<strong>&gt;&gt;</strong>、<strong>&gt;&gt;&gt;</strong>、<strong>|</strong>、<strong>&amp;</strong>和<strong>^</strong>运算的指令，用于处理<strong>int</strong>和<strong>long</strong>值。</p><p><strong>I2F</strong>, <strong>F2D</strong>, <strong>L2D</strong> 等将数值由一种数值类型转换为另一种 类型。</p><p><strong>CHECKCAST</strong> <em>t</em> 将一个引用值转换为类型 <em>t</em>。</p><p><strong>NEW</strong> <em>type*指令将 一个 *type</em> 类型的新对象压入栈中</p><p><strong>GETFIELD</strong> <em>owner name desc</em> 弹出一个对象引用，并压入其 <em>name</em> 字段中的值。</p><p><strong>PUTFIELD</strong> <em>owner name desc</em> 弹出一个值和一个对象引用，并将这个值存储在它的 <em>name</em> 字段中</p><p><strong>INVOKEVIRTUAL</strong> <em>owner name desc</em> 调用在 类 <em>owner</em> 中定义的 <em>name</em> 方法，其方法描述符为 <em>desc</em></p><p><strong>INVOKESTATIC</strong> 用于静态方法</p><p><strong>INVOKESPECIAL</strong> 用于私有方法和构造器</p><p><strong>INVOKEINTERFACE</strong> 用于接口中定义的方法</p><p><strong>INVOKEDYNAMIC</strong>  用于新动态方法调用机制（对于 Java 7 中的类）</p><p><strong>x</strong> <strong>ALOAD</strong>指令弹出一个索引和一个数组，并压入此索引处数组元素的值。</p><p><strong>x</strong> <strong>ASTORE</strong> 指令弹出一个值、一个索引和一个数组，并将这个值存储在该数组的这一索引处</p><p><strong>x</strong> 可以是 <strong>I</strong>、<strong>L</strong>、<strong>F</strong>、<strong>D</strong> 或 <strong>A</strong>，还可以是 <strong>B</strong>、<strong>C</strong> 或 <strong>S</strong>。</p><p><strong>IFEQ</strong> <em>label</em> 从栈中弹出一个 <strong>int</strong> 值，如果这个值为 0，则跳转到由这个 <em>label</em> 指定的指令处</p><p><strong>IFNE</strong> 或 <strong>IFGE</strong></p><p><strong>TABLESWITCH</strong> 和<strong>LOOKUPSWITCH</strong> 对应于 <strong>switch</strong> Java 指令。</p><p><strong>x</strong> <strong>RETURN</strong>和<strong>RETURN</strong>指令用于终止一个方法的执行，并将其结果返回给调用者</p><p><strong>RETURN</strong> 用于返回 <strong>void</strong> 的方法，<strong>x ** **RETURN</strong> 用于其他方法。</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> f;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.f;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setF</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getter</strong> 方法的字节码</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ALOAD</span> <span class="string">0</span></span><br><span class="line"><span class="attr">GETFIELD</span> <span class="string">pkg/Bean f I</span></span><br><span class="line"><span class="attr">IRETURN</span></span><br></pre></td></tr></table></figure><p><strong>setter</strong> 方法的字节码</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ALOAD</span> <span class="string">0</span></span><br><span class="line"><span class="attr">ILOAD</span> <span class="string">1</span></span><br><span class="line"><span class="attr">PUTFIELD</span> <span class="string">pkg/Bean f I</span></span><br><span class="line"><span class="attr">RETURN</span></span><br></pre></td></tr></table></figure><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAndSetF</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (f &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.f = f;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ILOAD <span class="number">1</span></span><br><span class="line">IFLT label</span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">ILOAD <span class="number">1</span></span><br><span class="line">PUTFIELD pkg/Bean f I GOTO end</span><br><span class="line"><span class="string">label:</span></span><br><span class="line">      NEW java<span class="regexp">/lang/</span>IllegalArgumentException</span><br><span class="line">      DUP</span><br><span class="line">      INVOKESPECIAL java<span class="regexp">/lang/</span>IllegalArgumentException &lt;init&gt; ()V</span><br><span class="line">      ATHROW</span><br><span class="line"><span class="string">end:</span></span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> d)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       Thread.sleep(d);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">TRYCATCHBLOCK <span class="keyword">try</span> <span class="keyword">catch</span> <span class="keyword">catch</span> java<span class="regexp">/lang/</span>InterruptedException <span class="string">try:</span></span><br><span class="line">      LLOAD <span class="number">0</span></span><br><span class="line">      INVOKESTATIC java<span class="regexp">/lang/</span>Thread sleep (J)V</span><br><span class="line">      RETURN</span><br><span class="line"><span class="string">catch:</span></span><br><span class="line">      INVOKEVIRTUAL java<span class="regexp">/lang/</span>InterruptedException printStackTrace ()V</span><br><span class="line">      RETURN</span><br></pre></td></tr></table></figure><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><p>visitFieldInsn ： 访问某个成员变量的指令，支持GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.</p><p>visitFrame ：访问当前局部变量表和操作数栈中元素的状态，参数就是局部变量表和操作数栈的内容</p><p>visitIincInsn ： 访问自增指令</p><p>visitVarInsn ：访问局部变量指令，就是取局部变量变的值放入操作数栈</p><p>visitMethodInsn ：访问方法指令，就是调用某个方法，支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.</p><p>visitInsn ： 访问无操作数的指令，例如nop，duo等等</p><p>visitTypeInsn：访问type指令，即将一个类的全限定名作为参数然后new一个对象压入操作数栈中</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>自定义插件（官网）： <a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/custom_plugins.html</a></p><p>asm文档（官网）：<a href="https://www.javadoc.io/doc/org.ow2.asm/asm/4.0/org/objectweb/asm/MethodVisitor.html" target="_blank" rel="noopener">https://www.javadoc.io/doc/org.ow2.asm/asm/4.0/org/objectweb/asm/MethodVisitor.html</a></p>]]></content>
    
    <summary type="html">
    
      对编译后的class文件进行修改或替换操作
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="ASM插桩" scheme="https://xxsu.xyz/tags/ASM%E6%8F%92%E6%A1%A9/"/>
    
  </entry>
  
  <entry>
    <title>插件kotlin化</title>
    <link href="https://xxsu.xyz/article/32d3c5f7/"/>
    <id>https://xxsu.xyz/article/32d3c5f7/</id>
    <published>2021-08-13T07:46:00.000Z</published>
    <updated>2021-10-19T01:33:55.760Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>新版本的官方Gradle插件，都已经全部使用Kotlin来编写。用法比较简洁，如下所示</p><p>文件改变：</p><p>buld.gradle.kts</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `java-gradle-plugin`</span><br><span class="line">    id(<span class="string">"org.jetbrains.kotlin.jvm"</span>) version <span class="string">"1.3.72"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(platform(<span class="string">"org.jetbrains.kotlin:kotlin-bom"</span>))</span><br><span class="line">    implementation(<span class="string">"com.android.tools.build:gradle:4.1.1"</span>)</span><br><span class="line">    implementation(<span class="string">"org.ow2.asm:asm:9.1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradlePlugin &#123;</span><br><span class="line">    <span class="keyword">val</span> greeting <span class="keyword">by</span> plugins.creating &#123;</span><br><span class="line">        id = <span class="string">"asmtest"</span></span><br><span class="line">        implementationClass = <span class="string">"com.yw.asm.MyPlugin"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">java.targetCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure><blockquote><p>tips：通过gradle init命令可以生成Kotlin版本的插件默认代码</p></blockquote>]]></content>
    
    <summary type="html">
    
      gradle插件经历java、groovy，最后到kotlin，语法更加简洁高效
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="插件kotlin化" scheme="https://xxsu.xyz/tags/%E6%8F%92%E4%BB%B6kotlin%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>自定义插件</title>
    <link href="https://xxsu.xyz/article/a2759747/"/>
    <id>https://xxsu.xyz/article/a2759747/</id>
    <published>2021-08-12T07:46:00.000Z</published>
    <updated>2021-10-19T01:33:25.826Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="自定义Gradle-插件"><a href="#自定义Gradle-插件" class="headerlink" title="自定义Gradle-插件"></a>自定义Gradle-插件</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在gradle中，插件大概可以分为三种类型，第一种是.gradle文件的插件，通过apply from的方式进行引用；第二种是插件对象，通过apply plugin的方式进行引用；第三种是单独项目的插件。</p><p>.gradle 形式的用得并不多，相对比较简单。这里主要介绍对象型插件的自定义方式。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java-library'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java-gradle-plugin'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"com.android.tools.build:gradle:4.2.1"</span></span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm:9.2'</span></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm-util:9.2'</span></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm-commons:9.2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradlePlugin &#123;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        greeting &#123;</span><br><span class="line">            id = <span class="string">'com.xs.track_asm'</span></span><br><span class="line">            implementationClass = <span class="string">'com.xs.track_asm.TrackPlugin'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.xs.track_asm'</span></span><br><span class="line">version = <span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        pom.groupId = <span class="string">'com.xs.track_asm'</span></span><br><span class="line">        pom.artifactId = <span class="string">'track_asm'</span></span><br><span class="line">        pom.version = <span class="string">'1.0.0'</span></span><br><span class="line">        repository(<span class="string">url:</span> uri(<span class="string">'../repos'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        groovy &#123;</span><br><span class="line">            srcDir <span class="string">'src/main/groovy'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resources &#123;</span><br><span class="line">            srcDir <span class="string">'src/main/resources'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>从gradle-7.0开始，apply plugin: ‘maven’  被移除掉了，因此uploadArchives 等方法将无法使用。需要用maven-publish 进行替换。</p><h2 id="gradle7-0之前"><a href="#gradle7-0之前" class="headerlink" title="gradle7.0之前"></a>gradle7.0之前</h2><p>导入maven</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'maven'</span></span><br></pre></td></tr></table></figure><p>发布配置</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        pom.groupId = <span class="string">'com.xs.track_asm'</span></span><br><span class="line">        pom.artifactId = <span class="string">'track_asm'</span></span><br><span class="line">        pom.version = <span class="string">'1.0.0'</span></span><br><span class="line">        repository(<span class="string">url:</span> uri(<span class="string">'../repos'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布命令：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">./gradlew uploadArchives</span><br></pre></td></tr></table></figure><h2 id="gradle7-0之后"><a href="#gradle7-0之后" class="headerlink" title="gradle7.0之后"></a>gradle7.0之后</h2><p>导入maven</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'maven-publish'</span></span><br></pre></td></tr></table></figure><p>发布配置</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        mavenJava(MavenPublication) &#123;</span><br><span class="line">            groupId <span class="string">'com.xs.track_asm'</span></span><br><span class="line">            artifactId <span class="string">'track_asm'</span></span><br><span class="line">            version <span class="string">'1.0.0'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'../repos'</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布命令：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">./gradlew publish</span><br></pre></td></tr></table></figure><h3 id="权限拒绝"><a href="#权限拒绝" class="headerlink" title="权限拒绝"></a>权限拒绝</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">zsh:</span> permission <span class="string">denied:</span> ./gradlew</span><br></pre></td></tr></table></figure><p>执行： </p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">chmod +<span class="symbol">x</span> gradlew</span><br></pre></td></tr></table></figure><h2 id="打包文档"><a href="#打包文档" class="headerlink" title="打包文档"></a>打包文档</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">javadoc &#123;</span><br><span class="line">    options &#123;</span><br><span class="line">        <span class="comment">//防止注释出现乱码</span></span><br><span class="line">        encoding <span class="string">"UTF-8"</span></span><br><span class="line">        charSet <span class="string">'UTF-8'</span></span><br><span class="line">        author <span class="literal">true</span></span><br><span class="line">        version <span class="literal">true</span></span><br><span class="line">        links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h2><p>优点：在buildSrc中定义的插件，可以直接在其他module中运用</p><p>即直接apply具体的类，而不是其发布名称，不管做什么修改，都能马上体现，而不需要等到重新发布版本。</p>]]></content>
    
    <summary type="html">
    
      对需要封装的逻辑进一步封装，以插件的形式进行依赖
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="自定义插件" scheme="https://xxsu.xyz/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>groovy 学习</title>
    <link href="https://xxsu.xyz/article/435ae83e/"/>
    <id>https://xxsu.xyz/article/435ae83e/</id>
    <published>2021-07-10T07:46:00.000Z</published>
    <updated>2021-10-19T01:33:02.541Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h2><p>使用‘.@’直接访问变量，跳过默认的getter/setter方法调用。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>1..5  包含范围</p><p>5..1  降序排列</p><p>1..&lt;5  独占范围 (开区间)</p><p>‘a’..’z’  范围也可以由字符组成</p><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>使用 def 关键字定义一个方法，方法不需要指定返回值类型，参数类型，方法体内的最后一行会自动作为返回值，而不需要return关键字</p><p>定义方法时，如果参数没有返回值类型，可以省略 def，使用 void 即可</p><p>实际上不管有没有返回值，Groovy 中返回的都是 Object 类型</p><p>类的构造方法，避免添加 def 关键字</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>Groovy中没有基本数据类型，全是引用类型，即使定义了基础类型，也会被转换成对应的包装类</strong></p><ul><li><p>在 Groovy 中，== 就相当于 Java 的 equals</p></li><li><p>比较两个对象是否是同一个，使用 .is()</p></li><li><p>**表示次方运算符</p></li></ul><h2 id="强大的Switch"><a href="#强大的Switch" class="headerlink" title="强大的Switch"></a>强大的Switch</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> result = <span class="string">'xxxx'</span></span><br><span class="line"><span class="keyword">switch</span> (result)&#123;</span><br><span class="line">    <span class="keyword">case</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="string">'yyy'</span>]:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包可以通过 .call 方法来调用</p><p>每个闭包中都含有 <strong>this、owner 和 delegate</strong> 这三个内置对象</p><ul><li>this 永远指向定义该闭包最近的类对象，就近原则</li><li>owner 、delegate 指向定义该闭包的类对象或者闭包对象</li><li>三者区别：this 和 owner 默认是只读的，delegate 可写的。</li></ul><h2 id="trait关键字"><a href="#trait关键字" class="headerlink" title="trait关键字"></a>trait关键字</h2><p>trait这个是Groovy中新加的类型，但是其实他就是一种介于抽象类和接口之间的类型；trait中可以定义抽象方法(即不实现)，也可以定义正常方法；使用的时候，和接口一样，也是要implement的,非抽象类实现是需要实现其抽象方法。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyTrait</span>&#123;</span></span><br><span class="line">      <span class="keyword">abstract</span> <span class="keyword">void</span> test();</span><br><span class="line">      <span class="keyword">void</span> play()&#123;</span><br><span class="line">         prinlt(<span class="string">"play"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="title">implement</span> <span class="title">MyTrait</span>&#123;</span></span><br><span class="line">       <span class="meta">@Override</span> </span><br><span class="line">       <span class="keyword">void</span> test()&#123;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      基于java的一种简洁而高效的编程语言
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="groovy" scheme="https://xxsu.xyz/tags/groovy/"/>
    
  </entry>
  
  <entry>
    <title>gradle执行流程</title>
    <link href="https://xxsu.xyz/article/8e10e406/"/>
    <id>https://xxsu.xyz/article/8e10e406/</id>
    <published>2021-06-23T07:46:00.000Z</published>
    <updated>2021-10-19T01:32:47.876Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="gradle执行流程"><a href="#gradle执行流程" class="headerlink" title="gradle执行流程"></a>gradle执行流程</h2><p>Gradle.buildStarted()</p><p>初始化阶段</p><ul><li>setting.gradle</li><li>Gradle.settingsEvaluated()</li><li>Gradle.projectsLoaded()</li></ul><p>配置阶段</p><ul><li>Gradle.beforeProject()&amp;Project.beforeEvaluate()</li><li>build.gradle(确定任务子集和配置task)</li><li>Gradle.afterProject()&amp;Project.afterEvaluate()</li><li>Gradle.projectsEvaluated()&amp;Gradle.taskGraph.whenReady()</li></ul><p>执行阶段</p><ul><li>Gradle.taskGraph.beaforeTask()</li><li>执行Task中的Actions</li><li>Gradle.taskGraph.afterTask()</li></ul><p>Gradle.buildFinish()</p>]]></content>
    
    <summary type="html">
    
      掌握好gradle，事半功倍
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="gradle" scheme="https://xxsu.xyz/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>arr打包</title>
    <link href="https://xxsu.xyz/article/4e400033/"/>
    <id>https://xxsu.xyz/article/4e400033/</id>
    <published>2021-06-17T07:46:00.000Z</published>
    <updated>2021-10-19T01:26:22.094Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="jar与aar区别"><a href="#jar与aar区别" class="headerlink" title="jar与aar区别"></a>jar与aar区别</h2><ul><li>*.jar：只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。</li><li>*.aar：包含所有资源 ，class 以及 res 资源文件全部包含</li></ul><h2 id="打包AAR"><a href="#打包AAR" class="headerlink" title="打包AAR"></a>打包AAR</h2><p>对于成型的项目(有依赖)，我们可以直接在项目中New一个Moudle 然后把项目复制到Moudle中，或者重新复制出来一个当前项目，然后在复制的项目中直接把此项目修改成AAR。</p><p>把apply plugin: ‘com.android.application’修改成apply plugin: ‘com.android.library’</p><p>去掉defaultConfig下的applicationId</p><p>修改application</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:allowBackup</span>=<span class="string">“false”</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:supportsRtl</span>=<span class="string">“true”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注释掉启动的Activity启动的action</p><p>AAR中是没有Application的,我们可以单独写一个Options类，提供给调用者，让他传递过来application，这样我们就可以在这个类中做一些初始化操作了。</p><p>直接build–&gt;Make Moudle app 就可以生成aar了！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>1.</strong> 主项目需要依赖AAR中所依赖的远程库，否则会出现ClassNotFound异常</p><p><strong>2.</strong> 资源命名最好统统加上你的项目名字前缀，比如图片资源、string、color、dimens、layout等等，反正res目录下所有文件最好都使用统一的加前缀命名，防止跟宿主app下的资源重复，因为aar引用跟源码引用起到的效果一样一样的，所有很容易出现资源重复引用的问题，所以加上前缀非常有必要。</p><p><strong>3.</strong> 如果在aar的MyAppliction里面使用了类的管理器，那么在打包成aar的时候需要将代码抽出来做个独立的类管理器，记住一点，打包成aar之后所有和application有关的东西都要检查替换，避免出现空指针异常。<br><strong>4.</strong> AAR模块用butterknife需要把资源R改为R2(批量替换)</p>]]></content>
    
    <summary type="html">
    
      arr打包处理
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="arr打包" scheme="https://xxsu.xyz/tags/arr%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>代码混淆配置</title>
    <link href="https://xxsu.xyz/article/8d839750/"/>
    <id>https://xxsu.xyz/article/8d839750/</id>
    <published>2021-06-05T07:46:00.000Z</published>
    <updated>2021-10-19T00:37:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>主要功能：优化代码，防止反编译</p><p>打开方式： minifyEnabled</p><p>proguard-android.txt是Android提供的默认混淆配置文件</p><p><strong>混淆命令</strong></p><ul><li>keep：保留类和类中的成员，防止被混淆或移除</li><li>keepnames：保留类和类中的成员，防止被混淆，成员没有被引用会被移除</li><li>keepclassmembers：只保留类中的成员，防止被混淆或移除</li><li>keepclassmembernames：只保留类中的成员，防止被混淆，成员没有引用会被移除</li><li>keepclasseswithmembers：保留类和类中的成员，防止被混淆或移除，保留指明的成员</li><li>keepclasseswithmembernames：保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除</li></ul><p><strong>混淆通配符</strong></p><ul><li><code>&lt;field&gt;</code>：匹配类中的所有字段</li><li><code>&lt;method&gt;</code>：匹配类中所有的方法</li><li><code>&lt;init&gt;</code>：匹配类中所有的构造函数</li><li><code>*</code>： 匹配任意长度字符，不包含包名分隔符(.)</li><li><code>**</code>： 匹配任意长度字符，包含包名分隔符(.)</li><li><code>***</code>： 匹配任意参数类型</li></ul><p>keep的规则的格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[keep命令] [类] &#123;</span><br><span class="line">        [成员]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span> <span class="comment">//不显示log</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            signingConfig signingConfigs.config</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="aar插件配置方式"><a href="#aar插件配置方式" class="headerlink" title="aar插件配置方式"></a>aar插件配置方式</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ···</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ···</span><br><span class="line">        consumerProguardFile <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      代码混淆可以提高APP反编译的安全性以及优化代码
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="代码混淆" scheme="https://xxsu.xyz/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>对象深度拷贝</title>
    <link href="https://xxsu.xyz/article/dcc2a71f/"/>
    <id>https://xxsu.xyz/article/dcc2a71f/</id>
    <published>2021-05-22T07:46:00.000Z</published>
    <updated>2021-10-19T01:32:29.244Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>深度拷贝对象的方式有很多，有基于构造函数的，也有借助第三方库的，这里介绍两种常见的方式</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>基于Cloneable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> na;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNa</span><span class="params">(String na)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.na = na;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String na;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">K</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        K k = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            k = (K) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    K k = <span class="keyword">new</span> K();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> F <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        F f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f = (F) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        f = <span class="keyword">new</span> F();</span><br><span class="line">        f.k = f.k.clone();</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>采用字节流的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> F <span class="title">copy</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bao);</span><br><span class="line">            oos.writeObject(f);</span><br><span class="line">            oos.close();</span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bao.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            obj = ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (F) obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      深度拷贝对象
    
    </summary>
    
    
      <category term="java" scheme="https://xxsu.xyz/categories/java/"/>
    
    
      <category term="对象拷贝" scheme="https://xxsu.xyz/tags/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基础操作</title>
    <link href="https://xxsu.xyz/article/bb06284f/"/>
    <id>https://xxsu.xyz/article/bb06284f/</id>
    <published>2021-04-02T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="二叉树基础操作"><a href="#二叉树基础操作" class="headerlink" title="二叉树基础操作"></a>二叉树基础操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 二叉树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉树基础操作 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">422</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">55</span>, <span class="number">64</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfsSearch</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; re : res) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(re.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height == res.size()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(height).add(node.data);</span><br><span class="line">        dfs(node.left, res, height + <span class="number">1</span>);</span><br><span class="line">        dfs(node.right, res, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfsSearch</span><span class="params">(Node tree)</span></span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= bfs(tree);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; re : res) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(re.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; bfs(Node root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node node= queue.poll();</span><br><span class="line">                <span class="keyword">assert</span> node != <span class="keyword">null</span>;</span><br><span class="line">                list.add(node.data);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            insert(root, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">insert</span><span class="params">(Node node, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data &lt;= node.data) &#123;</span><br><span class="line">            node.left= insert(node.left, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right= insert(node.right, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        printTree(node.left);</span><br><span class="line">        printTree(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=node.left;</span><br><span class="line">        node.left=node.right;</span><br><span class="line">        node.right=temp;</span><br><span class="line">        invert(node.left);</span><br><span class="line">        invert(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=searchMax(node.left);</span><br><span class="line">        <span class="keyword">int</span> right= searchMax(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(node.data,Math.max(left,right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDeep</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=maxDeep(node.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxDeep(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> balance(node)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">balance</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=balance(node.left);</span><br><span class="line">        <span class="keyword">int</span> right=balance(node.right);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>||right==-<span class="number">1</span>||Math.abs(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node tree = createTree(a2);</span><br><span class="line">        printTree(tree);</span><br><span class="line">        dfsSearch(tree);</span><br><span class="line">        bfsSearch(tree);</span><br><span class="line">        invert(tree);</span><br><span class="line">        bfsSearch(tree);</span><br><span class="line">        System.out.println(searchMax(tree));</span><br><span class="line">        System.out.println(maxDeep(tree));</span><br><span class="line">        System.out.println(isBalance(tree));</span><br><span class="line">        <span class="comment">//        System.out.println(Arrays.toString(qsort(arr, 0, arr.length - 1)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树常见基础操作
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://xxsu.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树非递归遍历</title>
    <link href="https://xxsu.xyz/article/1062d183/"/>
    <id>https://xxsu.xyz/article/1062d183/</id>
    <published>2021-03-12T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.851Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历_非递归"></a>前序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 前序遍历<span class="title">_</span>非递归 </span>&#123;</span><br><span class="line">    <span class="comment">//    非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                list.add(root.data);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更简洁的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            list.add(node.data);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历_非递归"></a>中序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mid</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        list.add(node.data);</span><br><span class="line">        root=node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历_非递归"></a>后序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 后序遍历<span class="title">_</span>非递归 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(<span class="number">0</span>, root.data);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树前中后三种非递归遍历实现
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://xxsu.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>异步流的方法详解</title>
    <link href="https://xxsu.xyz/article/76ae8ac8/"/>
    <id>https://xxsu.xyz/article/76ae8ac8/</id>
    <published>2021-02-17T11:22:00.000Z</published>
    <updated>2021-02-21T08:45:10.716Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a>flowOn 操作符</h2><p>该函数用于更改流发射的上下文。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变消耗 CPU 代码上下文的正确方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">1</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">1</span></span><br><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">2</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">2</span></span><br><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">3</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">3</span></span><br></pre></td></tr></table></figure><p> flowOn 操作符已改变流的默认顺序性。 现在收集发生在一个协程中（“coroutine#1”）而发射发生在运行于另一个线程中与收集协程并发运行的另一个协程（“coroutine#2”）中。当上游流必须改变其上下文中的 CoroutineDispatcher 的时候，flowOn 操作符创建了另一个协程。</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .buffer() <span class="comment">// 缓冲发射项，无需等待</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">1054</span> ms</span><br></pre></td></tr></table></figure><p>注意，当必须更改 CoroutineDispatcher 时，flowOn 操作符使用了相同的缓冲机制， 但是我们在这里显式地请求缓冲而不改变执行上下文。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>当流代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的那个。</p><p>当收集器处理它们太慢的时候， conflate 操作符可以用于跳过中间值。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .conflate() <span class="comment">// 合并发射项，不对每个值进行处理</span></span><br><span class="line">        .collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">749</span> ms</span><br></pre></td></tr></table></figure><h2 id="处理最新值"><a href="#处理最新值" class="headerlink" title="处理最新值"></a>处理最新值</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">            println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">            println(<span class="string">"Done <span class="variable">$value</span>"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br></pre></td></tr></table></figure><p>由于 collectLatest 的函数体需要花费 300 毫秒，但是新值每 100 秒发射一次，我们看到该代码块对每个值运行，但是只收集最后一个值：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line">Collecting <span class="number">2</span></span><br><span class="line">Collecting <span class="number">3</span></span><br><span class="line">Done <span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">691</span> ms</span><br></pre></td></tr></table></figure><h2 id="Zip方法"><a href="#Zip方法" class="headerlink" title="Zip方法"></a>Zip方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 数字 1..3</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>) <span class="comment">// 字符串</span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 组合单个字符串</span></span><br><span class="line">    .collect &#123; println(it) &#125; <span class="comment">// 收集并打印</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one</span><br><span class="line"><span class="symbol">2 </span>-&gt; two</span><br><span class="line"><span class="symbol">3 </span>-&gt; three</span><br></pre></td></tr></table></figure><h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>当流表示一个变量或操作的最新值时，可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// 发射数字 1..3，间隔 300 毫秒</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// 每 400 毫秒发射一次字符串</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始的时间</span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 使用“zip”组合单个字符串</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one at <span class="number">425</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; two at <span class="number">825</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; three at <span class="number">1227</span> ms from start</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// 发射数字 1..3，间隔 300 毫秒</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// 每 400 毫秒发射一次字符串</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始的时间</span></span><br><span class="line">nums.combine(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 使用“combine”组合单个字符串</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one at <span class="number">443</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; one at <span class="number">644</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; two at <span class="number">845</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; two at <span class="number">944</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; three at <span class="number">1245</span> ms from start</span><br></pre></td></tr></table></figure><h2 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h2><p>连接模式由 flatMapConcat 与 flattenConcat 操作符实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapConcat &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">127</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">1</span>: Second at <span class="number">628</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: First at <span class="number">729</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: Second at <span class="number">1229</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: First at <span class="number">1329</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: Second at <span class="number">1830</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br></pre></td></tr></table></figure><h2 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h2><p>另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 flatMapMerge 与 flattenMerge 操作符实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapMerge &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">136</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: First at <span class="number">231</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: First at <span class="number">333</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">1</span>: Second at <span class="number">639</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: Second at <span class="number">732</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: Second at <span class="number">833</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br></pre></td></tr></table></figure><h2 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapLatest &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">142</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">2</span>: First at <span class="number">322</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">3</span>: First at <span class="number">425</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">3</span>: Second at <span class="number">931</span> ms <span class="keyword">from</span> start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Flow使用及其相关方法详解
    
    </summary>
    
    
      <category term="kotlin" scheme="https://xxsu.xyz/categories/kotlin/"/>
    
    
      <category term="协程" scheme="https://xxsu.xyz/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Flow" scheme="https://xxsu.xyz/tags/Flow/"/>
    
  </entry>
  
  <entry>
    <title>并发工具类的使用</title>
    <link href="https://xxsu.xyz/article/22df6896/"/>
    <id>https://xxsu.xyz/article/22df6896/</id>
    <published>2021-02-09T09:10:00.000Z</published>
    <updated>2021-02-17T11:26:01.148Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常见的并发工具类有这几个：CountDownLatch，CyclicBarrier，Semaphore。除此之外，还有一个不常用的线程同步器类Exchanger。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个同步计数器，当计数器等于0时，开始触发。</p><p>应用场景：</p><ul><li>让多个线程同时阻塞在某一位置， 等待信号到来，再同时继续执行，模拟并发场景；</li><li>让单个线程等待，合并多个线程结果；</li></ul><p>例子1：</p><p><img src="image-20210212152635201.png" alt="image-20210212152635201"></p><p>输出</p><p><img src="image-20210212152709098.png" alt="image-20210212152709098"></p><p>例子2:</p><p><img src="image-20210212153137792.png" alt="image-20210212153137792"></p><p>输出：</p><p><img src="image-20210212153211891.png" alt="image-20210212153211891"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>从countDown的源码中我们可以看到，CountDownLatch内部使用了共享模式；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中创建了Sync实例;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync继承于AbstractQueuedSynchronizer，在构造方法中将计数器 通过setState方法设置下去了，最终给到了state变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch有个注意事项，当计数器减到0后，便不可以再次使用，需要再次new一个CountDownLatch实例对象。若要强制使用，则需要修改源码，将state值进行重置。此外，有另一个类也实现了CountDownLatch类似的功能，并且是可以重用，那就是CyclicBarrier。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。</p><p>例子：</p><p><img src="image-20210212160846010.png" alt="image-20210212160846010"></p><p>输出：</p><p><img src="image-20210212160910543.png" alt="image-20210212160910543"></p><p>通过例子，可以看出，CyclicBarrier的效果是和CountDownLatch一致的。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行wait操作时，会将count值进行自减一次，当减到0时，进行触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察其构造函数，可以发现，barrierAction是一个runnable对象，最终在触发的时候被调用了run方法，并没有交给子线程去做，说明还是在主线程中做的事情。</p><p>通过观察，我们发现在触发后执行了nextGeneration()方法，一探究竟，发现count值被复原了，这就是为什么CyclicBarrier可以重用的原因了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了CyclicBarrier之外，还有一个和CyclicBarrier类似，且计数可变，那就是Phaser，后面介绍。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 信号量，用于控制在一段时间内，可并发访问执行的线程数量。控制访问特定资源的线程数目，底层依赖AQS的State。Semaphore 在计数器不为 0 的时候对线程就放行，当为0时，所有请求将被阻塞。</p><p>Semaphore 有两种模式，<strong>公平模式</strong> 和 <strong>非公平模式</strong> ，默认是非公平模式。</p><ul><li>公平模式就是调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li><li>非公平模式是抢占式的；</li></ul><p>Semaphore的应用场景</p><p>可以用来做对公共资源的流量限制，如数据库连接。</p><p>释放公共资源许可的时候，有两种方法，一个是release，直接释放；另一个是reducePermits，释放并减少总的许可数量。</p><p>例子：</p><p><img src="image-20210212163929797.png" alt="image-20210212163929797"></p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>默认采用非公平锁；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类Sync继承AbstractQueuedSynchronizer；setState和getState对许可数进行设置和访问；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="reducePermits方法"><a href="#reducePermits方法" class="headerlink" title="reducePermits方法"></a>reducePermits方法</h3><p>reducePermits可以动态控制总的许可证数量；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p><p>想要两个线程之间进行数据交换，必然存在一个交换的时间点，在代码中用exchange来标记交互数据的位置。当两个线程均执行到exchange点时，便开启线程间数据的交换。“交换”二字也客观说明了执行该动作的是至少是两个线程，成对出现。若一个线程到达交换的时间点，而另一个线程并未到达，则该线程进行等待另一个线程。</p><p>其应用场景主要有：遗传算法、多线程数据校对等。</p><p>例子：</p><p><img src="image-20210212041536863.png" alt="image-20210212041536863"></p><p>输出：</p><p><img src="image-20210212041847191.png" alt="image-20210212041847191"></p><p>注意事项，在多个线程中（大于两个）使用同一个exchange，导致的结果随机选择到达交换时间点的线程进行信息交换，主要影响因素是CPU的线程调度；</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a>exchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x;</span><br><span class="line">    <span class="keyword">long</span> ns = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">         (v = slotExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() ||</span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (v == TIMED_OUT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="slotExchange方法"><a href="#slotExchange方法" class="headerlink" title="slotExchange方法"></a>slotExchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;</span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个线程到达交换时间点后，进行自选操作，等待另一个线程进行值交换；如果等待时间超时了，那么抛出超时的中断异常。</p><p>总之，每个工具类都有自己的优势和劣势，在实际开发场景中，还应根据它们的优缺点进行合适的选择。</p>]]></content>
    
    <summary type="html">
    
      关于CountDownLatch,CyclicBarrier,Semaphore,Exchanger的介绍
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CountDownLatch" scheme="https://xxsu.xyz/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="https://xxsu.xyz/tags/CyclicBarrier/"/>
    
      <category term="Semaphore" scheme="https://xxsu.xyz/tags/Semaphore/"/>
    
      <category term="Exchanger" scheme="https://xxsu.xyz/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>DecorView介绍</title>
    <link href="https://xxsu.xyz/article/603b68b6/"/>
    <id>https://xxsu.xyz/article/603b68b6/</id>
    <published>2021-01-26T07:46:00.000Z</published>
    <updated>2021-04-14T01:26:10.660Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>DecorView</strong>: 该类继承自<strong>FrameLayout</strong>，实现了<strong>RootViewSurfaceTaker</strong>, <strong>WindowCallbacks</strong>接口。它是所有应用窗口的根View,PhoneWindow设置DecorView为应用窗口的根视图。</p><p><strong>PhoneWindow</strong>: 该类在setContentView时，帮我们创建了一个<strong>DecorView</strong>（父类为FrameLayout）窗口顶层视图</p><p><strong>ViewRootImpl</strong>: 是连接WindowManager与DecorView的纽带，View的整个绘制流程的三大步（measure、layout、draw）以及我们一些addView()的操作，都是通过ViewRootImpl完成的。</p><p><strong>WindowManager</strong>: 应用程序界面和窗口管理器</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Activity的的<strong>setContentView</strong>方法调用，首先进入installDecor方法，进行decorView的创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里开始创建decorview</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>generateDecor</strong>方法为decorview的主要创建方法,参数为featureId，默认值为-1；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//decorview的主要创建方法</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>generateDecor</strong>方法主要是对decorview的上下文进行创建，当拿到context、featureId、phonewindow以及windowmanage的布局参数后，便开始真正的new DecorView 对象了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn't have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don't cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DecorView</strong>的构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    DecorView(Context context, <span class="keyword">int</span> featureId, PhoneWindow window,</span><br><span class="line">            WindowManager.LayoutParams params) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        updateAvailableWidth();</span><br><span class="line"></span><br><span class="line">        setWindow(window);</span><br><span class="line"></span><br><span class="line">        updateLogTag(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>setWindow</strong>方法设置DecorView的mWindow变量，若当前上下文是DecorContext，也更新decorContext的mPhoneWindow值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">        mWindow = phoneWindow;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> DecorContext) &#123;</span><br><span class="line">            DecorContext decorContext = (DecorContext) context;</span><br><span class="line">            decorContext.setPhoneWindow(mWindow);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<strong>DecorContext.java</strong>中,设置mPhoneWindow的值，同时从phoneWindow中获取上下文，取得context的弱引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPhoneWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">    mPhoneWindow = phoneWindow;</span><br><span class="line">    <span class="keyword">final</span> Context context = phoneWindow.getContext();</span><br><span class="line">    mContext = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">    mResources = context.getResources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="image-20210319102418129.png" alt="image-20210319102418129"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="View-提供的获取坐标方法"><a href="#View-提供的获取坐标方法" class="headerlink" title="View 提供的获取坐标方法"></a>View 提供的获取坐标方法</h3><p><strong>getTop</strong>： View 自身的顶边到父View顶边的距离</p><p><strong>getLeft</strong>： View 自身的左边到父View左边的距离</p><p><strong>getRight</strong>： View 自身的右边到父View左边的距离</p><p><strong>getBottom</strong>： View 自身的底边到父View上边的距离</p><h3 id="MotionEvent-提供的获取坐标方法"><a href="#MotionEvent-提供的获取坐标方法" class="headerlink" title="MotionEvent 提供的获取坐标方法"></a>MotionEvent 提供的获取坐标方法</h3><p><strong>getX</strong> : 触摸点到当前控件左边缘的距离</p><p><strong>getY</strong> : 触摸点当前控件顶边缘的距离</p><p><strong>getRawX</strong> : 触摸点屏幕左边缘的距离</p><p><strong>getRawY</strong> : 触摸点到屏幕顶边缘的距离</p><h3 id="MeasureSpec的三种类型"><a href="#MeasureSpec的三种类型" class="headerlink" title="MeasureSpec的三种类型"></a>MeasureSpec的三种类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MeasureSpecMode &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>UNSPECIFIED</strong>:父级没有对子级施加任何约束。</p><p><strong>EXACTLY</strong>:父级已确定子级的确切大小</p><p><strong>AT_MOST</strong>:子级可以根据需要的大小而定，最大可以达到指定的大小。</p><h3 id="onFinishInflate-调用时机"><a href="#onFinishInflate-调用时机" class="headerlink" title="onFinishInflate 调用时机"></a>onFinishInflate 调用时机</h3><p>setContentView &gt; onFinishInflate &gt; view绘制流程（performMeasure、performLayout、performDraw）</p>]]></content>
    
    <summary type="html">
    
      关于DecorView、PhoneWindow、ViewRootImpl三者的剖析
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="DecorView" scheme="https://xxsu.xyz/tags/DecorView/"/>
    
  </entry>
  
  <entry>
    <title>okhttp框架分析</title>
    <link href="https://xxsu.xyz/article/cec99305/"/>
    <id>https://xxsu.xyz/article/cec99305/</id>
    <published>2021-01-15T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.875Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>基于Socket， 和HttpUrlConnection同级但并不属于HttpUrlConnection（断点续传的关键）</p><p>目前相对主流的框架Retrofit，Glide中都是内置了OkHttp</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();<span class="comment">// 调度者</span></span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;<span class="comment">// 传输层版本和连接协议</span></span><br><span class="line">  eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">  &#125;</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;<span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;<span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;<span class="comment">// 代理身份验证</span></span><br><span class="line">  authenticator = Authenticator.NONE;<span class="comment">// 身份验证</span></span><br><span class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();<span class="comment">// 连接池，最大连接数量为5，空闲时间上限为5分钟；</span></span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="keyword">true</span>;<span class="comment">// 安全套接层重定向</span></span><br><span class="line">  followRedirects = <span class="keyword">true</span>;<span class="comment">// 本地重定向</span></span><br><span class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;<span class="comment">// 重试连接失败</span></span><br><span class="line">  callTimeout = <span class="number">0</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取拦截器链"><a href="#获取拦截器链" class="headerlink" title="获取拦截器链"></a>获取拦截器链</h2><p>添加各种拦截器，然后建立拦截器链，来处理对请求对象的拦截操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>关键类为RealInterceptorChain。</p><p>一个具体的拦截器链，包含整个拦截器链：所有应用程序拦截器，OkHttp核心，所有网络拦截器，最后是网络调用者。如果该链用于应用程序拦截器，则connection必须为空。如果它是用于网络拦截器的，则connection必须为非空。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> exchange != <span class="keyword">null</span> ? exchange.connection() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>包括常见异常日志打印；拦截器的链式调用；责任链模式；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">  calls++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用链中的下一个拦截器。</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">      index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call); <span class="comment">//准备好异步调用的运行顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对AsyncCall进行突变，以使其将现有正在运行的调用的AtomicInteger共享给同一主机。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">      AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关异步回调"><a href="#相关异步回调" class="headerlink" title="相关异步回调"></a>相关异步回调</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备好异步调用的运行顺序。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行异步调用。包括尚未结束的已取消呼叫。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行同步呼叫。包括尚未结束的已取消呼叫。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="promoteAndExecute"><a href="#promoteAndExecute" class="headerlink" title="promoteAndExecute"></a>promoteAndExecute</h3><p>将合格的回调从readyAsyncCalls更新到runningAsyncCalls，并在执行程序服务上运行它们。</p><p>不能以同步方式调用，因为执行调用可以调用用户代码。</p><p>@return如果调度程序当前正在运行回调，则为true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove();</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      okhttp原理分析
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="okhttp" scheme="https://xxsu.xyz/tags/okhttp/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程-ThreadLocal</title>
    <link href="https://xxsu.xyz/article/b0029a08/"/>
    <id>https://xxsu.xyz/article/b0029a08/</id>
    <published>2021-01-12T13:43:00.000Z</published>
    <updated>2021-02-17T11:27:30.895Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="number">2020</span>);</span><br><span class="line">    System.out.println(<span class="string">"parent-thread-s:"</span> + threadLocal.get());</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"child-thread-s:"</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="number">2021</span>);</span><br><span class="line">            System.out.println(<span class="string">"child-thread-e:"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">"parent-thread-e:"</span> + threadLocal.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">parent-thread-s:<span class="number">2020</span></span><br><span class="line">parent-thread-e:<span class="number">2020</span></span><br><span class="line">child-thread-s:<span class="literal">null</span></span><br><span class="line">child-thread-e:<span class="number">2021</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>有利必有弊，虽然解决了上面说到的问题，但是每个线程都创建了变量副本，这时就要考虑它对资源的消耗，使用ThreadLocal时占用的内存资源肯定是会比没有使用的时占用的多。</p><p>在之前的文章有提到synchronized，同样是解决线程安全的，那么他俩到底有啥区别呢？</p><p> synchronized，采用的是阻塞的方式，让线程等待，保证有序进行访问；不占用其他资源，可以说是采用了时间换取空间的策略；而ThreadLocal和线程同步机制相比较，恰好相反，它采用的是以空间换取时间的策略。</p><p>下面来看下ThreadLocal的源码</p><h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，一个线程中的多个ThreadLocal是通过该线程的ThreadLocalMap来管理的；也就是说，每个线程都维护有一个ThreadLocalMap。当在线程中使用来自其他线程的ThreadLocal时，在set的时候，是在根据线程名查找自己线程中是否有ThreadLocalMap，若没有则创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap构造函数"><a href="#ThreadLocalMap构造函数" class="headerlink" title="ThreadLocalMap构造函数"></a>ThreadLocalMap构造函数</h3><p>ThreadLocalMap是ThreadLocal的一个静态内部类，一个简单的Map结构，阈值为16*2/3,底层为数组，数组元素为Entry，Entry采用的是弱引用的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry持有ThreadLocal的弱引用，而table属于ThreadLocalMap，因而，ThreadLocalMap的key采用对ThreadLocal的弱引用。弱引用的生命周期短语软引用，远短于强引用，因此，还需注意垃圾回收的情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法先是获取到当前线程的ThreadLocalMap，再根据ThreadLocal这个key来获取值；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据hashcode值来进行获取数组中对应的Entry对象元素；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果没有获取到，那么用线性碰撞的方式；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该位置置空，再哈希；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>移除的是当前线程中ThreadLocalMap对应的ThreadLocal  key值，解除弱引用；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响；</li><li>一个ThreadLocal对应着多个ThreadLocalMap，每个ThreadLocalMap对应着一个线程；</li><li>如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</li></ul>]]></content>
    
    <summary type="html">
    
      ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响。
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://xxsu.xyz/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://xxsu.xyz/article/7cab1e06/"/>
    <id>https://xxsu.xyz/article/7cab1e06/</id>
    <published>2020-12-22T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.844Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 二叉树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉搜索树 </span>&#123;</span><br><span class="line">    <span class="comment">//    是否有效的二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(Node node, <span class="keyword">int</span> minVal, <span class="keyword">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.data &lt;= minVal || node.data &gt;= maxVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, minVal, node.data)</span><br><span class="line">                &amp;&amp; isValidBST(node.right, node.data, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    打印二叉树每层节点;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeBFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                linkedList.add(node.data);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;res&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    之字形打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeBFS_zhi</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    linkedList.addLast(node.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    linkedList.addFirst(node.data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;res&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, Node root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height &gt;= list.size()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; temp = list.get(height);</span><br><span class="line">        temp.add(root.data);</span><br><span class="line">        dfs(list, root.left, height + <span class="number">1</span>);</span><br><span class="line">        dfs(list, root.right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    打印二叉树每层节点;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeDFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(list, root, <span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(data[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    任意方式创建二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">insertSearchTree</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.data) &#123;</span><br><span class="line">            root.left = insertSearchTree(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.data) &#123;</span><br><span class="line">            root.right = insertSearchTree(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    搜索二叉树遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchTree</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == temp.data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; temp.data) &#123;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉搜索树实现
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉搜索树" scheme="https://xxsu.xyz/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>异步流使用详解</title>
    <link href="https://xxsu.xyz/article/762aaa36/"/>
    <id>https://xxsu.xyz/article/762aaa36/</id>
    <published>2020-12-15T07:46:00.000Z</published>
    <updated>2021-02-17T11:37:55.070Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123; <span class="comment">// 序列构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们正在计算</span></span><br><span class="line">        yield(i) <span class="comment">// 产生下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 假装我们在这里做了一些异步的事情</span></span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意使用Flow类型构建器函数：</p><ul><li>名为 flow的 Flow类型构建器函数。</li><li><code>flow { ... }</code> 构建块中的代码可以挂起。</li><li>函数 <code>simple</code> 不再标有 <code>suspend</code> 修饰符。</li><li>流使用 emit函数 <em>发射</em> 值。</li><li>流使用 collect 函数 <em>收集</em> 值。</li></ul><p>我们可以在 <code>simple</code> 的 <code>flow { ... }</code> 函数体内使用 <code>Thread.sleep</code> 代替 delay 以观察主线程在本案例中被阻塞了。</p><p>flow 构建器中的代码直到流被收集的时候才运行</p><h3 id="流的超时取消"><a href="#流的超时取消" class="headerlink" title="流的超时取消"></a>流的超时取消</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)          </span><br><span class="line">        println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123; <span class="comment">// 在 250 毫秒后超时</span></span><br><span class="line">        simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h3><p><code>flow { ... }</code> 构建器是最基础的一个    </p><p>flowOf 构建器定义了一个发射固定值集的流。<br>使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个整数区间转化为流</span></span><br><span class="line">(<span class="number">1</span>..<span class="number">3</span>).asFlow().collect &#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="过渡流操作符"><a href="#过渡流操作符" class="headerlink" title="过渡流操作符"></a>过渡流操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 模仿长时间运行的异步工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"response <span class="variable">$request</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 一个请求流</span></span><br><span class="line">        .map &#123; request -&gt; performRequest(request) &#125;</span><br><span class="line">        .collect &#123; response -&gt; println(response) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">response <span class="number">1</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 一个请求流</span></span><br><span class="line">    .transform &#123; request -&gt;</span><br><span class="line">        emit(<span class="string">"Making request <span class="variable">$request</span>"</span>) </span><br><span class="line">        emit(performRequest(request)) </span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123; response -&gt; println(response) &#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Making request <span class="number">1</span></span><br><span class="line">response <span class="number">1</span></span><br><span class="line">Making request <span class="number">2</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">Making request <span class="number">3</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="限长操作符"><a href="#限长操作符" class="headerlink" title="限长操作符"></a>限长操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                          </span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>) </span><br><span class="line">        println(<span class="string">"This line will not execute"</span>)</span><br><span class="line">        emit(<span class="number">3</span>)    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">"Finally in numbers"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    numbers() </span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// 只获取前两个</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="末端流操作符"><a href="#末端流操作符" class="headerlink" title="末端流操作符"></a>末端流操作符</h3><p>末端操作符：</p><ul><li>转化为各种集合，例如 toList 与 toSet。</li><li>获取第一个（first）值与确保流发射单个（single）值的操作符。</li><li>使用 reduce 与 fold 将流规约到单个值。</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = (<span class="number">1</span>..<span class="number">5</span>).asFlow()</span><br><span class="line">    .map &#123; it * it &#125; <span class="comment">// 数字 1 至 5 的平方                        </span></span><br><span class="line">    .reduce &#123; a, b -&gt; a + b &#125; <span class="comment">// 求和（末端操作符）</span></span><br><span class="line">println(sum)</span><br></pre></td></tr></table></figure><p>输出： 55</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>过滤偶数并将其映射到字符串</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">5</span>).asFlow()</span><br><span class="line">    .filter &#123;</span><br><span class="line">        println(<span class="string">"Filter <span class="variable">$it</span>"</span>)</span><br><span class="line">        it % <span class="number">2</span> == <span class="number">0</span>              </span><br><span class="line">    &#125;              </span><br><span class="line">    .map &#123; </span><br><span class="line">        println(<span class="string">"Map <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="string">"string <span class="variable">$it</span>"</span></span><br><span class="line">    &#125;.collect &#123; </span><br><span class="line">        println(<span class="string">"Collect <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Filter 1</span><br><span class="line">Filter 2</span><br><span class="line">Map 2</span><br><span class="line">Collect string 2</span><br><span class="line">Filter 3</span><br><span class="line">Filter 4</span><br><span class="line">Map 4</span><br><span class="line">Collect string 4</span><br><span class="line">Filter 5</span><br></pre></td></tr></table></figure><p>通常，withContext 用于在 Kotlin 协程中改变代码的上下文，但是 flow {…} 构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit）。</p>]]></content>
    
    <summary type="html">
    
      流的使用以及常见操作符的讲解
    
    </summary>
    
    
      <category term="kotlin" scheme="https://xxsu.xyz/categories/kotlin/"/>
    
    
      <category term="异步流" scheme="https://xxsu.xyz/tags/%E5%BC%82%E6%AD%A5%E6%B5%81/"/>
    
      <category term="协程" scheme="https://xxsu.xyz/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池原理</title>
    <link href="https://xxsu.xyz/article/335c74d5/"/>
    <id>https://xxsu.xyz/article/335c74d5/</id>
    <published>2020-12-05T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.862Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>优点：</p><ul><li>能够实现复用</li><li>线程统一管理</li></ul><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li><code>corePoolSize</code> 为线程池的基本大小。</li><li><code>maximumPoolSize</code> 为线程池最大线程大小。</li><li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li><li><code>workQueue</code> 用于存放任务的阻塞队列。</li><li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>提交任务》核心线程是否已满》阻塞队里是否已满》线程池是否已满》拒绝策略</strong></p><p>拒绝策略</p><p><code>AbortPolicy</code>： 直接拒绝所提交的任务，并抛出<code>RejectedExecutionException</code>异常。</p><p><code>CallerRunsPolicy</code>：只用调用者所在的线程来执行任务。</p><p><code>DiscardPolicy</code>：不处理直接丢弃掉任务。</p><p><code>DiscardOldestPolicy</code>：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。</p><h3 id="延时任务与定时任务"><a href="#延时任务与定时任务" class="headerlink" title="延时任务与定时任务"></a>延时任务与定时任务</h3><p>线程池可以处理延时任务，设置延迟时间执行任务</p><p>通过execute执行<strong>无返回值</strong>，而submit提交则有<strong>Future的返回值</strong>，其中get方法可以设置timeout时间，若deadline到达，还没有get到结果，则抛出异常。通过这个方法可以处理定时任务。但是值得注意的是，<strong>该方法会直接阻塞get所在线程！！</strong>若是在主线程中直接引起ui卡住，长时间超过5s则ANR。若想不卡主线程，而设置定时任务可以<strong>采用timer方式</strong>，除了这种方式外还可以采用<strong>开启守护线程</strong>方式来解决。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当需要频繁创建线程来执行任务的时候</p><p>需要延迟执行任务</p><p>多线程&amp;多任务场景以及单线程场景</p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>例如协程。协程（kotlin）的执行环境也是线程池的应用之一。当在主线程中使用协程提交任务，<strong>这些任务会被调度到线程池的各个线程中</strong>，虽然不在同一个线程，但是能够保证一定的执行顺序。通过自定义协程调度器可以设置其执行的指定线程池。总的来说，依靠的还是线程池。</p><p>例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorDispatcher</span></span></span><br><span class="line">    : AbstractCoroutineContextElement(ContinuationInterceptor),</span><br><span class="line">        ContinuationInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executorService = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">        Thread(it, <span class="string">"SingleThreadExecutor"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> MyContinuation(continuation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContinuation</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> origin: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = origin.context</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            executorService.submit &#123;</span><br><span class="line">                origin.resumeWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        executorService.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> dispatcher = SingleThreadExecutorDispatcher()</span><br><span class="line">    log(<span class="string">"AA"</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">"BB"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    dispatcher.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">main</span>] AA</span><br><span class="line">[<span class="meta">SingleThreadExecutor</span>] BB</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      线程池的执行流程，以及应用场景等
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="https://xxsu.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>abbrlink踩坑</title>
    <link href="https://xxsu.xyz/article/856a5aa8/"/>
    <id>https://xxsu.xyz/article/856a5aa8/</id>
    <published>2020-11-21T13:26:00.000Z</published>
    <updated>2021-02-02T16:09:52.897Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>博客搭建有一段时间了，但是链接地址却和文件名紧紧绑定在一起，及其不方便扩展，也给写作带来些许不便。</p><p>于是乎，今天便想着来搞搞；为了生成永久链接，这里使用abbrlink这个插件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部安装</span></span><br><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>嗯哼~ 安装失败….再来</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>ok了，这里配置了镜像，还是cnpm好用；</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>继续，开始配置外部的 _config.yml </p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:abbrlink/</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment">#true(default)</span></span><br><span class="line">     <span class="attr">depth:</span>        <span class="comment">#3(default)</span></span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#enable auto title, it can auto fill the title by path</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> <span class="comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span></span><br></pre></td></tr></table></figure><p>大家应该都看得懂了~</p><p>不过这里有个注意事项，auto_category 默认是true，这里我设置成false；下面是auto_category的源码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> opt_AutoCategoryEnable = config.auto_category &amp;&amp; config.auto_category.enable;</span><br><span class="line"><span class="keyword">var</span> overwrite = config.auto_category &amp;&amp; config.auto_category.over_write;</span><br><span class="line"><span class="keyword">if</span> (opt_AutoCategoryEnable &amp;&amp; overwrite) &#123;</span><br><span class="line"><span class="keyword">var</span> categories = data.source.split(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">var</span> opt_AutoCategoryDepth = config.auto_category.depth || <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> depth = opt_AutoCategoryDepth || categories.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (categories.length - <span class="number">2</span> == <span class="number">0</span> || depth == <span class="number">0</span>) &#123;</span><br><span class="line">tmpPost.categories = <span class="keyword">this</span>.config.default_category;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> newCategories = categories.slice(<span class="number">1</span>, <span class="number">1</span> + <span class="built_in">Math</span>.min(depth, categories.length - <span class="number">2</span>));</span><br><span class="line"><span class="comment">//prevents duplicate file changes</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">!<span class="built_in">Array</span>.isArray(tmpPost.categories) ||</span><br><span class="line">!tmpPost.categories.join(<span class="string">'_'</span>) == newCategories.join(<span class="string">'_'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">tmpPost.categories = newCategories;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来查看一下hexo-abbrlink的版本</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">npm view hexo-abbrlink versions --json</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.0"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.1"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.2"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.3"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.1"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.2"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.4"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.5"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.1.5"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.1.6"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.2.0"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.2.1"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure><p>默认安装的是最新版是2.2.1；</p><p>abbrlink 的原理是在每篇文章的属性里加上一个16位/32位的十六进制的数，来作为文章唯一的id。具体内部实现依靠hexo-fs插件来进行写入生成；</p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>在配置好以上内容之后，就可以开始执行生成索引了，这是最后一步了。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure><p>可执行了以上命令之后，情况又不妙了~</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">Error: EEXIST: file already exists, mkdir '</span>F:\software2\MyGithubPage\hexo\source\_posts\Android<span class="string">'</span></span><br><span class="line"><span class="string">    at Object.mkdirSync (fs.js:729:3)</span></span><br><span class="line"><span class="string">    at Object.writeFileSync (F:\software2\MyGithubPage\hexo\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js:63:6)</span></span><br><span class="line"><span class="string">    at Hexo.logic (F:\software2\MyGithubPage\hexo\node_modules\_hexo-abbrlink@2.2.1@hexo-abbrlink\lib\logic.js:98:20)</span></span><br><span class="line"><span class="string">    at Hexo.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Hexo.&lt;anonymous&gt; (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\method.js:15:34)</span></span><br><span class="line"><span class="string">    at Promise.each.filter (F:\software2\MyGithubPage\hexo\node_modules\hexo\lib\extend\filter.js:62:52)</span></span><br><span class="line"><span class="string">    at tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Object.gotValue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:166:18)</span></span><br><span class="line"><span class="string">    at Object.gotAccum (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:155:25)</span></span><br><span class="line"><span class="string">    at Object.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Promise._settlePromiseFromHandler (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:547:31)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:604:18)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise0 (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:649:10)</span></span><br><span class="line"><span class="string">    at Promise._settlePromises (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:729:18)</span></span><br><span class="line"><span class="string">    at _drainQueueStep (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:93:12)</span></span><br><span class="line"><span class="string">    at _drainQueue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:86:9)</span></span><br><span class="line"><span class="string">    at Async._drainQueues (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:102:5)</span></span><br><span class="line"><span class="string">    at Immediate.Async.drainQueues [as _onImmediate] (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:15:14)</span></span><br><span class="line"><span class="string">    at runCallback (timers.js:693:18)</span></span><br><span class="line"><span class="string">    at tryOnImmediate (timers.js:664:5)</span></span><br><span class="line"><span class="string">    at processImmediate (timers.js:646:5)</span></span><br></pre></td></tr></table></figure><p>报了一堆堆栈日志，通过观察，我们可以看到程序是在执行了 logic.js 之后，接着执行 fs.js 报错的；文件已存在，程序还在强行创建!!!!</p><p>为了一探究竟，我们进入到logic.js 中看看</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFileSync(data.full_source, postStr, <span class="string">'utf-8'</span>);</span><br></pre></td></tr></table></figure><p>程序是执行了这段代码导致的，如果abbrlink不存在的话，该插件会遍历文件夹中的文件进行写入，然后创建新的文件夹；继续追，查看下package.json</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  "hexo-front-matter": "^1.0.0",</span><br><span class="line">  "hexo-fs": "^3.1.0"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>依赖的最新的fs是3.1。进入hexo-js中，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeFileSync</span>(<span class="params">path, data, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'path is required!'</span>);</span><br><span class="line"></span><br><span class="line">  fs.mkdirSync(dirname(path), &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  fs.writeFileSync(path, data, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好家伙，直接就创建了，都不检查下的吗？？</p><h2 id="手动修改hexo-fs"><a href="#手动修改hexo-fs" class="headerlink" title="手动修改hexo-fs"></a>手动修改hexo-fs</h2><p>路径：<code>\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js</code>  文件</p><p>在文件中添加以下函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkParentSync</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'path is required!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> parent = dirname(path);</span><br><span class="line">  <span class="keyword">var</span> exist = fs.existsSync(parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exist) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mkdirsSync(parent);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'EEXIST'</span>) <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将fs.mkdirSync 注释掉，增加 checkParentSync(path);  的调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs.mkdirSync(dirname(path), &#123; recursive: true &#125;);</span></span><br><span class="line">checkParentSync(path);</span><br></pre></td></tr></table></figure><p>最后，大功告成~:happy:</p>]]></content>
    
    <summary type="html">
    
      为博客生成唯一永久链接
    
    </summary>
    
    
      <category term="踩坑日记" scheme="https://xxsu.xyz/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="abbrlink" scheme="https://xxsu.xyz/tags/abbrlink/"/>
    
  </entry>
  
</feed>
