<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueSky&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xxsu.xyz/"/>
  <updated>2021-04-14T04:03:00.848Z</updated>
  <id>https://xxsu.xyz/</id>
  
  <author>
    <name>Xiao Su</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树基础操作</title>
    <link href="https://xxsu.xyz/article/bb06284f/"/>
    <id>https://xxsu.xyz/article/bb06284f/</id>
    <published>2021-04-02T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="二叉树基础操作"><a href="#二叉树基础操作" class="headerlink" title="二叉树基础操作"></a>二叉树基础操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 二叉树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉树基础操作 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">422</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">55</span>, <span class="number">64</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfsSearch</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; re : res) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(re.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height == res.size()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(height).add(node.data);</span><br><span class="line">        dfs(node.left, res, height + <span class="number">1</span>);</span><br><span class="line">        dfs(node.right, res, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfsSearch</span><span class="params">(Node tree)</span></span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= bfs(tree);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; re : res) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(re.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; bfs(Node root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node node= queue.poll();</span><br><span class="line">                <span class="keyword">assert</span> node != <span class="keyword">null</span>;</span><br><span class="line">                list.add(node.data);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            insert(root, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">insert</span><span class="params">(Node node, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data &lt;= node.data) &#123;</span><br><span class="line">            node.left= insert(node.left, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right= insert(node.right, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        printTree(node.left);</span><br><span class="line">        printTree(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=node.left;</span><br><span class="line">        node.left=node.right;</span><br><span class="line">        node.right=temp;</span><br><span class="line">        invert(node.left);</span><br><span class="line">        invert(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=searchMax(node.left);</span><br><span class="line">        <span class="keyword">int</span> right= searchMax(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(node.data,Math.max(left,right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDeep</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=maxDeep(node.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxDeep(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> balance(node)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">balance</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=balance(node.left);</span><br><span class="line">        <span class="keyword">int</span> right=balance(node.right);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>||right==-<span class="number">1</span>||Math.abs(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node tree = createTree(a2);</span><br><span class="line">        printTree(tree);</span><br><span class="line">        dfsSearch(tree);</span><br><span class="line">        bfsSearch(tree);</span><br><span class="line">        invert(tree);</span><br><span class="line">        bfsSearch(tree);</span><br><span class="line">        System.out.println(searchMax(tree));</span><br><span class="line">        System.out.println(maxDeep(tree));</span><br><span class="line">        System.out.println(isBalance(tree));</span><br><span class="line">        <span class="comment">//        System.out.println(Arrays.toString(qsort(arr, 0, arr.length - 1)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树常见基础操作
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://xxsu.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树非递归遍历</title>
    <link href="https://xxsu.xyz/article/1062d183/"/>
    <id>https://xxsu.xyz/article/1062d183/</id>
    <published>2021-03-12T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.851Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历_非递归"></a>前序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 前序遍历<span class="title">_</span>非递归 </span>&#123;</span><br><span class="line">    <span class="comment">//    非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                list.add(root.data);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更简洁的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            list.add(node.data);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历_非递归"></a>中序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mid</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        list.add(node.data);</span><br><span class="line">        root=node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历_非递归"></a>后序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 后序遍历<span class="title">_</span>非递归 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(<span class="number">0</span>, root.data);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉树前中后三种非递归遍历实现
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://xxsu.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>异步流的方法详解</title>
    <link href="https://xxsu.xyz/article/76ae8ac8/"/>
    <id>https://xxsu.xyz/article/76ae8ac8/</id>
    <published>2021-02-17T11:22:00.000Z</published>
    <updated>2021-02-21T08:45:10.716Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a>flowOn 操作符</h2><p>该函数用于更改流发射的上下文。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变消耗 CPU 代码上下文的正确方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">1</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">1</span></span><br><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">2</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">2</span></span><br><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">3</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">3</span></span><br></pre></td></tr></table></figure><p> flowOn 操作符已改变流的默认顺序性。 现在收集发生在一个协程中（“coroutine#1”）而发射发生在运行于另一个线程中与收集协程并发运行的另一个协程（“coroutine#2”）中。当上游流必须改变其上下文中的 CoroutineDispatcher 的时候，flowOn 操作符创建了另一个协程。</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .buffer() <span class="comment">// 缓冲发射项，无需等待</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">1054</span> ms</span><br></pre></td></tr></table></figure><p>注意，当必须更改 CoroutineDispatcher 时，flowOn 操作符使用了相同的缓冲机制， 但是我们在这里显式地请求缓冲而不改变执行上下文。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>当流代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的那个。</p><p>当收集器处理它们太慢的时候， conflate 操作符可以用于跳过中间值。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .conflate() <span class="comment">// 合并发射项，不对每个值进行处理</span></span><br><span class="line">        .collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">749</span> ms</span><br></pre></td></tr></table></figure><h2 id="处理最新值"><a href="#处理最新值" class="headerlink" title="处理最新值"></a>处理最新值</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">            println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">            println(<span class="string">"Done <span class="variable">$value</span>"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br></pre></td></tr></table></figure><p>由于 collectLatest 的函数体需要花费 300 毫秒，但是新值每 100 秒发射一次，我们看到该代码块对每个值运行，但是只收集最后一个值：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line">Collecting <span class="number">2</span></span><br><span class="line">Collecting <span class="number">3</span></span><br><span class="line">Done <span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">691</span> ms</span><br></pre></td></tr></table></figure><h2 id="Zip方法"><a href="#Zip方法" class="headerlink" title="Zip方法"></a>Zip方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 数字 1..3</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>) <span class="comment">// 字符串</span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 组合单个字符串</span></span><br><span class="line">    .collect &#123; println(it) &#125; <span class="comment">// 收集并打印</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one</span><br><span class="line"><span class="symbol">2 </span>-&gt; two</span><br><span class="line"><span class="symbol">3 </span>-&gt; three</span><br></pre></td></tr></table></figure><h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>当流表示一个变量或操作的最新值时，可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// 发射数字 1..3，间隔 300 毫秒</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// 每 400 毫秒发射一次字符串</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始的时间</span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 使用“zip”组合单个字符串</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one at <span class="number">425</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; two at <span class="number">825</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; three at <span class="number">1227</span> ms from start</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// 发射数字 1..3，间隔 300 毫秒</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// 每 400 毫秒发射一次字符串</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始的时间</span></span><br><span class="line">nums.combine(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 使用“combine”组合单个字符串</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one at <span class="number">443</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; one at <span class="number">644</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; two at <span class="number">845</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; two at <span class="number">944</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; three at <span class="number">1245</span> ms from start</span><br></pre></td></tr></table></figure><h2 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h2><p>连接模式由 flatMapConcat 与 flattenConcat 操作符实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapConcat &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">127</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">1</span>: Second at <span class="number">628</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: First at <span class="number">729</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: Second at <span class="number">1229</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: First at <span class="number">1329</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: Second at <span class="number">1830</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br></pre></td></tr></table></figure><h2 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h2><p>另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 flatMapMerge 与 flattenMerge 操作符实现。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapMerge &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">136</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: First at <span class="number">231</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: First at <span class="number">333</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">1</span>: Second at <span class="number">639</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: Second at <span class="number">732</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: Second at <span class="number">833</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br></pre></td></tr></table></figure><h2 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapLatest &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">142</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">2</span>: First at <span class="number">322</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">3</span>: First at <span class="number">425</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">3</span>: Second at <span class="number">931</span> ms <span class="keyword">from</span> start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Flow使用及其相关方法详解
    
    </summary>
    
    
      <category term="kotlin" scheme="https://xxsu.xyz/categories/kotlin/"/>
    
    
      <category term="协程" scheme="https://xxsu.xyz/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Flow" scheme="https://xxsu.xyz/tags/Flow/"/>
    
  </entry>
  
  <entry>
    <title>并发工具类的使用</title>
    <link href="https://xxsu.xyz/article/22df6896/"/>
    <id>https://xxsu.xyz/article/22df6896/</id>
    <published>2021-02-09T09:10:00.000Z</published>
    <updated>2021-02-17T11:26:01.148Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常见的并发工具类有这几个：CountDownLatch，CyclicBarrier，Semaphore。除此之外，还有一个不常用的线程同步器类Exchanger。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个同步计数器，当计数器等于0时，开始触发。</p><p>应用场景：</p><ul><li>让多个线程同时阻塞在某一位置， 等待信号到来，再同时继续执行，模拟并发场景；</li><li>让单个线程等待，合并多个线程结果；</li></ul><p>例子1：</p><p><img src="image-20210212152635201.png" alt="image-20210212152635201"></p><p>输出</p><p><img src="image-20210212152709098.png" alt="image-20210212152709098"></p><p>例子2:</p><p><img src="image-20210212153137792.png" alt="image-20210212153137792"></p><p>输出：</p><p><img src="image-20210212153211891.png" alt="image-20210212153211891"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>从countDown的源码中我们可以看到，CountDownLatch内部使用了共享模式；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中创建了Sync实例;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync继承于AbstractQueuedSynchronizer，在构造方法中将计数器 通过setState方法设置下去了，最终给到了state变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch有个注意事项，当计数器减到0后，便不可以再次使用，需要再次new一个CountDownLatch实例对象。若要强制使用，则需要修改源码，将state值进行重置。此外，有另一个类也实现了CountDownLatch类似的功能，并且是可以重用，那就是CyclicBarrier。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。</p><p>例子：</p><p><img src="image-20210212160846010.png" alt="image-20210212160846010"></p><p>输出：</p><p><img src="image-20210212160910543.png" alt="image-20210212160910543"></p><p>通过例子，可以看出，CyclicBarrier的效果是和CountDownLatch一致的。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行wait操作时，会将count值进行自减一次，当减到0时，进行触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察其构造函数，可以发现，barrierAction是一个runnable对象，最终在触发的时候被调用了run方法，并没有交给子线程去做，说明还是在主线程中做的事情。</p><p>通过观察，我们发现在触发后执行了nextGeneration()方法，一探究竟，发现count值被复原了，这就是为什么CyclicBarrier可以重用的原因了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了CyclicBarrier之外，还有一个和CyclicBarrier类似，且计数可变，那就是Phaser，后面介绍。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 信号量，用于控制在一段时间内，可并发访问执行的线程数量。控制访问特定资源的线程数目，底层依赖AQS的State。Semaphore 在计数器不为 0 的时候对线程就放行，当为0时，所有请求将被阻塞。</p><p>Semaphore 有两种模式，<strong>公平模式</strong> 和 <strong>非公平模式</strong> ，默认是非公平模式。</p><ul><li>公平模式就是调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li><li>非公平模式是抢占式的；</li></ul><p>Semaphore的应用场景</p><p>可以用来做对公共资源的流量限制，如数据库连接。</p><p>释放公共资源许可的时候，有两种方法，一个是release，直接释放；另一个是reducePermits，释放并减少总的许可数量。</p><p>例子：</p><p><img src="image-20210212163929797.png" alt="image-20210212163929797"></p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>默认采用非公平锁；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类Sync继承AbstractQueuedSynchronizer；setState和getState对许可数进行设置和访问；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="reducePermits方法"><a href="#reducePermits方法" class="headerlink" title="reducePermits方法"></a>reducePermits方法</h3><p>reducePermits可以动态控制总的许可证数量；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p><p>想要两个线程之间进行数据交换，必然存在一个交换的时间点，在代码中用exchange来标记交互数据的位置。当两个线程均执行到exchange点时，便开启线程间数据的交换。“交换”二字也客观说明了执行该动作的是至少是两个线程，成对出现。若一个线程到达交换的时间点，而另一个线程并未到达，则该线程进行等待另一个线程。</p><p>其应用场景主要有：遗传算法、多线程数据校对等。</p><p>例子：</p><p><img src="image-20210212041536863.png" alt="image-20210212041536863"></p><p>输出：</p><p><img src="image-20210212041847191.png" alt="image-20210212041847191"></p><p>注意事项，在多个线程中（大于两个）使用同一个exchange，导致的结果随机选择到达交换时间点的线程进行信息交换，主要影响因素是CPU的线程调度；</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a>exchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x;</span><br><span class="line">    <span class="keyword">long</span> ns = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">         (v = slotExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() ||</span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (v == TIMED_OUT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="slotExchange方法"><a href="#slotExchange方法" class="headerlink" title="slotExchange方法"></a>slotExchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;</span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个线程到达交换时间点后，进行自选操作，等待另一个线程进行值交换；如果等待时间超时了，那么抛出超时的中断异常。</p><p>总之，每个工具类都有自己的优势和劣势，在实际开发场景中，还应根据它们的优缺点进行合适的选择。</p>]]></content>
    
    <summary type="html">
    
      关于CountDownLatch,CyclicBarrier,Semaphore,Exchanger的介绍
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CountDownLatch" scheme="https://xxsu.xyz/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="https://xxsu.xyz/tags/CyclicBarrier/"/>
    
      <category term="Semaphore" scheme="https://xxsu.xyz/tags/Semaphore/"/>
    
      <category term="Exchanger" scheme="https://xxsu.xyz/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>DecorView介绍</title>
    <link href="https://xxsu.xyz/article/603b68b6/"/>
    <id>https://xxsu.xyz/article/603b68b6/</id>
    <published>2021-01-26T07:46:00.000Z</published>
    <updated>2021-04-14T01:26:10.660Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>DecorView</strong>: 该类继承自<strong>FrameLayout</strong>，实现了<strong>RootViewSurfaceTaker</strong>, <strong>WindowCallbacks</strong>接口。它是所有应用窗口的根View,PhoneWindow设置DecorView为应用窗口的根视图。</p><p><strong>PhoneWindow</strong>: 该类在setContentView时，帮我们创建了一个<strong>DecorView</strong>（父类为FrameLayout）窗口顶层视图</p><p><strong>ViewRootImpl</strong>: 是连接WindowManager与DecorView的纽带，View的整个绘制流程的三大步（measure、layout、draw）以及我们一些addView()的操作，都是通过ViewRootImpl完成的。</p><p><strong>WindowManager</strong>: 应用程序界面和窗口管理器</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Activity的的<strong>setContentView</strong>方法调用，首先进入installDecor方法，进行decorView的创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里开始创建decorview</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>generateDecor</strong>方法为decorview的主要创建方法,参数为featureId，默认值为-1；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//decorview的主要创建方法</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>generateDecor</strong>方法主要是对decorview的上下文进行创建，当拿到context、featureId、phonewindow以及windowmanage的布局参数后，便开始真正的new DecorView 对象了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn't have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don't cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DecorView</strong>的构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    DecorView(Context context, <span class="keyword">int</span> featureId, PhoneWindow window,</span><br><span class="line">            WindowManager.LayoutParams params) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        updateAvailableWidth();</span><br><span class="line"></span><br><span class="line">        setWindow(window);</span><br><span class="line"></span><br><span class="line">        updateLogTag(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>setWindow</strong>方法设置DecorView的mWindow变量，若当前上下文是DecorContext，也更新decorContext的mPhoneWindow值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">        mWindow = phoneWindow;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> DecorContext) &#123;</span><br><span class="line">            DecorContext decorContext = (DecorContext) context;</span><br><span class="line">            decorContext.setPhoneWindow(mWindow);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<strong>DecorContext.java</strong>中,设置mPhoneWindow的值，同时从phoneWindow中获取上下文，取得context的弱引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPhoneWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">    mPhoneWindow = phoneWindow;</span><br><span class="line">    <span class="keyword">final</span> Context context = phoneWindow.getContext();</span><br><span class="line">    mContext = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">    mResources = context.getResources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="image-20210319102418129.png" alt="image-20210319102418129"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="View-提供的获取坐标方法"><a href="#View-提供的获取坐标方法" class="headerlink" title="View 提供的获取坐标方法"></a>View 提供的获取坐标方法</h3><p><strong>getTop</strong>： View 自身的顶边到父View顶边的距离</p><p><strong>getLeft</strong>： View 自身的左边到父View左边的距离</p><p><strong>getRight</strong>： View 自身的右边到父View左边的距离</p><p><strong>getBottom</strong>： View 自身的底边到父View上边的距离</p><h3 id="MotionEvent-提供的获取坐标方法"><a href="#MotionEvent-提供的获取坐标方法" class="headerlink" title="MotionEvent 提供的获取坐标方法"></a>MotionEvent 提供的获取坐标方法</h3><p><strong>getX</strong> : 触摸点到当前控件左边缘的距离</p><p><strong>getY</strong> : 触摸点当前控件顶边缘的距离</p><p><strong>getRawX</strong> : 触摸点屏幕左边缘的距离</p><p><strong>getRawY</strong> : 触摸点到屏幕顶边缘的距离</p><h3 id="MeasureSpec的三种类型"><a href="#MeasureSpec的三种类型" class="headerlink" title="MeasureSpec的三种类型"></a>MeasureSpec的三种类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MeasureSpecMode &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>UNSPECIFIED</strong>:父级没有对子级施加任何约束。</p><p><strong>EXACTLY</strong>:父级已确定子级的确切大小</p><p><strong>AT_MOST</strong>:子级可以根据需要的大小而定，最大可以达到指定的大小。</p><h3 id="onFinishInflate-调用时机"><a href="#onFinishInflate-调用时机" class="headerlink" title="onFinishInflate 调用时机"></a>onFinishInflate 调用时机</h3><p>setContentView &gt; onFinishInflate &gt; view绘制流程（performMeasure、performLayout、performDraw）</p>]]></content>
    
    <summary type="html">
    
      关于DecorView、PhoneWindow、ViewRootImpl三者的剖析
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="DecorView" scheme="https://xxsu.xyz/tags/DecorView/"/>
    
  </entry>
  
  <entry>
    <title>okhttp框架分析</title>
    <link href="https://xxsu.xyz/article/cec99305/"/>
    <id>https://xxsu.xyz/article/cec99305/</id>
    <published>2021-01-15T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.875Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>基于Socket， 和HttpUrlConnection同级但并不属于HttpUrlConnection（断点续传的关键）</p><p>目前相对主流的框架Retrofit，Glide中都是内置了OkHttp</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();<span class="comment">// 调度者</span></span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;<span class="comment">// 传输层版本和连接协议</span></span><br><span class="line">  eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">  &#125;</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;<span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;<span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;<span class="comment">// 代理身份验证</span></span><br><span class="line">  authenticator = Authenticator.NONE;<span class="comment">// 身份验证</span></span><br><span class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();<span class="comment">// 连接池，最大连接数量为5，空闲时间上限为5分钟；</span></span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="keyword">true</span>;<span class="comment">// 安全套接层重定向</span></span><br><span class="line">  followRedirects = <span class="keyword">true</span>;<span class="comment">// 本地重定向</span></span><br><span class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;<span class="comment">// 重试连接失败</span></span><br><span class="line">  callTimeout = <span class="number">0</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取拦截器链"><a href="#获取拦截器链" class="headerlink" title="获取拦截器链"></a>获取拦截器链</h2><p>添加各种拦截器，然后建立拦截器链，来处理对请求对象的拦截操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>关键类为RealInterceptorChain。</p><p>一个具体的拦截器链，包含整个拦截器链：所有应用程序拦截器，OkHttp核心，所有网络拦截器，最后是网络调用者。如果该链用于应用程序拦截器，则connection必须为空。如果它是用于网络拦截器的，则connection必须为非空。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> exchange != <span class="keyword">null</span> ? exchange.connection() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>包括常见异常日志打印；拦截器的链式调用；责任链模式；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">  calls++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用链中的下一个拦截器。</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">      index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call); <span class="comment">//准备好异步调用的运行顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对AsyncCall进行突变，以使其将现有正在运行的调用的AtomicInteger共享给同一主机。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">      AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关异步回调"><a href="#相关异步回调" class="headerlink" title="相关异步回调"></a>相关异步回调</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备好异步调用的运行顺序。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行异步调用。包括尚未结束的已取消呼叫。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行同步呼叫。包括尚未结束的已取消呼叫。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="promoteAndExecute"><a href="#promoteAndExecute" class="headerlink" title="promoteAndExecute"></a>promoteAndExecute</h3><p>将合格的回调从readyAsyncCalls更新到runningAsyncCalls，并在执行程序服务上运行它们。</p><p>不能以同步方式调用，因为执行调用可以调用用户代码。</p><p>@return如果调度程序当前正在运行回调，则为true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove();</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      okhttp原理分析
    
    </summary>
    
    
      <category term="Android" scheme="https://xxsu.xyz/categories/Android/"/>
    
    
      <category term="okhttp" scheme="https://xxsu.xyz/tags/okhttp/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程-ThreadLocal</title>
    <link href="https://xxsu.xyz/article/b0029a08/"/>
    <id>https://xxsu.xyz/article/b0029a08/</id>
    <published>2021-01-12T13:43:00.000Z</published>
    <updated>2021-02-17T11:27:30.895Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="number">2020</span>);</span><br><span class="line">    System.out.println(<span class="string">"parent-thread-s:"</span> + threadLocal.get());</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"child-thread-s:"</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="number">2021</span>);</span><br><span class="line">            System.out.println(<span class="string">"child-thread-e:"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">"parent-thread-e:"</span> + threadLocal.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">parent-thread-s:<span class="number">2020</span></span><br><span class="line">parent-thread-e:<span class="number">2020</span></span><br><span class="line">child-thread-s:<span class="literal">null</span></span><br><span class="line">child-thread-e:<span class="number">2021</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>有利必有弊，虽然解决了上面说到的问题，但是每个线程都创建了变量副本，这时就要考虑它对资源的消耗，使用ThreadLocal时占用的内存资源肯定是会比没有使用的时占用的多。</p><p>在之前的文章有提到synchronized，同样是解决线程安全的，那么他俩到底有啥区别呢？</p><p> synchronized，采用的是阻塞的方式，让线程等待，保证有序进行访问；不占用其他资源，可以说是采用了时间换取空间的策略；而ThreadLocal和线程同步机制相比较，恰好相反，它采用的是以空间换取时间的策略。</p><p>下面来看下ThreadLocal的源码</p><h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，一个线程中的多个ThreadLocal是通过该线程的ThreadLocalMap来管理的；也就是说，每个线程都维护有一个ThreadLocalMap。当在线程中使用来自其他线程的ThreadLocal时，在set的时候，是在根据线程名查找自己线程中是否有ThreadLocalMap，若没有则创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap构造函数"><a href="#ThreadLocalMap构造函数" class="headerlink" title="ThreadLocalMap构造函数"></a>ThreadLocalMap构造函数</h3><p>ThreadLocalMap是ThreadLocal的一个静态内部类，一个简单的Map结构，阈值为16*2/3,底层为数组，数组元素为Entry，Entry采用的是弱引用的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry持有ThreadLocal的弱引用，而table属于ThreadLocalMap，因而，ThreadLocalMap的key采用对ThreadLocal的弱引用。弱引用的生命周期短语软引用，远短于强引用，因此，还需注意垃圾回收的情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法先是获取到当前线程的ThreadLocalMap，再根据ThreadLocal这个key来获取值；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据hashcode值来进行获取数组中对应的Entry对象元素；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果没有获取到，那么用线性碰撞的方式；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该位置置空，再哈希；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>移除的是当前线程中ThreadLocalMap对应的ThreadLocal  key值，解除弱引用；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响；</li><li>一个ThreadLocal对应着多个ThreadLocalMap，每个ThreadLocalMap对应着一个线程；</li><li>如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</li></ul>]]></content>
    
    <summary type="html">
    
      ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响。
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://xxsu.xyz/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://xxsu.xyz/article/7cab1e06/"/>
    <id>https://xxsu.xyz/article/7cab1e06/</id>
    <published>2020-12-22T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.844Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 二叉树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉搜索树 </span>&#123;</span><br><span class="line">    <span class="comment">//    是否有效的二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(Node node, <span class="keyword">int</span> minVal, <span class="keyword">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.data &lt;= minVal || node.data &gt;= maxVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, minVal, node.data)</span><br><span class="line">                &amp;&amp; isValidBST(node.right, node.data, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    打印二叉树每层节点;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeBFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                linkedList.add(node.data);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;res&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    之字形打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeBFS_zhi</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    linkedList.addLast(node.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    linkedList.addFirst(node.data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;res&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, Node root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height &gt;= list.size()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; temp = list.get(height);</span><br><span class="line">        temp.add(root.data);</span><br><span class="line">        dfs(list, root.left, height + <span class="number">1</span>);</span><br><span class="line">        dfs(list, root.right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    打印二叉树每层节点;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeDFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(list, root, <span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(data[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    任意方式创建二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">insertSearchTree</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.data) &#123;</span><br><span class="line">            root.left = insertSearchTree(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.data) &#123;</span><br><span class="line">            root.right = insertSearchTree(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    搜索二叉树遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchTree</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == temp.data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; temp.data) &#123;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      二叉搜索树实现
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉搜索树" scheme="https://xxsu.xyz/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>异步流使用详解</title>
    <link href="https://xxsu.xyz/article/762aaa36/"/>
    <id>https://xxsu.xyz/article/762aaa36/</id>
    <published>2020-12-15T07:46:00.000Z</published>
    <updated>2021-02-17T11:37:55.070Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123; <span class="comment">// 序列构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们正在计算</span></span><br><span class="line">        yield(i) <span class="comment">// 产生下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 假装我们在这里做了一些异步的事情</span></span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意使用Flow类型构建器函数：</p><ul><li>名为 flow的 Flow类型构建器函数。</li><li><code>flow { ... }</code> 构建块中的代码可以挂起。</li><li>函数 <code>simple</code> 不再标有 <code>suspend</code> 修饰符。</li><li>流使用 emit函数 <em>发射</em> 值。</li><li>流使用 collect 函数 <em>收集</em> 值。</li></ul><p>我们可以在 <code>simple</code> 的 <code>flow { ... }</code> 函数体内使用 <code>Thread.sleep</code> 代替 delay 以观察主线程在本案例中被阻塞了。</p><p>flow 构建器中的代码直到流被收集的时候才运行</p><h3 id="流的超时取消"><a href="#流的超时取消" class="headerlink" title="流的超时取消"></a>流的超时取消</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)          </span><br><span class="line">        println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123; <span class="comment">// 在 250 毫秒后超时</span></span><br><span class="line">        simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h3><p><code>flow { ... }</code> 构建器是最基础的一个    </p><p>flowOf 构建器定义了一个发射固定值集的流。<br>使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个整数区间转化为流</span></span><br><span class="line">(<span class="number">1</span>..<span class="number">3</span>).asFlow().collect &#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="过渡流操作符"><a href="#过渡流操作符" class="headerlink" title="过渡流操作符"></a>过渡流操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 模仿长时间运行的异步工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"response <span class="variable">$request</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 一个请求流</span></span><br><span class="line">        .map &#123; request -&gt; performRequest(request) &#125;</span><br><span class="line">        .collect &#123; response -&gt; println(response) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">response <span class="number">1</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 一个请求流</span></span><br><span class="line">    .transform &#123; request -&gt;</span><br><span class="line">        emit(<span class="string">"Making request <span class="variable">$request</span>"</span>) </span><br><span class="line">        emit(performRequest(request)) </span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123; response -&gt; println(response) &#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Making request <span class="number">1</span></span><br><span class="line">response <span class="number">1</span></span><br><span class="line">Making request <span class="number">2</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">Making request <span class="number">3</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="限长操作符"><a href="#限长操作符" class="headerlink" title="限长操作符"></a>限长操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                          </span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>) </span><br><span class="line">        println(<span class="string">"This line will not execute"</span>)</span><br><span class="line">        emit(<span class="number">3</span>)    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">"Finally in numbers"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    numbers() </span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// 只获取前两个</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="末端流操作符"><a href="#末端流操作符" class="headerlink" title="末端流操作符"></a>末端流操作符</h3><p>末端操作符：</p><ul><li>转化为各种集合，例如 toList 与 toSet。</li><li>获取第一个（first）值与确保流发射单个（single）值的操作符。</li><li>使用 reduce 与 fold 将流规约到单个值。</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = (<span class="number">1</span>..<span class="number">5</span>).asFlow()</span><br><span class="line">    .map &#123; it * it &#125; <span class="comment">// 数字 1 至 5 的平方                        </span></span><br><span class="line">    .reduce &#123; a, b -&gt; a + b &#125; <span class="comment">// 求和（末端操作符）</span></span><br><span class="line">println(sum)</span><br></pre></td></tr></table></figure><p>输出： 55</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>过滤偶数并将其映射到字符串</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">5</span>).asFlow()</span><br><span class="line">    .filter &#123;</span><br><span class="line">        println(<span class="string">"Filter <span class="variable">$it</span>"</span>)</span><br><span class="line">        it % <span class="number">2</span> == <span class="number">0</span>              </span><br><span class="line">    &#125;              </span><br><span class="line">    .map &#123; </span><br><span class="line">        println(<span class="string">"Map <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="string">"string <span class="variable">$it</span>"</span></span><br><span class="line">    &#125;.collect &#123; </span><br><span class="line">        println(<span class="string">"Collect <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Filter 1</span><br><span class="line">Filter 2</span><br><span class="line">Map 2</span><br><span class="line">Collect string 2</span><br><span class="line">Filter 3</span><br><span class="line">Filter 4</span><br><span class="line">Map 4</span><br><span class="line">Collect string 4</span><br><span class="line">Filter 5</span><br></pre></td></tr></table></figure><p>通常，withContext 用于在 Kotlin 协程中改变代码的上下文，但是 flow {…} 构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit）。</p>]]></content>
    
    <summary type="html">
    
      流的使用以及常见操作符的讲解
    
    </summary>
    
    
      <category term="kotlin" scheme="https://xxsu.xyz/categories/kotlin/"/>
    
    
      <category term="异步流" scheme="https://xxsu.xyz/tags/%E5%BC%82%E6%AD%A5%E6%B5%81/"/>
    
      <category term="协程" scheme="https://xxsu.xyz/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池原理</title>
    <link href="https://xxsu.xyz/article/335c74d5/"/>
    <id>https://xxsu.xyz/article/335c74d5/</id>
    <published>2020-12-05T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.862Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>优点：</p><ul><li>能够实现复用</li><li>线程统一管理</li></ul><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li><code>corePoolSize</code> 为线程池的基本大小。</li><li><code>maximumPoolSize</code> 为线程池最大线程大小。</li><li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li><li><code>workQueue</code> 用于存放任务的阻塞队列。</li><li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>提交任务》核心线程是否已满》阻塞队里是否已满》线程池是否已满》拒绝策略</strong></p><p>拒绝策略</p><p><code>AbortPolicy</code>： 直接拒绝所提交的任务，并抛出<code>RejectedExecutionException</code>异常。</p><p><code>CallerRunsPolicy</code>：只用调用者所在的线程来执行任务。</p><p><code>DiscardPolicy</code>：不处理直接丢弃掉任务。</p><p><code>DiscardOldestPolicy</code>：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。</p><h3 id="延时任务与定时任务"><a href="#延时任务与定时任务" class="headerlink" title="延时任务与定时任务"></a>延时任务与定时任务</h3><p>线程池可以处理延时任务，设置延迟时间执行任务</p><p>通过execute执行<strong>无返回值</strong>，而submit提交则有<strong>Future的返回值</strong>，其中get方法可以设置timeout时间，若deadline到达，还没有get到结果，则抛出异常。通过这个方法可以处理定时任务。但是值得注意的是，<strong>该方法会直接阻塞get所在线程！！</strong>若是在主线程中直接引起ui卡住，长时间超过5s则ANR。若想不卡主线程，而设置定时任务可以<strong>采用timer方式</strong>，除了这种方式外还可以采用<strong>开启守护线程</strong>方式来解决。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当需要频繁创建线程来执行任务的时候</p><p>需要延迟执行任务</p><p>多线程&amp;多任务场景以及单线程场景</p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>例如协程。协程（kotlin）的执行环境也是线程池的应用之一。当在主线程中使用协程提交任务，<strong>这些任务会被调度到线程池的各个线程中</strong>，虽然不在同一个线程，但是能够保证一定的执行顺序。通过自定义协程调度器可以设置其执行的指定线程池。总的来说，依靠的还是线程池。</p><p>例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorDispatcher</span></span></span><br><span class="line">    : AbstractCoroutineContextElement(ContinuationInterceptor),</span><br><span class="line">        ContinuationInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executorService = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">        Thread(it, <span class="string">"SingleThreadExecutor"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> MyContinuation(continuation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContinuation</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> origin: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = origin.context</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            executorService.submit &#123;</span><br><span class="line">                origin.resumeWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        executorService.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> dispatcher = SingleThreadExecutorDispatcher()</span><br><span class="line">    log(<span class="string">"AA"</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">"BB"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    dispatcher.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">main</span>] AA</span><br><span class="line">[<span class="meta">SingleThreadExecutor</span>] BB</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      线程池的执行流程，以及应用场景等
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="https://xxsu.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>abbrlink踩坑</title>
    <link href="https://xxsu.xyz/article/856a5aa8/"/>
    <id>https://xxsu.xyz/article/856a5aa8/</id>
    <published>2020-11-21T13:26:00.000Z</published>
    <updated>2021-02-02T16:09:52.897Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>博客搭建有一段时间了，但是链接地址却和文件名紧紧绑定在一起，及其不方便扩展，也给写作带来些许不便。</p><p>于是乎，今天便想着来搞搞；为了生成永久链接，这里使用abbrlink这个插件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部安装</span></span><br><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>嗯哼~ 安装失败….再来</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>ok了，这里配置了镜像，还是cnpm好用；</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>继续，开始配置外部的 _config.yml </p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:abbrlink/</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment">#true(default)</span></span><br><span class="line">     <span class="attr">depth:</span>        <span class="comment">#3(default)</span></span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#enable auto title, it can auto fill the title by path</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> <span class="comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span></span><br></pre></td></tr></table></figure><p>大家应该都看得懂了~</p><p>不过这里有个注意事项，auto_category 默认是true，这里我设置成false；下面是auto_category的源码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> opt_AutoCategoryEnable = config.auto_category &amp;&amp; config.auto_category.enable;</span><br><span class="line"><span class="keyword">var</span> overwrite = config.auto_category &amp;&amp; config.auto_category.over_write;</span><br><span class="line"><span class="keyword">if</span> (opt_AutoCategoryEnable &amp;&amp; overwrite) &#123;</span><br><span class="line"><span class="keyword">var</span> categories = data.source.split(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">var</span> opt_AutoCategoryDepth = config.auto_category.depth || <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> depth = opt_AutoCategoryDepth || categories.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (categories.length - <span class="number">2</span> == <span class="number">0</span> || depth == <span class="number">0</span>) &#123;</span><br><span class="line">tmpPost.categories = <span class="keyword">this</span>.config.default_category;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> newCategories = categories.slice(<span class="number">1</span>, <span class="number">1</span> + <span class="built_in">Math</span>.min(depth, categories.length - <span class="number">2</span>));</span><br><span class="line"><span class="comment">//prevents duplicate file changes</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">!<span class="built_in">Array</span>.isArray(tmpPost.categories) ||</span><br><span class="line">!tmpPost.categories.join(<span class="string">'_'</span>) == newCategories.join(<span class="string">'_'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">tmpPost.categories = newCategories;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来查看一下hexo-abbrlink的版本</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">npm view hexo-abbrlink versions --json</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.0"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.1"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.2"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.3"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.1"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.2"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.4"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.5"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.1.5"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.1.6"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.2.0"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.2.1"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure><p>默认安装的是最新版是2.2.1；</p><p>abbrlink 的原理是在每篇文章的属性里加上一个16位/32位的十六进制的数，来作为文章唯一的id。具体内部实现依靠hexo-fs插件来进行写入生成；</p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>在配置好以上内容之后，就可以开始执行生成索引了，这是最后一步了。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure><p>可执行了以上命令之后，情况又不妙了~</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">Error: EEXIST: file already exists, mkdir '</span>F:\software2\MyGithubPage\hexo\source\_posts\Android<span class="string">'</span></span><br><span class="line"><span class="string">    at Object.mkdirSync (fs.js:729:3)</span></span><br><span class="line"><span class="string">    at Object.writeFileSync (F:\software2\MyGithubPage\hexo\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js:63:6)</span></span><br><span class="line"><span class="string">    at Hexo.logic (F:\software2\MyGithubPage\hexo\node_modules\_hexo-abbrlink@2.2.1@hexo-abbrlink\lib\logic.js:98:20)</span></span><br><span class="line"><span class="string">    at Hexo.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Hexo.&lt;anonymous&gt; (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\method.js:15:34)</span></span><br><span class="line"><span class="string">    at Promise.each.filter (F:\software2\MyGithubPage\hexo\node_modules\hexo\lib\extend\filter.js:62:52)</span></span><br><span class="line"><span class="string">    at tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Object.gotValue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:166:18)</span></span><br><span class="line"><span class="string">    at Object.gotAccum (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:155:25)</span></span><br><span class="line"><span class="string">    at Object.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Promise._settlePromiseFromHandler (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:547:31)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:604:18)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise0 (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:649:10)</span></span><br><span class="line"><span class="string">    at Promise._settlePromises (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:729:18)</span></span><br><span class="line"><span class="string">    at _drainQueueStep (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:93:12)</span></span><br><span class="line"><span class="string">    at _drainQueue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:86:9)</span></span><br><span class="line"><span class="string">    at Async._drainQueues (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:102:5)</span></span><br><span class="line"><span class="string">    at Immediate.Async.drainQueues [as _onImmediate] (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:15:14)</span></span><br><span class="line"><span class="string">    at runCallback (timers.js:693:18)</span></span><br><span class="line"><span class="string">    at tryOnImmediate (timers.js:664:5)</span></span><br><span class="line"><span class="string">    at processImmediate (timers.js:646:5)</span></span><br></pre></td></tr></table></figure><p>报了一堆堆栈日志，通过观察，我们可以看到程序是在执行了 logic.js 之后，接着执行 fs.js 报错的；文件已存在，程序还在强行创建!!!!</p><p>为了一探究竟，我们进入到logic.js 中看看</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFileSync(data.full_source, postStr, <span class="string">'utf-8'</span>);</span><br></pre></td></tr></table></figure><p>程序是执行了这段代码导致的，如果abbrlink不存在的话，该插件会遍历文件夹中的文件进行写入，然后创建新的文件夹；继续追，查看下package.json</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  "hexo-front-matter": "^1.0.0",</span><br><span class="line">  "hexo-fs": "^3.1.0"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>依赖的最新的fs是3.1。进入hexo-js中，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeFileSync</span>(<span class="params">path, data, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'path is required!'</span>);</span><br><span class="line"></span><br><span class="line">  fs.mkdirSync(dirname(path), &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  fs.writeFileSync(path, data, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好家伙，直接就创建了，都不检查下的吗？？</p><h2 id="手动修改hexo-fs"><a href="#手动修改hexo-fs" class="headerlink" title="手动修改hexo-fs"></a>手动修改hexo-fs</h2><p>路径：<code>\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js</code>  文件</p><p>在文件中添加以下函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkParentSync</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'path is required!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> parent = dirname(path);</span><br><span class="line">  <span class="keyword">var</span> exist = fs.existsSync(parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exist) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mkdirsSync(parent);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'EEXIST'</span>) <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将fs.mkdirSync 注释掉，增加 checkParentSync(path);  的调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs.mkdirSync(dirname(path), &#123; recursive: true &#125;);</span></span><br><span class="line">checkParentSync(path);</span><br></pre></td></tr></table></figure><p>最后，大功告成~:happy:</p>]]></content>
    
    <summary type="html">
    
      为博客生成唯一永久链接
    
    </summary>
    
    
      <category term="踩坑日记" scheme="https://xxsu.xyz/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="abbrlink" scheme="https://xxsu.xyz/tags/abbrlink/"/>
    
  </entry>
  
  <entry>
    <title>协程详解</title>
    <link href="https://xxsu.xyz/article/c47eb885/"/>
    <id>https://xxsu.xyz/article/c47eb885/</id>
    <published>2020-11-14T07:46:00.000Z</published>
    <updated>2021-02-17T11:34:43.913Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><code>kotlinx.coroutines</code> 是由 JetBrains 开发的功能丰富的协程库。它涵盖了的很多启用高级协程的原语，包括 <code>launch</code>、 <code>async</code> 等等。</p><p>本质上，协程是轻量级的线程。 它们在某些 <strong>CoroutineScope</strong>上下文中与 <strong>launch</strong> <em>协程构建器</em> 一起启动。</p><p>当我们在 <strong>GlobalScope</strong> 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。</p><p> <strong>delay</strong>是一个特殊的 <strong><em>挂起函数</em></strong> ，它不会造成线程阻塞，但是会 <strong><em>挂起</em></strong> 协程，并且只能在协程中使用。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul><li><em>非阻塞的</em> <code>delay(……)</code> </li><li><em>阻塞的</em> <code>Thread.sleep(……)</code></li><li><em>阻塞的</em>runBlocking{..delay(….)..}  </li></ul><p>注意： runBlocking会阻塞主线程，直到内部执行完成</p><p>例子</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// 开始执行主协程</span></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// 在后台启动一个新的协程并继续，这与局部启动（launch &#123;&#125;）不同</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 主协程在这里会立即执行</span></span><br><span class="line">    delay(<span class="number">2000L</span>)      <span class="comment">// 延迟 2 秒来保证 JVM 存活,或者使用 job.join() </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>挂起函数单元测试</strong></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testMySuspendingFunction</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里我们可以使用任何喜欢的断言风格来使用挂起函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h3><ul><li>runBlocking 方法会阻塞当前线程来等待；</li><li>coroutineScope 只是挂起，会释放底层线程用于其他用途。</li></ul><p>runBlocking 是常规函数，而 coroutineScope 是挂起函数。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">"Task from runBlocking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; <span class="comment">// 创建一个协程作用域</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>) </span><br><span class="line">            println(<span class="string">"Task from nested launch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">"Task from coroutine scope"</span>) <span class="comment">// 这一行会在内嵌 launch 之前输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"Coroutine scope is over"</span>) <span class="comment">// 这一行在内嵌 launch 执行完毕后才输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Task <span class="keyword">from</span> coroutine scope</span><br><span class="line">Task <span class="keyword">from</span> runBlocking</span><br><span class="line">Task <span class="keyword">from</span> nested launch</span><br><span class="line">Coroutine scope <span class="keyword">is</span> over</span><br></pre></td></tr></table></figure><h3 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是你的第一个挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hello,</span></span><br><span class="line">World!</span><br></pre></td></tr></table></figure><p>注意：在 GlobalScope 中启动的活动协程并不会使进程保活。它们就像守护线程。</p><h2 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"job: I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">    println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">    job.cancel() <span class="comment">// 取消该作业</span></span><br><span class="line">    job.join() <span class="comment">// 等待作业执行结束；可以用cancelAndJoin 取代上面两行</span></span><br><span class="line">    println(<span class="string">"main: Now I can quit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">0</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">1</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">2</span> <span class="string">...</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">I'm</span> <span class="string">tired</span> <span class="string">of</span> <span class="string">waiting!</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">Now</span> <span class="string">I</span> <span class="string">can</span> <span class="string">quit.</span></span><br></pre></td></tr></table></figure><p>如果协程正在执行计算任务，并且没有检查取消的话，那么它是不能被取消的</p><p>有两种方法来使执行计算的代码可以被取消。第一种方法是定期调用挂起函数来检查取消。对于这种目的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html" target="_blank" rel="noopener">yield</a> 是一个好的选择。 另一种方法是显式的检查取消状态。</p><p>isActive 是一个可以被使用在 CoroutineScope 中的扩展属性。</p><h3 id="运行不能取消的代码块"><a href="#运行不能取消的代码块" class="headerlink" title="运行不能取消的代码块"></a>运行不能取消的代码块</h3><p>所有良好的关闭操作（关闭一个文件、取消一个作业、或是关闭任何一种通信通道）通常都是非阻塞的，并且不会调用任何挂起函数。</p><p>当你需要挂起一个被取消的协程，你可以将相应的代码包装在 withContext(NonCancellable) {……} 中，并使用 withContext 函数以及 NonCancellable 上下文</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"job: I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        withContext(NonCancellable) &#123;</span><br><span class="line">            println(<span class="string">"job: I'm running finally"</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">"job: And I've just delayed for 1 sec because I'm non-cancellable"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">job.cancelAndJoin() <span class="comment">// 取消该作业并等待它结束</span></span><br><span class="line">println(<span class="string">"main: Now I can quit."</span>)</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">0</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">1</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">2</span> <span class="string">...</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">I'm</span> <span class="string">tired</span> <span class="string">of</span> <span class="string">waiting!</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">running</span> <span class="string">finally</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">And</span> <span class="string">I've</span> <span class="string">just</span> <span class="string">delayed</span> <span class="string">for</span> <span class="number">1</span> <span class="string">sec</span> <span class="string">because</span> <span class="string">I'm</span> <span class="string">non-cancellable</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">Now</span> <span class="string">I</span> <span class="string">can</span> <span class="string">quit.</span></span><br></pre></td></tr></table></figure><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>例子1</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">        println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">        delay(<span class="number">500L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"Done"</span> <span class="comment">// 在它运行得到结果之前取消它</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Result is <span class="variable">$result</span>"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">0</span> <span class="string">...</span></span><br><span class="line"><span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">1</span> <span class="string">...</span></span><br><span class="line"><span class="string">Result</span> <span class="string">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> acquired = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123; acquired++ &#125; <span class="comment">// Acquire the resource</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123; acquired-- &#125; <span class="comment">// Release the resource</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">100_000</span>) &#123; <span class="comment">// Launch 100K coroutines</span></span><br><span class="line">            launch &#123; </span><br><span class="line">                <span class="keyword">var</span> resource: Resource? = <span class="literal">null</span> <span class="comment">// Not acquired yet</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    withTimeout(<span class="number">60</span>) &#123; <span class="comment">// Timeout of 60 ms</span></span><br><span class="line">                        delay(<span class="number">50</span>) <span class="comment">// Delay for 50 ms</span></span><br><span class="line">                        resource = Resource() <span class="comment">// Store a resource to the variable if acquired      </span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// We can do something else with the resource here</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                    resource?.close() <span class="comment">// Release the resource if it was acquired</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Outside of runBlocking all coroutines have completed</span></span><br><span class="line">    println(acquired) <span class="comment">// Print the number of resources still acquired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：该例子是安全的，因为都在同一个线程中。</p><h3 id="async-并发"><a href="#async-并发" class="headerlink" title="async 并发"></a>async 并发</h3><p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p><p>请注意，使用协程进行并发总是显式的。</p><p>async 可以通过将 start 参数设置为 CoroutineStart.LAZY 而变为惰性的。 在这个模式下，只有结果通过 await 获取的时候协程才会启动，或者在 Job 的 start 函数调用的时候。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        <span class="comment">// 执行一些计算</span></span><br><span class="line">        one.start() <span class="comment">// 启动第一个</span></span><br><span class="line">        two.start() <span class="comment">// 启动第二个</span></span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里也做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程上下文与调度器"><a href="#协程上下文与调度器" class="headerlink" title="协程上下文与调度器"></a>协程上下文与调度器</h2><p>所有的协程构建器诸如 launch 和 async 接收一个可选的 CoroutineContext 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。</p><p>newSingleThreadContext 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。</p><p><code>launch(Dispatchers.Default) { …… }</code> 与 <code>GlobalScope.launch { …… }</code> 使用相同的调度器。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch &#123; <span class="comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class="line">    println(<span class="string">"main runBlocking      : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">launch(Dispatchers.Unconfined) &#123; <span class="comment">// 不受限的——将工作在主线程中</span></span><br><span class="line">    println(<span class="string">"Unconfined            : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">launch(Dispatchers.Default) &#123; <span class="comment">// 将会获取默认调度器</span></span><br><span class="line">    println(<span class="string">"Default               : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">launch(newSingleThreadContext(<span class="string">"MyOwnThread"</span>)) &#123; <span class="comment">// 将使它获得一个新的线程</span></span><br><span class="line">    println(<span class="string">"newSingleThreadContext: I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Unconfined            </span>: I'm working in thread main <span class="variable">@coroutine</span><span class="number">#3</span></span><br><span class="line"><span class="attribute">Default               </span>: I'm working in thread DefaultDispatcher-worker-<span class="number">1</span> <span class="variable">@coroutine</span><span class="number">#4</span></span><br><span class="line">main <span class="attribute">runBlocking      </span>: I'm working in thread main <span class="variable">@coroutine</span><span class="number">#2</span></span><br><span class="line"><span class="attribute">newSingleThreadContext</span>: I'm working in thread MyOwnThread <span class="variable">@coroutine</span><span class="number">#5</span></span><br></pre></td></tr></table></figure><h3 id="非受限调度器-vs-受限调度器"><a href="#非受限调度器-vs-受限调度器" class="headerlink" title="非受限调度器 vs 受限调度器"></a>非受限调度器 vs 受限调度器</h3><p>Dispatchers.Unconfined 协程调度器在调用它的线程启动了一个协程，但它仅仅只是运行到第一个挂起点。挂起后，它恢复线程中的协程，而这完全由被调用的挂起函数来决定。非受限的调度器非常适用于执行不消耗 CPU 时间的任务，以及不更新局限于特定线程的任何共享数据（如UI）的协程。</p>]]></content>
    
    <summary type="html">
    
      kotlinx.coroutines是由JetBrains开发的功能丰富的协程库。本质上，协程是轻量级的线程。
    
    </summary>
    
    
      <category term="kotlin" scheme="https://xxsu.xyz/categories/kotlin/"/>
    
    
      <category term="协程" scheme="https://xxsu.xyz/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>生产者与消费者模式</title>
    <link href="https://xxsu.xyz/article/e6c2b842/"/>
    <id>https://xxsu.xyz/article/e6c2b842/</id>
    <published>2020-11-06T11:43:00.000Z</published>
    <updated>2021-03-07T00:23:19.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>通过使用CountDownLatch 来模拟并发场景，用synchronized来进行多线程间的同步，保障线程安全。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> full = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNum = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> LinkedBlockingQueue&lt;String&gt; link = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Runnable product = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == full) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    link.add(Thread.currentThread().getName() + <span class="string">" product: "</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" consumer: "</span> + link.poll());</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            Thread pThread = <span class="keyword">new</span> Thread(product);</span><br><span class="line">            pThread.start();</span><br><span class="line">            Thread cThread = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">            cThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="image-20210306193021365.png" alt="image-20210306193021365"></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>采用重入锁（ReentrantLock）机制来实现，使用了两个Condition，分别控制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> full = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNum = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkedBlockingQueue&lt;String&gt; link = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Runnable product = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == full) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    link.add(Thread.currentThread().getName() + <span class="string">" product: "</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        notEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" consumer: "</span> + link.poll());</span><br><span class="line">                    notFull.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            Thread pThread = <span class="keyword">new</span> Thread(product);</span><br><span class="line">            pThread.start();</span><br><span class="line">            Thread cThread = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">            cThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="image-20210306193529183.png" alt="image-20210306193529183"></p><p>当然除了以上两种方式之外，还可以用Semaphore 共享锁机制来实现以及阻塞队列的take方法，感兴趣的可以去实现一下。</p>]]></content>
    
    <summary type="html">
    
      生产者与消费者模式的多种实现
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="生产者与消费者" scheme="https://xxsu.xyz/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>线程模型&amp;线程池</title>
    <link href="https://xxsu.xyz/article/a6b81681/"/>
    <id>https://xxsu.xyz/article/a6b81681/</id>
    <published>2020-10-20T08:40:00.000Z</published>
    <updated>2021-02-21T08:48:10.995Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h2><ul><li>内核级线程模型</li><li>用户级线程模型</li><li>混合型线程模型</li></ul><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>用户线程与内核线程是1对1关系。</p><p>优点：该模型在一个线程执行阻塞系统调用时，能够允许另一个线程继续执行，允许多个线程并行运行在多处理器系统上。</p><p>缺点：创建一个用户线程就要创建一个相应的内核线程。为了提升性能，大多数实现限制了系统支持的线程数量。</p><p>应用：Linux、Windows 操作系统都实现了一对一模型。</p><h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户线程与内核线程是多对1关系。映射多个用户级线程到一个内核线程。</p><p>优点：线程管理是由用户空间的线程库来完成的，因此效率更高。</p><p>缺点：如果一个线程执行阻塞系统调用，那么整个进程将会阻塞。再者，因为任一时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上。</p><p>应用：现在几乎没有系统继续使用这个模型，因为它无法利用多个处理核。</p><h3 id="混合型线程模型"><a href="#混合型线程模型" class="headerlink" title="混合型线程模型"></a>混合型线程模型</h3><p>用户线程与内核线程是多对多关系。</p><p>优点：开发人员可以创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。而且，当一个线程执行阻塞系统调用时，内核可以调度另一个线程来执行；</p><p>缺点：这种动态关联机制的实现很复杂，也需要用户自己去实现；</p><p>应用：Go语言中的并发就是使用的这种实现方式。</p><h2 id="线程生命状态"><a href="#线程生命状态" class="headerlink" title="线程生命状态"></a>线程生命状态</h2><ul><li><strong>NEW</strong> ，新建</li><li><strong>RUNNABLE</strong> ，运行</li><li><strong>BLOCKED</strong> ，阻塞</li><li><strong>WAITING</strong> ，等待</li><li><strong>TIMED_WAITING</strong> ，超时等待</li><li><strong>TERMINATED</strong>，终结</li></ul><h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>使用ExecutorService线程池</li></ul><blockquote><p>注意：其中前两种方式线程执行完后都没有返回值，<strong>后两种是带返回值</strong>的。</p></blockquote><p>例子</p><p><img src="image-20210221163248651.png" alt="image-20210221163248651"></p><p><img src="image-20210221163431129.png" alt="image-20210221163431129"></p><p>输出：</p><p><img src="image-20210221163506027.png" alt="image-20210221163506027"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>默认线程池：ThreadPoolExecutor </li><li>定时线程池：ScheduledThreadPoolExecutor </li></ul><h3 id="五种线程池创建类型"><a href="#五种线程池创建类型" class="headerlink" title="五种线程池创建类型"></a>五种线程池创建类型</h3><ul><li><p>newFixedThreadPool（<strong>固定大小线程池</strong>）</p></li><li><p>newSingleThreadExecutor(<strong>单个后台线程</strong>）</p></li><li><p>newCachedThreadPool（<strong>无界线程池，可以进行自动线程回收</strong>）</p></li><li><p>newScheduledThreadPool (<strong>可调度</strong>)</p></li></ul><p>​      创建一个定长线程池，支持<strong>定时及周期性任务执行</strong>。和 其他线程池最大的区别是使用的阻塞队列是 <strong>DelayedWorkQueue</strong>，而且多了两个定时执行的方法scheduleAtFixedRate和scheduleWithFixedDelay</p><ul><li>newWorkStealingPool（<strong>并行操作</strong>）</li></ul><p>​     JDK1.8新增newWorkStealingPool，适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类<strong>ForkJoinPool</strong>的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很<strong>耗时</strong>的任务中。</p>]]></content>
    
    <summary type="html">
    
      三种线程模型、线程池类型的详解
    
    </summary>
    
    
      <category term="并发编程" scheme="https://xxsu.xyz/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="https://xxsu.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android中协程的特点</title>
    <link href="https://xxsu.xyz/article/2905e442/"/>
    <id>https://xxsu.xyz/article/2905e442/</id>
    <published>2020-10-09T07:46:00.000Z</published>
    <updated>2021-02-17T11:34:43.898Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Android中协程的特点"><a href="#Android中协程的特点" class="headerlink" title="Android中协程的特点"></a>Android中协程的特点</h2><ul><li><strong>轻量</strong>：您可以在单个线程上运行多个协程，因为协程支持<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html" target="_blank" rel="noopener">挂起</a>，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。</li><li><strong>内存泄漏更少</strong>：使用<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" target="_blank" rel="noopener">结构化并发</a>机制在一个作用域内执行多项操作。</li><li><strong>内置取消支持</strong>：<a href="https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html" target="_blank" rel="noopener">取消</a>操作会自动在运行中的整个协程层次结构内传播。</li><li><strong>Jetpack 集成</strong>：许多 Jetpack 库都包含提供全面协程支持的<a href="https://developer.android.com/kotlin/ktx?hl=zh-cn" target="_blank" rel="noopener">扩展</a>。某些库还提供自己的<a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn" target="_blank" rel="noopener">协程作用域</a>，可供您用于结构化并发。</li></ul><p>非受限的调度器是一种高级机制，可以在某些极端情况下提供帮助而不需要调度协程以便稍后执行或产生不希望的副作用， 因为某些操作必须立即在协程中执行。 非受限调度器不应该在通常的代码中使用。</p><p>协程可以在一个线程上挂起并在其它线程上恢复。</p><h3 id="在不同线程间跳转"><a href="#在不同线程间跳转" class="headerlink" title="在不同线程间跳转"></a>在不同线程间跳转</h3><p>使用 <code>-Dkotlinx.coroutines.debug</code> JVM 参数运行下面的代码</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSingleThreadContext(<span class="string">"Ctx1"</span>).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(<span class="string">"Ctx2"</span>).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(<span class="string">"Started in ctx1"</span>)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(<span class="string">"Working in ctx2"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">"Back to ctx1"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[Ctx1 @coroutine#1]</span> <span class="selector-tag">Started</span> <span class="selector-tag">in</span> <span class="selector-tag">ctx1</span></span><br><span class="line"><span class="selector-attr">[Ctx2 @coroutine#1]</span> <span class="selector-tag">Working</span> <span class="selector-tag">in</span> <span class="selector-tag">ctx2</span></span><br><span class="line"><span class="selector-attr">[Ctx1 @coroutine#1]</span> <span class="selector-tag">Back</span> <span class="selector-tag">to</span> <span class="selector-tag">ctx1</span></span><br><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" <span class="selector-tag">java</span><span class="selector-class">.security</span><span class="selector-class">.AccessControlException</span>: <span class="selector-tag">Access</span> <span class="selector-tag">control</span> <span class="selector-tag">exception</span> <span class="selector-tag">due</span> <span class="selector-tag">to</span> <span class="selector-tag">security</span> <span class="selector-tag">reasons</span> <span class="selector-tag">in</span> <span class="selector-tag">web</span> <span class="selector-tag">playground</span>: </span><br><span class="line"> <span class="selector-tag">access</span> <span class="selector-tag">denied</span> ("<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.RuntimePermission</span>" "<span class="selector-tag">modifyThread</span>")</span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.SecurityManager</span><span class="selector-class">.checkPermission</span> (<span class="selector-tag">SecurityManager</span><span class="selector-class">.java</span><span class="selector-pseudo">:549)</span></span><br></pre></td></tr></table></figure><p>使用 runBlocking 来显式指定了一个上下文，并且另一个使用 withContext 函数来改变协程的上下文，而仍然驻留在相同的协程中</p><p>当我们不再需要某个在 newSingleThreadContext 中创建的线程的时候， 它使用了 Kotlin 标准库中的 use 函数来释放该线程。</p><p>注意，CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式。</p><p>当一个父协程被取消的时候，所有它的子协程也会被递归的取消。然而，当使用 GlobalScope 来启动一个协程时，则新协程的作业没有父作业。 因此它与这个启动的作用域无关且独立运作。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="string">"Started main coroutine"</span>)</span><br><span class="line"><span class="comment">// 运行两个后台值计算</span></span><br><span class="line"><span class="keyword">val</span> v1 = async(CoroutineName(<span class="string">"v1coroutine"</span>)) &#123;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    log(<span class="string">"Computing v1"</span>)</span><br><span class="line">    <span class="number">252</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> v2 = async(CoroutineName(<span class="string">"v2coroutine"</span>)) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="string">"Computing v2"</span>)</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">"The answer for v1 / v2 = <span class="subst">$&#123;v1.await() / v2.await()&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>协程上下文中定义多个元素</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Default + CoroutineName(<span class="string">"test"</span>)) &#123;</span><br><span class="line">    println(<span class="string">"I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="literal">I</span>'m working <span class="keyword">in</span> thread DefaultDispatcher-worker-<span class="number">1</span> <span class="meta">@test</span><span class="comment">#2</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mainScope = CoroutineScope(Dispatchers.Default) <span class="comment">// use Default for test purposes</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mainScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class="line">        repeat(<span class="number">10</span>) &#123; i -&gt;</span><br><span class="line">            mainScope.launch &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// Activity 类结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> activity = Activity()</span><br><span class="line">    activity.doSomething() <span class="comment">// 运行测试函数</span></span><br><span class="line">    println(<span class="string">"Launched coroutines"</span>)</span><br><span class="line">    delay(<span class="number">500L</span>) <span class="comment">// 延迟半秒钟</span></span><br><span class="line">    println(<span class="string">"Destroying activity!"</span>)</span><br><span class="line">    activity.destroy() <span class="comment">// 取消所有的协程</span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 为了在视觉上确认它们没有工作    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Launched coroutines</span><br><span class="line">Coroutine <span class="number">0</span> <span class="keyword">is</span> done</span><br><span class="line">Coroutine <span class="number">1</span> <span class="keyword">is</span> done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      介绍Android中协程的特点
    
    </summary>
    
    
      <category term="kotlin" scheme="https://xxsu.xyz/categories/kotlin/"/>
    
    
      <category term="协程" scheme="https://xxsu.xyz/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>几个经典的动态规划问题</title>
    <link href="https://xxsu.xyz/article/b2b6f046/"/>
    <id>https://xxsu.xyz/article/b2b6f046/</id>
    <published>2020-09-26T07:46:00.000Z</published>
    <updated>2021-03-07T00:23:19.942Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="硬币找零"><a href="#硬币找零" class="headerlink" title="硬币找零"></a>硬币找零</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(a,Integer.MAX_VALUE);</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; value) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                a[i] = Math.min(a[i], a[i - value] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+ <span class="string">" : "</span>+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>] &gt;= a[i]) &#123;</span><br><span class="line">            anchor = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, i - anchor + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">char</span>[] b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>][b.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[a.length][b.length]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      dp数组使用案例
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="https://xxsu.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法稳定性介绍</title>
    <link href="https://xxsu.xyz/article/a0d5c7de/"/>
    <id>https://xxsu.xyz/article/a0d5c7de/</id>
    <published>2020-09-15T07:46:00.000Z</published>
    <updated>2021-03-07T00:23:19.964Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="不稳定排序算法"><a href="#不稳定排序算法" class="headerlink" title="不稳定排序算法"></a>不稳定排序算法</h3><ol><li>选择排序 — O(n²)</li><li>希尔排序 — O(nlogn)</li><li>堆排序 — O(nlogn)</li><li>快速排序 — O(nlogn) 期望时间,O(n²) 最坏情况; </li></ol><br/><h3 id="稳定排序算法"><a href="#稳定排序算法" class="headerlink" title="稳定排序算法"></a>稳定排序算法</h3><ol><li>冒泡排序  — O(n²)</li><li>插入排序 — O(n²)</li><li>桶排序 — O(n); 需要 O(k)额外空间</li><li>计数排序  — O(n+k); 需要O(n+k) 额外空间</li><li>合并排序  — O(nlogn); 需要O(n) 额外空间</li><li>二叉排序树排序   —O(n log n) 期望时间; O(n²)最坏时间; 需要O(n) 额外空间</li><li>基数排序  —O(n·k); 需要O(n) 额外空间</li></ol><h2 id="快排code"><a href="#快排code" class="headerlink" title="快排code"></a>快排code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] qSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = arr[s], i = s, j = e;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((i&lt;j)&amp;&amp;(arr[j]&gt;p)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((i&lt;j)&amp;&amp;(arr[i]&lt;p)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((arr[i]==arr[j])&amp;&amp;(i&lt;j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s&lt;i-<span class="number">1</span>) arr=qSort(arr,s,i-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (j+<span class="number">1</span>&lt;e) arr=qSort(arr,j+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">return</span> (arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    arr=qSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:arr) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      算法稳定性介绍
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="稳定性" scheme="https://xxsu.xyz/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
      <category term="快排" scheme="https://xxsu.xyz/tags/%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>JavaPoet讲解</title>
    <link href="https://xxsu.xyz/article/fa8ccf2d/"/>
    <id>https://xxsu.xyz/article/fa8ccf2d/</id>
    <published>2020-09-13T09:27:00.000Z</published>
    <updated>2021-02-13T09:30:58.389Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="JavaPoet"><a href="#JavaPoet" class="headerlink" title="JavaPoet"></a>JavaPoet</h2><p>JavaPoet是Square推出的开源Java代码生成框架，提供Java Api生成.java源文件。通过这个框架可以很方便的使用它根据注解、数据库模式、协议格式等来对应生成代码。用这种自动化生产代码的方式可以来替换冗杂重复的工作，提高工作效率。</p><p>代码生成技术相当于元编程，可用于编译期根据注解等元数据动态生成Java类。在框架Dagger、ButterKnife等等中就是利用JavaPoet注解的方式实现生成所需的类。</p><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ul><li>JavaFile：用于构造输出包含一个顶级类的Java文件，是对.java文件的抽象；</li><li>TypeSpec：TypeSpec是类/接口/枚举的抽象；</li><li>MethodSpec：MethodSpec是方法/构造函数的抽象；</li><li>FieldSpec：FieldSpec是成员变量/字段的抽象；</li><li>ParameterSpec：ParameterSpec用于创建参数；</li><li>AnnotationSpec：AnnotationSpec用于创建注解；</li><li>TypeName：类型；</li><li>ClassName：用来包装一个类；</li></ul><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul><li>$L     参数，方法中的参数；</li><li>$S     字符串，和String.format中%s一样；</li><li>$N     方法或变量的名称，我们自己生成的方法名或者变量名等等；</li><li>$T     类型名，指的是TypeName，该模板主要将Class抽象出来，用传入的TypeName指向的Class来代替；</li></ul><p>设置方法抛出异常,可以使用addException方法,传入指定的异常的ClassName,即可为该方法设置其抛出该异常.</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compileOnly <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class="line">annotationProcessor <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class="line">implementation <span class="string">'com.squareup:javapoet:1.12.1'</span></span><br></pre></td></tr></table></figure><p>一般情况下，还需要配合注解解释器来使用才行，一般我们常用的或注解解释器为 AutoService 和 gradle-incap-helper。</p><h4 id="自定义处理器"><a href="#自定义处理器" class="headerlink" title="自定义处理器"></a>自定义处理器</h4><p>注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以自定义注解，并注册相应的注解处理器（自定义的注解处理器需继承自AbstractProcessor）。</p><p>注意：注解处理器是运行在独立的虚拟机JVM中，javac启动一个完整Java虚拟机来运行注解处理器。</p><h5 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h5><ul><li>init(ProcessingEnvironment env): 初始化方法，会被注解处理器调用，可以从ProcessingEnviroment对象中获取到如Elements, Types,Messager和Filer等工具类；</li><li>process(Set&lt; ? extends TypeElement&gt; annotations, RoundEnvironment env): 真正的处理方法，也是核心的方法。在这里写如何处理注解的代码，以及生成的java文件需要存放的位置。参数RoundEnviroment可以查询出包含特定注解的被注解元素。</li><li>getSupportedAnnotationTypes(): 指定注解处理器是注册给哪个注解的。返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</li><li>getSupportedSourceVersion(): 用来指定你使用的Java版本。通常返回SourceVersion.latestSupported()。</li></ul><p>技巧：后面两个方法还有另一种写法（通过注解给定）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(&#123;Constants.BINDERVIEW_ANNOTATION_TYPES&#125;)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SupportedAnnotationTypes</span>(<span class="title">Constant</span>.<span class="title">ANY_TYPE</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CustomProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Filer filer; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">    filer = processingEnvironment.getFiler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">            .returns(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            .addParameter(String[].class, "args")</span><br><span class="line">            .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">            .addMethod(main)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        javaFile.writeTo(filer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SourceVersion.RELEASE_7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="kapt和transform的差别"><a href="#kapt和transform的差别" class="headerlink" title="kapt和transform的差别"></a>kapt和transform的差别</h4><p>AbstractProcessor只能处理注解，然后根据注解通过javapoet生成一个新的java类。而transfrom则是通过gradle插件的transfrom方法，对.class文件做的修改。</p><p>AbstractProcessor是一个抽象类，它的父类是Processer。Processor会在编译阶段初始化，然后对当前模块内的代码进行一次扫描，然后获取到对应的注解，之后调用process方法，然后我们根据这些注解类来做一些后续操作。</p><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>source(源代码) -&gt; processor（处理器） -&gt; generate （文件生成）-&gt; javacompiler -&gt; .class文件 -&gt; .dex(只针对安卓)。</p><p><em>官方链接：<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">https://github.com/square/javapoet</a></em></p>]]></content>
    
    <summary type="html">
    
      JavaPoet是Square推出的开源Java代码生成框架，提供Java Api生成.java源文件。
    
    </summary>
    
    
      <category term="框架" scheme="https://xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaPoet" scheme="https://xxsu.xyz/tags/JavaPoet/"/>
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://xxsu.xyz/article/71c610d3/"/>
    <id>https://xxsu.xyz/article/71c610d3/</id>
    <published>2020-09-05T07:46:00.000Z</published>
    <updated>2021-03-07T00:23:19.930Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表创建"><a href="#单链表创建" class="headerlink" title="单链表创建"></a>单链表创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">SingleNode</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(a[i]);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表逆序输出"><a href="#单链表逆序输出" class="headerlink" title="单链表逆序输出"></a>单链表逆序输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=f(head.next);</span><br><span class="line">    System.out.print(head.data + <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p>链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">f2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>||head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=f2(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">head=f2(head);</span><br></pre></td></tr></table></figure><h3 id="逆序输出并未反转"><a href="#逆序输出并未反转" class="headerlink" title="逆序输出并未反转"></a>逆序输出并未反转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=f(head.next);</span><br><span class="line">    System.out.print(head.data + <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">f(head);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      单链表使用
    
    </summary>
    
    
      <category term="算法" scheme="https://xxsu.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="单链表" scheme="https://xxsu.xyz/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>gradle命令</title>
    <link href="https://xxsu.xyz/article/dda7bba2/"/>
    <id>https://xxsu.xyz/article/dda7bba2/</id>
    <published>2020-08-15T07:46:00.000Z</published>
    <updated>2021-04-14T04:03:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="gradlew-命令详解"><a href="#gradlew-命令详解" class="headerlink" title="gradlew 命令详解"></a>gradlew 命令详解</h2><p>gradlew tasks –all：查看所有任务，包括缓存任务等；</p><p>gradlew clean：清除工程目录下的build文件夹；</p><p>gradlew build： 检查依赖并编译打包，debug、release环境的包都会打出来；</p><p>gradlew assemble：编译指定的包：如Debug包（gradlew assembleDebug）、Release包（gradlew assembleRelease）、渠道包（gradlew assembleOemRelease/assembleOemDebug）、定制的版本等等；</p><p>gradlew install：编译并安装指定的包。如Debug包（gradlew installDebug）、Release包（gradlew installOemRelease/installOemDebug）、定制的版本等等；</p><p>gradlew uninstall：卸载已安装的指定模式的包：如Debug包（gradlew uninstallDebug）、Release包（gradlew uninstallRelease）、渠道包（gradlew uninstallOemRelease/uninstallOemDebug）、定制的版本等等；</p><p>gradlew :模块名称:dependencies   ，如gradlew :app:dependencies，作用：查看包依赖关系；</p><p>gradlew build -i/–info -d/–debug -s/–stacktrace：编译并打印debug模式和info等级的日志及所用异常的堆栈信息(–stacktrace)；</p><p>gradlew clean build –refresh-dependencies：组合指令，清除构建并重新构建，同时强制刷新依赖(gradlew –refresh-dependencies)；</p><p>gradlew –offline：离线模式，即让Gradle只使用本地cache里的依赖，如果cache中没有也不会更新依赖，而是提示编译失败；</p><p>gradlew –refresh-dependencies：强制刷新依赖，即检查依赖是否有更新比如动态版本、SHA1进行本地cache和远程仓库散列码的对比等，有更新则下载更新进行构建；使用这种方式可以避免手动删除cache；–info：打印堆栈信息；</p><p>gradlew –daemon：守护进程，使用Gradle的守护进程构建，能够提高构建效率，如果守护进程没启动或现有的都处于忙碌状态，就启动一个守护进程；</p><p>守护进程和守护线程的区别：</p><ul><li>守护进程 :只会守护到主进程的代码结束</li><li>守护线程 :会守护所有其他非守护线程的结束</li></ul><p>gradlew –no-daemon：如果你已经配置为使用守护进程构建，可以使用该选项本次不用守护进程构建；</p><p>gradlew –continuous：连续构建，即任务队列中即使某个任务失败，不会终止执行，而是会继续执行下一个任务；<br>gradlew –parallel –parallel-threads=N：并行编译；</p><p>gradlew –configure-on-demand：按需编译；</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>implementation：gradle会将依赖项添加到编译类路径，并将依赖项打包到编译输出。且其他模块只有在运行时才能使用该依赖项。</p><p>api：gradle会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项。</p><p>compileOnly：gradle只会将依赖项添加到编译类路径，不会将其添加到编译输出。</p><p>runtimeOnly：gradle只会将依赖项添加到编译输出，以便在运行时使用。即，不会将其添加到编译类路径。</p><p>annotationProcessor：要添加对作为注解处理器的库的依赖关系，必须使用 annotationProcessor 配置将其添加到注解处理器类路径。 </p>]]></content>
    
    <summary type="html">
    
      gradlew命令、依赖配置
    
    </summary>
    
    
      <category term="技巧" scheme="https://xxsu.xyz/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="gradle" scheme="https://xxsu.xyz/tags/gradle/"/>
    
  </entry>
  
</feed>
