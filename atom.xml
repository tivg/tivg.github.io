<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueSky&#39;s Blog</title>
  
  
  <link href="https://blog.xxsu.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.xxsu.xyz/"/>
  <updated>2023-12-22T07:27:09.511Z</updated>
  <id>https://blog.xxsu.xyz/</id>
  
  <author>
    <name>Xiao Su</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hilt框架介绍</title>
    <link href="https://blog.xxsu.xyz/article/fd33f9e4/"/>
    <id>https://blog.xxsu.xyz/article/fd33f9e4/</id>
    <published>2023-12-19T06:58:00.000Z</published>
    <updated>2023-12-22T07:27:09.511Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><blockquote><p>Hilt是由Google推出的基于Dagger的依赖注入框架，它旨在简化Dagger在Android应用中的使用，并提供更多的便利性和易用性。</p><p>tips:先学习dagger再来看Hilt框架会简单很多。</p></blockquote><br/><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>简化配置和使用：Hilt通过简化Dagger的模板代码，提供了更简单的注入方式，减少了开发者需要编写的代码量。引入了一些默认的配置，使得在大多数情况下无需手动配置模块。</p><p>自动生成代码和更高的抽象层级：Hilt生成一些常见的依赖注入代码，减少了开发者需要手动编写的代码量。引入了一些高级抽象，例如@ViewModelInject注解，用于更方便地注入ViewModel。</p><p>组件化和测试：Hilt鼓励更模块化的设计，使得组件更易于测试和维护。通过更好地支持单元测试，使得测试更容易进行。</p><p>Android特定的优化和集成：Hilt提供了特定于Android的功能，比如支持Android组件的生命周期管理，与ViewModel的集成等。</p><br/><h3 id="Hilt和Dagger对比"><a href="#Hilt和Dagger对比" class="headerlink" title="Hilt和Dagger对比"></a>Hilt和Dagger对比</h3><table><thead><tr><th>简化点</th><th>Hilt</th><th>Dagger</th></tr></thead><tbody><tr><td>模板代码的减少</td><td>引入默认配置和标准化注解，减少模板代码量</td><td>需要手动编写较多的模板代码来配置依赖注入</td></tr><tr><td>Android组件的注入</td><td>使用@AndroidEntryPoint简化Android组件的依赖注入</td><td>需要手动配置每个Android组件的依赖注入</td></tr><tr><td>ViewModel的注入</td><td>使用@HiltViewModel和by viewModels()简化ViewModel注入</td><td>需要手动配置特定Provider来注入ViewModel</td></tr><tr><td>生命周期管理</td><td>自动处理Android组件的生命周期，简化依赖对象的管理</td><td>需要手动管理依赖对象的创建和销毁，处理生命周期可能较繁琐</td></tr><tr><td>默认绑定和作用域</td><td>提供默认的绑定和作用域配置，简化依赖注入的配置</td><td>需要手动配置绑定和作用域，可能容易出错或需要更多的手动设置</td></tr></tbody></table><br/><h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在项目级别的build.gradle文件中添加Hilt插件</span><br>classpath <span class="hljs-string">&#x27;com.google.dagger:hilt-android-gradle-plugin:版本号&#x27;</span><br><br><span class="hljs-comment">//在应用的build.gradle文件中</span><br><span class="hljs-comment">// 应用Hilt插件</span><br>apply plugin: <span class="hljs-string">&#x27;dagger.hilt.android.plugin&#x27;</span><br><br><span class="hljs-comment">// 添加Hilt依赖</span><br>implementation <span class="hljs-string">&#x27;com.google.dagger:hilt-android:版本号&#x27;</span><br>kapt <span class="hljs-string">&#x27;com.google.dagger:hilt-compiler:版本号&#x27;</span><br></code></pre></td></tr></table></figure><br/><h3 id="HiltAndroidApp注解"><a href="#HiltAndroidApp注解" class="headerlink" title="@HiltAndroidApp注解"></a>@HiltAndroidApp注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-title">extends</span> <span class="hljs-title">Application</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="AndroidEntryPoint注解"><a href="#AndroidEntryPoint注解" class="headerlink" title="@AndroidEntryPoint注解"></a>@AndroidEntryPoint注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> <span class="hljs-title">extends</span> <span class="hljs-title">AppCompatActivity</span> &#123;<br>  <br>    <span class="hljs-meta">@Inject</span><br>    SomeDependency someDependency;<br>  <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="HiltViewModel注解"><a href="#HiltViewModel注解" class="headerlink" title="@HiltViewModel注解"></a>@HiltViewModel注解</h3><p>@HiltViewModel 注解被添加到 ViewModel 类上，表示这是一个需要 Hilt 进行依赖注入的 ViewModel。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRepository</span> &#123;<br>    <span class="hljs-comment">// Repository 的具体实现</span><br>&#125;<br><br><span class="hljs-meta">@HiltViewModel</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> <span class="hljs-title">extends</span> <span class="hljs-title">ViewModel</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository repository;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">public</span> MyViewModel(MyRepository repository) &#123;<br>        <span class="hljs-keyword">this</span>.repository = repository;<br>    &#125;<br><br>    <span class="hljs-comment">// ViewModel 的逻辑方法</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Hilt在dagger的基础上专门对Android做了简化，让依赖注入框架使用起来更方便，毕竟dagger是java的依赖注入库。</p>]]></content>
    
    
    <summary type="html">Hilt框架介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg使用总结</title>
    <link href="https://blog.xxsu.xyz/article/4f6e9117/"/>
    <id>https://blog.xxsu.xyz/article/4f6e9117/</id>
    <published>2023-12-18T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.473Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="通用命令格式"><a href="#通用命令格式" class="headerlink" title="通用命令格式"></a>通用命令格式</h2><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">ffmpeg [全局参数] [输入文件参数] -i 输入文件地址 [输出文件参数] 输出文件地址<br></code></pre></td></tr></table></figure><br/><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>音视频格式转换：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 output.avi<br></code></pre></td></tr></table></figure><p>调整视频尺寸：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vf scale=640:480 output.mp4<br></code></pre></td></tr></table></figure><p>裁剪视频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -ss 00:00:10 -to 00:00:30 -c copy output.mp4<br></code></pre></td></tr></table></figure><p>提取音频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vn -acodec copy output.mp3<br></code></pre></td></tr></table></figure><p>合并视频和音频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac -strict experimental output.mp4<br></code></pre></td></tr></table></figure><p>添加水印：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -i watermark.png -filter_complex &quot;overlay=10:10&quot; output.mp4<br></code></pre></td></tr></table></figure><p>调整音量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp3 -af &quot;volume=1.5&quot; output.mp3<br></code></pre></td></tr></table></figure><p>提取视频帧：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vf &quot;select=&#x27;eq(n\,100)&#x27;&quot; -vsync vfr frame_%03d.png<br></code></pre></td></tr></table></figure><p>转gif：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">ffmpeg -i file.mov -r <span class="hljs-number">15</span> file.gif <span class="hljs-comment">//帧率15</span><br></code></pre></td></tr></table></figure><p>更多命令教程： https://wklchris.github.io/blog/FFmpeg/FFmpeg.html</p><br/><h2 id="常用模块库"><a href="#常用模块库" class="headerlink" title="常用模块库"></a>常用模块库</h2><p>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构。</p><p>libavcodec：用于各种类型音视频编解码</p><p>libavutil：包含一些公共的工具函数</p><p>libswscale：用于视频场景比例缩放、色彩映射转换等</p><p>libpostproc：用于后期效果处理等</p><p>libswresample：提供音频重采样功能，包括采样频率、声道格式等</p><p>libavfilter：用于滤波器处理，如音视频倍速、水平翻转、叠加文字等功能</p><p>libavdevice：包含输入输出设备的库，实现音视频数据的抓取或渲染</p><br/><p>命令行工具：</p><p>ffmpeg：编解码小工具，可用于格式转换、解码或电视卡即时编码等</p><p>ffserver：一个HTTP多媒体即时广播串流服务器</p><p>ffplay：一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示</p><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《FFmpeg入门详解–音视频原理及应用》</p>]]></content>
    
    
    <summary type="html">ffmpeg使用总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>apk签名介绍</title>
    <link href="https://blog.xxsu.xyz/article/e77709f1/"/>
    <id>https://blog.xxsu.xyz/article/e77709f1/</id>
    <published>2023-12-17T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.477Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="如何确保消息正确？"><a href="#如何确保消息正确？" class="headerlink" title="如何确保消息正确？"></a>如何确保消息正确？</h2><p>客户端利用 Hash 算法针对数据得出一个摘要，使用公钥加密，连同对称加密的数据一起发送过去，服务端收到消息后，先利用对称密钥对内容解密，再进行 Hash 计算得出摘要。使用私钥将摘要内容解密，和再次计算得出的摘要作对比，一致就代表消息无误。</p><h2 id="如何保证公钥的正确性？"><a href="#如何保证公钥的正确性？" class="headerlink" title="如何保证公钥的正确性？"></a>如何保证公钥的正确性？</h2><p>使用数字证书，包含的信息有：</p><p>主体信息：证书的主体是公钥的拥有者</p><p>公钥：证书中包含了公钥的信息，用于进行加密或数字签名验证</p><p>证书颁发者（CA）信息：证书颁发者是证书的签发机构</p><p>证书有效期：包括证书的起始日期和截止日期</p><p>数字签名：证书内容经过 CA 使用私钥进行数字签名，验证方可以使用 CA 的公钥对签名进行验证</p><p>证书序列号：唯一标识证书的序列号，用于区分不同的证书</p><p>扩展信息：包括一些额外的信息，如密钥用途、颁发者策略等</p><h2 id="ADB增量APK安装"><a href="#ADB增量APK安装" class="headerlink" title="ADB增量APK安装"></a>ADB增量APK安装</h2><p>生成差分文件》生成增量补丁》传输并应用增量补丁</p><p>可行性检测： adb install –incremental</p><p>增量安装时，adb 会要求 .apk.idsig 文件存在于 .apk 旁边（APK v4的签名文件.apk.idsig并不会打包进apk文件中）</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>https://blog.csdn.net/chzphoenix/article/details/130130934</p>]]></content>
    
    
    <summary type="html">apk签名介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>JWT认证介绍</title>
    <link href="https://blog.xxsu.xyz/article/881e5f30/"/>
    <id>https://blog.xxsu.xyz/article/881e5f30/</id>
    <published>2023-12-16T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.474Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="传统认证流程-Cookie-Session"><a href="#传统认证流程-Cookie-Session" class="headerlink" title="传统认证流程 Cookie + Session"></a>传统认证流程 Cookie + Session</h2><p>基本工作流程：</p><ol><li>用户登录：<ul><li>用户提供用户名和密码进行登录。</li><li>服务器验证用户提供的凭证，如果验证通过，则创建一个 Session。</li></ul></li><li>Session 创建：<ul><li>服务器为该用户创建一个唯一的 Session 对象，并将其标识符（Session ID）存储在服务器端。</li><li>同时，在响应中向用户的浏览器发送一个包含 Session ID 的 Cookie。</li></ul></li><li>Cookie 存储：<ul><li>浏览器收到服务器响应后，将包含 Session ID 的 Cookie 存储在本地。</li></ul></li><li>后续请求：<ul><li>用户在之后的每个请求中都会携带该 Cookie。</li><li>服务器收到请求时，从 Cookie 中提取 Session ID。</li><li>服务器使用提取的 Session ID 来识别用户的 Session，从而验证用户身份和状态。</li></ul></li><li>会话管理：<ul><li>服务器在 Session 中存储用户的状态信息，如登录状态、权限等。</li><li>每次请求都使用 Cookie 中的 Session ID 识别用户，并根据该 Session 获取或更新用户的状态信息。</li></ul></li><li>登出：<ul><li>当用户登出时，服务器会销毁相应的 Session，删除相关信息。</li><li>同时，服务器发送一个指示浏览器删除 Cookie 的响应，从而清除本地保存的 Session ID。</li></ul></li></ol><p>不足：如跨站点请求伪造（CSRF）攻击、服务器端需要存储会话信息等。</p><br/><h2 id="基于-Token-的认证方式"><a href="#基于-Token-的认证方式" class="headerlink" title="基于 Token 的认证方式"></a>基于 Token 的认证方式</h2><p>JWT（JSON Web Token）是一种用于安全传输信息的开放标准（RFC 7519），它通过一种紧凑且自包含的方式在各方之间安全地传递信息。JWT 主要由三部分组成，它们以点号分隔，形成一个字符串，具有如下结构：header.payload.signature</p><ul><li>Header（头部）：包含了关于生成的 Token 类型（JWT）和所使用的签名算法等元数据信息，通常以 JSON 格式表示。</li><li>Payload（载荷）：存放着 Token 的主体信息，如用户的身份信息、权限等数据，也是以 JSON 格式表示。Payload 可以包含一些预定义的声明（Registered Claims），例如过期时间（Expiration Time）等。</li><li>Signature（签名）：使用指定的算法对前面两部分的内容进行签名，确保 Token 没有被篡改。签名部分需要使用一个密钥进行加密，并与 Token 一起发送。</li></ul><p>工作流程：</p><ol><li>生成 Token：在服务端，根据用户提供的信息生成 JWT，包括指定的头部、载荷信息，并使用密钥生成签名部分。</li><li>传递 Token：将生成的 JWT 作为身份验证令牌发送给客户端（通常是通过 HTTP 头部传递），客户端通常将 Token 存储在本地。</li><li>验证和解析 Token：每次客户端发送请求时，都会携带 Token。服务端接收到请求后，解析 Token，验证签名，检查 Token 是否有效和完整。</li><li>处理有效 Token：如果 Token 有效并通过验证，服务端根据载荷中的信息，进行相应的操作，如用户认证、授权等。</li><li>Token 更新和续期：在 Token 过期之前，可以考虑更新 Token，续期用户的会话状态。</li></ol><p>JWT 的优势在于它的轻量、紧凑、自包含性和可扩展性，使得它成为在不同系统之间安全地传递信息的一种流行方式。</p><br/><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>JWT 默认是不加密，但也可以加密：JWT 默认不加密，但可以使用密钥进行签名，也可以选择加密整个令牌。签名是为了确保令牌的完整性和真实性。</li><li>不在 JWT 中存储敏感数据：JWT 可以包含信息，但不应存储敏感数据，特别是不应该在不加密的情况下存储敏感信息。</li><li>JWT 可用于信息交换和减少数据库查询：JWT 可以携带信息，允许客户端与服务器之间传递信息，避免了一些额外的数据库查询。</li><li>无法废止或修改有效期内的 Token：这是 JWT 的一个局限性。一旦签发，JWT 在到期之前都是有效的，服务器不能立即废止或修改其权限。需要额外的逻辑来处理失效的情况。</li><li>泄露可能导致权限被滥用：JWT 一旦泄露，持有者可以使用其中的信息进行认证。因此，建议设置较短的有效期，并对于重要的操作再次进行认证。</li><li>使用 HTTPS 传输 JWT：为了保证安全，不应该在 HTTP 下明文传输 JWT。使用 HTTPS 协议传输可以加密通信，确保令牌安全传输。</li></ol>]]></content>
    
    
    <summary type="html">JWT认证介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Clean架构介绍</title>
    <link href="https://blog.xxsu.xyz/article/857fda5c/"/>
    <id>https://blog.xxsu.xyz/article/857fda5c/</id>
    <published>2023-12-15T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.468Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>项目地址：</p><p>https://github.com/android10/Android-CleanArchitecture</p><p>https://github.com/android10/Android-CleanArchitecture-Kotlin</p><p>该架构主要用于分离业务逻辑和底层的实现，提高项目的可维护性、拓展性。</p><br/><p>Clean 架构是由软件工程师 Robert C. Martin（也被称为 Uncle Bob）提出的。他在他的书籍《Clean Architecture》中详细介绍了这种架构模式，旨在构建易于理解、灵活、可维护和可测试的软件系统。</p><br/><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ol><li>实体层： 包含应用程序的业务实体和核心业务逻辑，是整个架构的核心。这一层不依赖于任何其他层，它定义了应用程序的核心模型和规则。</li><li>用例层： 也称为交互器或业务逻辑层，负责应用程序的具体用例和业务规则。用例层依赖于实体层，但不依赖于任何特定的框架或技术。</li><li>接口适配器层： 这一层包含了外部框架和工具，如数据库、UI、Web 等。它负责将用例层的业务逻辑适配到外部工具，同时也负责将外部数据转换为用例层所需的格式。</li><li>框架与驱动器层： 包含与外部设备、框架或工具的代码，比如 UI、数据库等。这一层依赖于接口适配器层，但并不直接影响核心业务逻辑。</li></ol><br/><h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>Clean Architecture 强调依赖规则，通过依赖倒置原则和单一职责原则来减少各层之间的耦合度：</p><ul><li>依赖倒置原则： 高层模块不应该依赖于底层模块，而是应该依赖于抽象接口。即，抽象不应该依赖于具体实现，具体实现应该依赖于抽象。这一原则使得不同层次的组件之间的依赖更加灵活，易于替换和扩展。</li><li>单一职责原则： 每个模块、类或函数都应该只有一个单一的责任。在 Clean Architecture 中，每一层都有其明确的职责，遵循单一职责原则有助于代码的清晰度和可维护性。</li></ul><br/><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：可维护性高、测试性强、可扩展性、独立性、降低耦合；</p><p>缺点：复杂程度增加、过度设计风险、对小型项目增加不必要的开发成本。</p><br/><h2 id="与MVVM的区别"><a href="#与MVVM的区别" class="headerlink" title="与MVVM的区别"></a>与MVVM的区别</h2><ol><li>关注点不同： Clean Architecture 更侧重于整体应用程序的架构设计和分层，强调业务逻辑和依赖规则的组织；而 MVVM 更专注于界面和数据的绑定、视图模型的设计。</li><li>依赖关系不同： Clean Architecture 强调解耦合，通过分层和依赖规则来降低各部分之间的耦合度；而 MVVM 主要解决视图和业务逻辑的解耦合。</li><li>应用场景不同： Clean Architecture 适用于各种规模的项目，特别是需要长期维护和扩展的大型项目；MVVM 更适用于需要复杂、动态用户界面的应用程序，特别是基于 UI 数据绑定的框架（比如 Android 中的 Data Binding ）。</li></ol>]]></content>
    
    
    <summary type="html">Clean架构优缺点</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket介绍</title>
    <link href="https://blog.xxsu.xyz/article/a0966911/"/>
    <id>https://blog.xxsu.xyz/article/a0966911/</id>
    <published>2023-12-14T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.478Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="WebSocket介绍"><a href="#WebSocket介绍" class="headerlink" title="WebSocket介绍"></a>WebSocket介绍</h2><p>基于TCP协议，客户端和服务端保持长连接，使用帧（Frame）来封装和传输数据，采用事件驱动，使用加密的 WebSocket（wss:&#x2F;&#x2F;）连接，支持跨域通信，常用语聊天、实时协作等需要实时数据推送的场景。</p><br/><h2 id="Android中使用"><a href="#Android中使用" class="headerlink" title="Android中使用"></a>Android中使用</h2><p>借助 OkHttp 可以很轻易的实现 WebSocket，它的 OkHttpClient 中，提供了 newWebSocket() 方法，可以直接建立一个 WebSocket 连接并完成通信。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionWebSockt</span><span class="hljs-params">(hostName:<span class="hljs-type">String</span>,port:<span class="hljs-type">Int</span>)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> httpClient = OkHttpClient.Builder()<br>      .pingInterval(<span class="hljs-number">40</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 设置 PING 帧发送间隔</span><br>      .build()<br>  <span class="hljs-keyword">val</span> webSocketUrl = <span class="hljs-string">&quot;ws://<span class="hljs-subst">$&#123;hostName&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>&quot;</span><br>  <span class="hljs-keyword">val</span> request = Request.Builder()<br>      .url(webSocketUrl)<br>      .build()<br>  httpClient.newWebSocket(request, <span class="hljs-keyword">object</span>:WebSocketListener()&#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onOpen(webSocket, response)<br>      <span class="hljs-comment">// WebSocket 连接建立</span><br>      mWebSocket = webSocket<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, text: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onMessage(webSocket, text)<br>      <span class="hljs-comment">// 收到服务端发送来的 String 类型消息</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosing</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosing(webSocket, code, reason)<br>      <span class="hljs-comment">// 收到服务端发来的 CLOSE 帧消息，准备关闭连接</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosed</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosed(webSocket, code, reason)<br>      <span class="hljs-comment">// WebSocket 连接关闭</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, t: <span class="hljs-type">Throwable</span>, response: <span class="hljs-type">Response</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onFailure(webSocket, t, response)<br>      <span class="hljs-comment">// 出错了</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="MockWebSocket"><a href="#MockWebSocket" class="headerlink" title="MockWebSocket"></a>MockWebSocket</h2><p>有时候为了方便我们测试，OkHttp 还提供了扩展的 MockWebSocket 服务，来模拟服务端。</p><p>MockWebSocket 需要添加额外的 Gradle 引用，最好和 OkHttp 版本保持一致：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">api <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:3.9.1&#x27;</span><br>api <span class="hljs-string">&#x27;com.squareup.okhttp3:mockwebserver:3.9.1&#x27;</span><br></code></pre></td></tr></table></figure><p>MockWebServer 的使用也非常简单，只需要利用 MockWebSocket 类即可。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> mMockWebSocket: MockWebServer? = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockWebSocket</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (mMockWebSocket != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  mMockWebSocket = MockWebServer()<br>  mMockWebSocket?.enqueue(MockResponse().withWebSocketUpgrade(<span class="hljs-keyword">object</span> : WebSocketListener() &#123;<br>     <span class="hljs-comment">//...</span><br> &#125;))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WebSocket介绍</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="flutter" scheme="https://blog.xxsu.xyz/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>c++锁的使用总结</title>
    <link href="https://blog.xxsu.xyz/article/f80a2866/"/>
    <id>https://blog.xxsu.xyz/article/f80a2866/</id>
    <published>2023-12-13T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.480Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h2><p>可以传递参数： 参数是一个枚举值，可以是 std::defer_lock、std::adopt_lock。</p><p>使用 std::adopt_lock 时，std::unique_lock 对象会认为互斥量已经被锁定，因此它不会尝试再次锁定互斥量。而是直接将自己关联到已锁定的互斥量上，然后你可以在合适的地方使用这个 std::unique_lock 对象来解锁。</p><p>std::try_lock 允许一次性尝试锁定多个互斥量，如果无法成功锁定所有互斥量，则不会阻塞线程，并返回适当的结果。</p><p>std::once_flag 和 std::call_once：这些用于实现只执行一次的操作，保证在多线程环境中某个函数只会被执行一次。</p><br/><h2 id="std-shared-lock"><a href="#std-shared-lock" class="headerlink" title="std::shared_lock"></a>std::shared_lock</h2><p> 可以同时被多个线程持有，允许并发的共享访问。</p><p>pthread_rwlock_t 是 POSIX 线程库中提供的一种读写锁（Read-Write Lock）。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。 </p><br/><h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard 是一个轻量级的互斥锁封装，用于在代码块中自动锁定和解锁互斥量。它的锁定和解锁是在构造和析构函数中完成的，适用于需要在作用域内自动管理锁定的场景。 </p><br/><h2 id="std-scoped-lock"><a href="#std-scoped-lock" class="headerlink" title="std::scoped_lock"></a>std::scoped_lock</h2><p>是 C++11 引入的一个锁，用于同时锁定多个互斥量，实现死锁避免和提高代码可读性。与 std::lock 不同，std::scoped_lock 是在构造时锁定互斥量，在析构时解锁互斥量，从而确保在任何情况下都会正确释放锁。 </p><br/><h2 id="递归锁（std-recursive-mutex）"><a href="#递归锁（std-recursive-mutex）" class="headerlink" title="递归锁（std::recursive_mutex）"></a>递归锁（std::recursive_mutex）</h2><p>递归锁（std::recursive_mutex）允许同一个线程多次获取锁，这在某些递归调用的情况下非常有用。 </p><br/><h2 id="自旋锁（std-atomic-flag）"><a href="#自旋锁（std-atomic-flag）" class="headerlink" title="自旋锁（std::atomic_flag）"></a>自旋锁（std::atomic_flag）</h2><p>自旋锁不是标准库提供的，但是可以使用原子标志（std::atomic_flag）实现。它在尝试获得锁失败时，不会进入休眠状态，而是一直在一个循环中自旋等待锁被释放。适用于短时间内锁被占用的情况。</p><br/><h2 id="FIFO支持"><a href="#FIFO支持" class="headerlink" title="FIFO支持"></a>FIFO支持</h2><p>在 C++ 标准库中，std::mutex 和 std::unique_lock 是不支持 FIFO（先来先服务）策略的锁，因为它们的锁定顺序不受先后顺序的限制，而是由操作系统或编译器实现来决定。</p><p>C++17 引入了一种新的锁类型 std::shared_mutex，它在共享锁定时支持 FIFO 策略，这意味着等待共享锁的线程会按照它们请求锁的顺序依次获得锁。</p>]]></content>
    
    
    <summary type="html">c++锁的使用总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="c++" scheme="https://blog.xxsu.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>ViewDragHelper源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/bc17390a/"/>
    <id>https://blog.xxsu.xyz/article/bc17390a/</id>
    <published>2023-12-12T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.476Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="ViewDragHelper源码剖析"><a href="#ViewDragHelper源码剖析" class="headerlink" title="ViewDragHelper源码剖析"></a>ViewDragHelper源码剖析</h2><p>创建方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mHelper = ViewDragHelper.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewDragCallback</span>());<br></code></pre></td></tr></table></figure><p>消息拦截</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mEnable) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onInterceptTouchEvent(ev);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mHelper.shouldInterceptTouchEvent(ev);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>        ignored.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mEnable) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTouchEvent(event);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mHelper.processTouchEvent(event);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>        ignored.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="回调方法详解"><a href="#回调方法详解" class="headerlink" title="回调方法详解"></a>回调方法详解</h2><p>ViewDragHelper 是一个用于处理拖拽和滑动的辅助类，通常用于创建可拖拽的用户界面元素，比如实现拖拽移动或侧滑删除等功能。</p><br/><h3 id="onViewDragStateChanged-int-state"><a href="#onViewDragStateChanged-int-state" class="headerlink" title="onViewDragStateChanged(int state)"></a>onViewDragStateChanged(int state)</h3><p>当拖拽状态改变时调用，参数 state 表示当前的拖拽状态。</p><br/><h3 id="onViewPositionChanged-View-changedView-int-left-int-top-int-dx-int-dy"><a href="#onViewPositionChanged-View-changedView-int-left-int-top-int-dx-int-dy" class="headerlink" title="onViewPositionChanged(View changedView, int left, int top, int dx, int dy)"></a>onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</h3><p>当被拖拽的 View 的位置发生改变时调用，参数包括变化的 View、左上角的新位置坐标、水平和垂直方向上的位移。</p><br/><h3 id="onViewCaptured-View-capturedChild-int-activePointerId"><a href="#onViewCaptured-View-capturedChild-int-activePointerId" class="headerlink" title="onViewCaptured(View capturedChild, int activePointerId)"></a>onViewCaptured(View capturedChild, int activePointerId)</h3><p>当一个 View 被捕获时调用，参数为被捕获的 View 和触摸点的 ID。</p><br/><h3 id="onViewReleased-View-releasedChild-float-xvel-float-yvel"><a href="#onViewReleased-View-releasedChild-float-xvel-float-yvel" class="headerlink" title="onViewReleased(View releasedChild, float xvel, float yvel)"></a>onViewReleased(View releasedChild, float xvel, float yvel)</h3><p>当被捕获的 View 被释放时调用，参数包括被释放的 View 和释放时的水平和垂直速度。</p><br/><h3 id="onEdgeTouched-int-edgeFlags-int-pointerId"><a href="#onEdgeTouched-int-edgeFlags-int-pointerId" class="headerlink" title="onEdgeTouched(int edgeFlags, int pointerId)"></a>onEdgeTouched(int edgeFlags, int pointerId)</h3><p>当触摸到边缘时调用，参数包括边缘标志和触摸点的 ID。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the left edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_LEFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the right edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_RIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the top edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_TOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the bottom edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_BOTTOM</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><br/><h3 id="onEdgeLock-int-edgeFlags"><a href="#onEdgeLock-int-edgeFlags" class="headerlink" title="onEdgeLock(int edgeFlags)"></a>onEdgeLock(int edgeFlags)</h3><p>当边缘锁定时调用，返回一个布尔值表示是否锁定边缘。</p><p>如果锁定了，就不会调用onEdgeDragStarted函数。</p><br/><h3 id="onEdgeDragStarted-int-edgeFlags-int-pointerId"><a href="#onEdgeDragStarted-int-edgeFlags-int-pointerId" class="headerlink" title="onEdgeDragStarted(int edgeFlags, int pointerId)"></a>onEdgeDragStarted(int edgeFlags, int pointerId)</h3><p>当开始拖动边缘时调用，参数包括边缘标志和触摸点的 ID。</p><blockquote><p>需要注意的是，上面的3个回调函数默认都不会通知返回，需要我们额外调用mDragger.setEdgeTrackingEnabled（ViewDragHelper.EDGE_LEFT |ViewDragHelper.EDGE_TOP）来开启边缘捕捉功能。</p></blockquote><br/><h3 id="getOrderedChildIndex-int-index"><a href="#getOrderedChildIndex-int-index" class="headerlink" title="getOrderedChildIndex(int index)"></a>getOrderedChildIndex(int index)</h3><p>获取指定索引位置的子 View 的顺序。</p><br/><h3 id="getViewHorizontalDragRange-View-child"><a href="#getViewHorizontalDragRange-View-child" class="headerlink" title="getViewHorizontalDragRange(View child)"></a>getViewHorizontalDragRange(View child)</h3><p>返回水平方向上允许拖动的范围。</p><br/><h3 id="getViewVerticalDragRange-View-child"><a href="#getViewVerticalDragRange-View-child" class="headerlink" title="getViewVerticalDragRange(View child)"></a>getViewVerticalDragRange(View child)</h3><p>返回垂直方向上允许拖动的范围。</p><br/><h3 id="tryCaptureView-View-child-int-pointerId"><a href="#tryCaptureView-View-child-int-pointerId" class="headerlink" title="tryCaptureView(View child, int pointerId)"></a>tryCaptureView(View child, int pointerId)</h3><p>尝试捕获指定的 View，返回一个布尔值表示是否成功捕获。</p><p>View child：当前用户触摸的子控件的View对象。</p><p>pointerId：当前触摸此控件的手指所对应的pointerId。触摸过程中pointerId不变，但是其索引会改变。</p><p>return boolean：返回值，表示是否对这个View进行各种事件的捕捉。如果返回值为false，那么就表示不对这个View进行捕捉，在手指触摸到这个View及这个View发生变动时，ViewDragHelper.Callback中的回调函数不会有任何反馈。</p><br/><h3 id="clampViewPositionHorizontal-View-child-int-left-int-dx"><a href="#clampViewPositionHorizontal-View-child-int-left-int-dx" class="headerlink" title="clampViewPositionHorizontal(View child, int left, int dx)"></a>clampViewPositionHorizontal(View child, int left, int dx)</h3><p>在水平方向上限制 View 移动的位置。</p><p>View child：当前手指横向移动所在的子View。</p><p>int left：当前子View如果跟随手指移动，那么它即将移动到的位置的left坐标值就是这里的left。</p><p>int dx：手指横向移动的距离。</p><p>return int：返回子View的新left坐标值，系统会把该子View的left坐标移动到这个位置。在代码中如果return left，则是让View横向跟随手指移动。</p><br/><h3 id="clampViewPositionVertical-View-child-int-top-int-dy"><a href="#clampViewPositionVertical-View-child-int-top-int-dy" class="headerlink" title="clampViewPositionVertical(View child, int top, int dy)"></a>clampViewPositionVertical(View child, int top, int dy)</h3><p>在垂直方向上限制 View 移动的位置，和clampViewPositionHorizontal类似。</p><br/><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="captureChildView-View-childView-int-activePointerId"><a href="#captureChildView-View-childView-int-activePointerId" class="headerlink" title="captureChildView(View childView, int activePointerId)"></a>captureChildView(View childView, int activePointerId)</h3><p>绕过tryCaptureView，直接开启对指定View的捕捉功能。</p><p>View childView：要捕捉拖动动作的childView对象。</p><p>int activePointerId：激活当前childView进行捕捉操作的手指id。</p><p><strong>开启的捕捉功能，只会临时开启，当用户松手时，此次捕捉结束，回到初始状态。</strong></p><p><strong>通过captureChildView捕捉的childView，会根据手指的移动轨迹相对于自身的原始位置移动，而不会跑到手指下方来跟随手指移动。</strong></p>]]></content>
    
    
    <summary type="html">ViewDragHelper源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>编辑器--倒计时插件</title>
    <link href="https://blog.xxsu.xyz/article/eceecfb7/"/>
    <id>https://blog.xxsu.xyz/article/eceecfb7/</id>
    <published>2023-12-11T06:58:00.000Z</published>
    <updated>2023-12-22T11:48:51.635Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>平时写代码可能会忘记时间，于是乎就想着准备开发一个编辑器的倒计时插件，方便提醒自己。</p><br/><h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id(<span class="hljs-string">&quot;java&quot;</span>)<br>    id(<span class="hljs-string">&quot;idea&quot;</span>)<br>    id(<span class="hljs-string">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version <span class="hljs-string">&quot;1.7.10&quot;</span><br>    id(<span class="hljs-string">&quot;org.jetbrains.intellij&quot;</span>) version <span class="hljs-string">&quot;1.8.0&quot;</span><br>&#125;<br><br>group = <span class="hljs-string">&quot;com.xxsu&quot;</span><br>version = <span class="hljs-string">&quot;1.0&quot;</span><br><br>repositories &#123;<br>    google()<br>    mavenCentral()<br>    jcenter()<br>&#125;<br><br>dependencies &#123;<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;</span>)<br><span class="hljs-comment">//    implementation(&quot;com.github.adedayo.intellij.sdk:forms_rt:142.1&quot;)</span><br>    implementation(<span class="hljs-string">&quot;com.intellij:forms_rt:7.0.3&quot;</span>)<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Configure Gradle IntelliJ Plugin</span><br><span class="hljs-comment">// Read more: https://plugins.jetbrains.com/docs/intellij/tools-gradle-intellij-plugin.html</span><br>intellij &#123;<br>    version.set(<span class="hljs-string">&quot;2021.3.3&quot;</span>)<br>    type.set(<span class="hljs-string">&quot;IC&quot;</span>) <span class="hljs-comment">// Target IDE Platform  //IC指IDEA社区版(免费版本)，IU指旗舰版(收费版本)</span><br><br>    plugins.set(listOf(<span class="hljs-string">&quot;com.intellij.java&quot;</span>,<span class="hljs-string">&quot;android&quot;</span>))<br>&#125;<br><br>tasks &#123;<br>    <span class="hljs-comment">// Set the JVM compatibility versions</span><br>    withType&lt;JavaCompile&gt; &#123;<br>        sourceCompatibility = <span class="hljs-string">&quot;11&quot;</span><br>        targetCompatibility = <span class="hljs-string">&quot;11&quot;</span><br>    &#125;<br>    withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt; &#123;<br>        kotlinOptions.jvmTarget = <span class="hljs-string">&quot;11&quot;</span><br>    &#125;<br><br>    patchPluginXml &#123;<br><span class="hljs-comment">// 这里配置sinceBuild=213，表示插件只能被版本号大于等于2021.3版本的IDEA安装，低于这个版本的将抛无法兼容的错误</span><br>        sinceBuild.set(<span class="hljs-string">&quot;213&quot;</span>)<br>        untilBuild.set(<span class="hljs-string">&quot;223.*&quot;</span>)<br>    &#125;<br><br>    signPlugin &#123;<br>        certificateChain.set(System.getenv(<span class="hljs-string">&quot;CERTIFICATE_CHAIN&quot;</span>))<br>        privateKey.set(System.getenv(<span class="hljs-string">&quot;PRIVATE_KEY&quot;</span>))<br>        password.set(System.getenv(<span class="hljs-string">&quot;PRIVATE_KEY_PASSWORD&quot;</span>))<br>    &#125;<br><br>    publishPlugin &#123;<br>        token.set(System.getenv(<span class="hljs-string">&quot;PUBLISH_TOKEN&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h2><p>这里主要是插件的一些配置信息，也包括一些类的注册。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">applicationListeners</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        项目打开关闭监听--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;project_module.ProjectOpenCloseListener&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">topic</span>=<span class="hljs-string">&quot;com.intellij.openapi.project.ProjectManagerListener&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">applicationListeners</span>&gt;</span><br></code></pre></td></tr></table></figure><br/><h2 id="封装一个工具类来创建倒计时UI"><a href="#封装一个工具类来创建倒计时UI" class="headerlink" title="封装一个工具类来创建倒计时UI"></a>封装一个工具类来创建倒计时UI</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> time_module<br><br><span class="hljs-keyword">import</span> com.intellij.openapi.Disposable<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionGroup<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionPlaces<br><span class="hljs-keyword">import</span> com.intellij.openapi.application.ApplicationManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.project.Project<br><span class="hljs-keyword">import</span> com.intellij.openapi.util.Disposer<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.StatusBar<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.WindowManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.impl.status.widget.StatusBarWidgetsActionGroup<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.impl.status.widget.StatusBarWidgetsManager<br><span class="hljs-keyword">import</span> com.intellij.ui.awt.RelativePoint<br><span class="hljs-keyword">import</span> utils.MyPopupHandler<br><span class="hljs-keyword">import</span> utils.ToastUtils<br><span class="hljs-keyword">import</span> java.util.function.Function<br><span class="hljs-keyword">import</span> javax.swing.JComponent<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeHelper</span> : <span class="hljs-type">Disposable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> statusBar: StatusBar<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTimeStatusWidget</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>?)</span></span> &#123;<br>        project ?: <span class="hljs-keyword">return</span><br>        statusBar = WindowManager.getInstance().getStatusBar(project) ?: <span class="hljs-keyword">return</span><br>        statusBar.addWidget(TimeWidget(project), <span class="hljs-keyword">this</span>)<br><br>        <span class="hljs-keyword">val</span> group = Function &#123; am: ActionManager -&gt;<br>            <span class="hljs-keyword">val</span> action = am.getAction(StatusBarWidgetsActionGroup.GROUP_ID)<br>            <span class="hljs-keyword">if</span> (action <span class="hljs-keyword">is</span> ActionGroup) &#123;<br>                <span class="hljs-keyword">return</span><span class="hljs-symbol">@Function</span> action<br>            &#125;<br>            <span class="hljs-literal">null</span><br>        &#125;<br>        MyPopupHandler.installPopupMenu(statusBar <span class="hljs-keyword">as</span> JComponent, group, ActionPlaces.STATUS_BAR_PLACE, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br><br>        <span class="hljs-keyword">val</span> statusBarWidgetsManager: StatusBarWidgetsManager =<br>            project.getService(StatusBarWidgetsManager::<span class="hljs-keyword">class</span>.java) ?: <span class="hljs-keyword">return</span><br>        ApplicationManager.getApplication().invokeLater &#123; statusBarWidgetsManager.installPendingWidgets() &#125;<br>        Disposer.register(statusBar) &#123; statusBarWidgetsManager.disableAllWidgets() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRelativePoint</span><span class="hljs-params">()</span></span>:RelativePoint&#123;<br>        <span class="hljs-keyword">return</span> RelativePoint.getCenterOf(statusBar.component)<br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        Disposer.dispose(statusBar)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="弹框工具类"><a href="#弹框工具类" class="headerlink" title="弹框工具类"></a>弹框工具类</h2><p>用于消息提示</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyPopupHandler &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installPopupMenu</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        component: <span class="hljs-type">JComponent</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        group: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">ActionManager</span>, ActionGroup?&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        place: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        actionManager: <span class="hljs-type">ActionManager</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        menuListener: <span class="hljs-type">PopupMenuListener</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: PopupHandler &#123;<br>        <span class="hljs-keyword">if</span> (ApplicationManager.getApplication() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : PopupHandler() &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokePopup</span><span class="hljs-params">(comp: <span class="hljs-type">Component</span>?, x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> &#123;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">val</span> popupHandler: PopupHandler = <span class="hljs-keyword">object</span> : PopupHandler() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokePopup</span><span class="hljs-params">(comp: <span class="hljs-type">Component</span>?, x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">val</span> manager = actionManager ?: ActionManager.getInstance()<br>                <span class="hljs-keyword">val</span> actionGroup: ActionGroup = manager?.let &#123; group.apply(it) &#125; ?: <span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">val</span> popupMenu = manager.createActionPopupMenu(place, actionGroup)<br>                popupMenu.setTargetComponent(component)<br>                <span class="hljs-keyword">val</span> menu = popupMenu.component<br>                <span class="hljs-keyword">if</span> (menuListener != <span class="hljs-literal">null</span>) &#123;<br>                    menu.addPopupMenuListener(menuListener)<br>                &#125;<br>                menu.show(comp, x, y)<br>            &#125;<br>        &#125;<br>        component.addMouseListener(popupHandler)<br>        <span class="hljs-keyword">return</span> popupHandler<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="自定义UI组件"><a href="#自定义UI组件" class="headerlink" title="自定义UI组件"></a>自定义UI组件</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeWidget</span>(<span class="hljs-keyword">val</span> project: Project) : CustomStatusBarWidget, TextPresentation &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myLabel = JLabel(<span class="hljs-string">&quot;「00:00」&quot;</span>)<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">object</span> : ClickListener() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(e: <span class="hljs-type">MouseEvent</span>, clickCount: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>                <span class="hljs-keyword">val</span> myPopupMenu = JPopupMenu()<br>                myPopupMenu.add(<span class="hljs-keyword">object</span> : AbstractAction(<span class="hljs-string">&quot;设置倒计时&quot;</span>, IconsUtils.settingIcon) &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> &#123;<br>                        AppObserver.getInstance(project).openSettingDialog.increment()<br>                    &#125;<br>                &#125;)<br>                myPopupMenu.addSeparator()<br>                myPopupMenu.add(<span class="hljs-keyword">object</span> : AbstractAction(<span class="hljs-string">&quot;暂停/恢复&quot;</span>, getIconByStatus()) &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> &#123;<br>                        <span class="hljs-keyword">if</span> (CountDownHelper.getInstance(project).isPauseStatus()) &#123;<br>                            <span class="hljs-keyword">if</span> (!CountDownHelper.getInstance(project).resumeCountDown()) &#123;<br>                                ToastUtils.show(project, <span class="hljs-string">&quot;恢复失败,请重启开启~&quot;</span>)<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            CountDownHelper.getInstance(project).pauseCountDown()<br>                        &#125;<br>                        <span class="hljs-keyword">this</span>.putValue(SMALL_ICON, getIconByStatus())<br>                    &#125;<br>                &#125;)<br><br>                <span class="hljs-keyword">val</span> dimension: Dimension = myLabel.preferredSize<br>                <span class="hljs-keyword">val</span> at = Point(<span class="hljs-number">0</span>, -dimension.height)<br>                myPopupMenu.show(e.component, at.x - <span class="hljs-number">20</span>, at.y - <span class="hljs-number">20</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;.installOn(myLabel, <span class="hljs-literal">true</span>)<br><br>        AppObserver.getInstance(project).startCountDown.addObserver &#123;<br>            startCountDown()<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getIconByStatus</span><span class="hljs-params">()</span></span>: Icon &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (CountDownHelper.getInstance(project).isPauseStatus()) &#123;<br>            IconsUtils.stopIcon<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            IconsUtils.runningIcon<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startCountDown</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> totalMinutes = SpUtils.getIntValue(TimeConstants.SpKey.key_minutes) ?: <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (totalMinutes == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        CountDownHelper.getInstance(project).startCountDown(totalMinutes * <span class="hljs-number">60</span>, &#123;<br>            <span class="hljs-keyword">val</span> minutes = it / <span class="hljs-number">60</span><br>            <span class="hljs-keyword">val</span> seconds = it % <span class="hljs-number">60</span><br>            <span class="hljs-keyword">val</span> minutesStr = <span class="hljs-keyword">if</span> (minutes &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-string">&quot;0<span class="hljs-variable">$minutes</span>&quot;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minutes<br>            &#125;<br>            <span class="hljs-keyword">val</span> secondsStr = <span class="hljs-keyword">if</span> (seconds &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-string">&quot;0<span class="hljs-variable">$seconds</span>&quot;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                seconds<br>            &#125;<br>            myLabel.text = <span class="hljs-string">&quot;「<span class="hljs-variable">$minutesStr</span>:<span class="hljs-variable">$secondsStr</span>」&quot;</span><br>        &#125;, &#123;<br>            myLabel.text = <span class="hljs-string">&quot;「00:00」&quot;</span><br>            ToastUtils.show(<br>                project,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;SpUtils.getValue(TimeConstants.SpKey.key_minutes)&#125;</span>分钟的任务已结束，请check:\n &quot;</span><br>                        + SpUtils.getValue(TimeConstants.SpKey.key_task)<br>            )<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ID</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(statusBar: <span class="hljs-type">StatusBar</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getComponent</span><span class="hljs-params">()</span></span>: JComponent &#123;<br>        <span class="hljs-keyword">return</span> myLabel<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPresentation</span><span class="hljs-params">()</span></span>: WidgetPresentation &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTooltipText</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;点击进行更多设置&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getClickConsumer</span><span class="hljs-params">()</span></span>: Consumer&lt;MouseEvent&gt; &#123;<br>        <span class="hljs-keyword">return</span> Consumer &#123; _: MouseEvent? -&gt;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getText</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TimeWidget&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAlignment</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>        <span class="hljs-keyword">return</span> Component.CENTER_ALIGNMENT<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        CountDownHelper.getInstance(project).cancelCountDownTimer()<br>        AppObserver.getInstance(project).startCountDown.removeAllObservers()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是倒计时插件的主要代码，此外还有些小的工具类就不一一粘贴了。下面看下效果吧:)</p><br/><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/./../../images/skill-countdown/countdown.gif" alt="倒计时"></p>]]></content>
    
    
    <summary type="html">编辑器里用来倒计时的一个小插件</summary>
    
    
    
    <category term="插件" scheme="https://blog.xxsu.xyz/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="效率工具" scheme="https://blog.xxsu.xyz/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>dagger使用总结</title>
    <link href="https://blog.xxsu.xyz/article/e8d0b96f/"/>
    <id>https://blog.xxsu.xyz/article/e8d0b96f/</id>
    <published>2023-12-10T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.471Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>dagger可以在编译时生成代码，创建实例，进行注入，同时对类型进行安全检查。</p><br/><h2 id="常用注解介绍"><a href="#常用注解介绍" class="headerlink" title="常用注解介绍"></a>常用注解介绍</h2><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>标记一个接口或抽象类，用于连接依赖的提供者和需要依赖的消费者。通过@Component注解的接口可以生成一个Dagger组件，该组件负责创建和维护依赖项的实例。</p><br/><h3 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h3><p>标记一个类，用于提供依赖项的实例。@Module注解的类包含一个或多个带有@Provides注解的方法，这些方法返回依赖项的实例。</p><br/><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h3><p>标记一个依赖项，使其成为单例实例。当一个依赖项被标记为@Singleton时，Dagger会确保只有一个实例被创建和共享。</p><br/><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>用于创建自定义的限定符注解。限定符注解允许在具有相同类型的多个依赖项之间进行区分。</p><br/><h3 id="Provides使用"><a href="#Provides使用" class="headerlink" title="@Provides使用"></a>@Provides使用</h3><p>用于标记@Module注解的类中的方法，该方法返回依赖项的实例。Dagger使用这些方法来构建和提供依赖项的实例。</p><p>如果您使用 @Provides 修饰两个方法，两个方法都返回同一个接口的不同实现实例，那么在使用 @Inject 注解进行依赖注入时，您可以通过限定符（Qualifier）来区分不同的实例。</p><br/><p>首先，您需要定义一个限定符注解，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FirstImplementation &#123;<br>&#125;<br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecondImplementation &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，您可以在 @Provides 方法中使用这些限定符注解来标识不同的实现实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Provides</span><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-meta">@FirstImplementation</span><br><span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">provideFirstImplementationA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstImplementationA</span>();<br>&#125;<br><br><span class="hljs-meta">@Provides</span><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-meta">@SecondImplementation</span><br><span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">provideSecondImplementationA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondImplementationA</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在需要注入 InterfaceA 实例的地方，您可以使用相应的限定符注解进行注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-meta">@FirstImplementation</span><br>InterfaceA implementationA;<br></code></pre></td></tr></table></figure><p>这样，Dagger 将根据限定符注解来选择正确的实现实例进行注入。</p><p>请注意，限定符注解应确保在运行时保留（使用 @Retention(RetentionPolicy.RUNTIME) 注解），以便 Dagger 在运行时可以正确解析和匹配限定符注解。</p><br/><h3 id="Binds-使用场景"><a href="#Binds-使用场景" class="headerlink" title="@Binds  使用场景"></a>@Binds  使用场景</h3><p>接口绑定：当你有一个接口，并且想要将其绑定到一个具体的实现类时，可以使用@Binds注解。</p><p>@Binds方法必须是抽象的（abstract）且没有方法体，因为它只是用于建立接口和实现类之间的绑定关系。此外，@Binds方法必须位于抽象类或接口的模块中。</p><br/><h3 id="ContributesAndroidInjector"><a href="#ContributesAndroidInjector" class="headerlink" title="@ContributesAndroidInjector"></a>@ContributesAndroidInjector</h3><ul><li><p>Activity 和 Fragment：当想要在 Activity 或 Fragment 中进行依赖注入时，可以使用 @ContributesAndroidInjector 注解来帮助 Dagger 2 自动生成相应的子组件和注入器代码。</p></li><li><p>模块的子模块：当希望在一个 Dagger 模块中包含其他模块时，可以使用 @ContributesAndroidInjector 注解来简化子模块的配置。</p></li></ul><p>模块的子模块例子：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentModule</span> &#123;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = [ChildModule::class])</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contributeChildInjector</span><span class="hljs-params">()</span></span>: ChildActivity<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="IntoSet"><a href="#IntoSet" class="headerlink" title="@IntoSet"></a>@IntoSet</h3><p>用于将多个实例绑定到一个 Set 集合中。这对于在依赖注入时提供多个实例的情况很有用，例如在一个接口有多个实现类时，想要将它们统一管理。</p><br/><p>以下是一个简单的例子，展示如何使用 @IntoSet 将多个实例绑定到一个 Set 中：</p><p>假设有两个实现了 Logger 接口的类：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">// 实现文件日志记录</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">// 实现控制台日志输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 Dagger 的模块中使用 @IntoSet 注解将这两个实例添加到 Set 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerModule</span> &#123;<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    Logger <span class="hljs-title function_">provideFileLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLogger</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    Logger <span class="hljs-title function_">provideConsoleLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleLogger</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，当你在依赖注入的地方请求一个 Set<Logger> 时，Dagger 将自动收集这两个实例并提供给你：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br>Set&lt;Logger&gt; loggers; <span class="hljs-comment">// Dagger 将注入包含两个 Logger 实例的 Set</span><br><br><span class="hljs-comment">// 使用 loggers 集合中的实例进行日志记录等操作</span><br></code></pre></td></tr></table></figure><p>这样，你可以将多个实例统一管理，方便地进行依赖注入和使用。</p><br/><h3 id="IntoMap"><a href="#IntoMap" class="headerlink" title="@IntoMap"></a>@IntoMap</h3><p>用于将依赖注入的实例添加到一个 Map 集合中，在 Dagger 中使用它可以方便地将多个实例与特定的键关联起来。</p><p>以下是一个简单的例子，展示如何使用 @IntoMap 将多个实例添加到 Map 中：</p><p>假设有一个接口 Processor，有两个实现类 AddProcessor 和 SubtractProcessor，并且想要将它们关联到一个 Map&lt;String, Processor&gt; 中，其中键为操作类型（”add” 或 “subtract”）。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 Dagger 的模块中使用 @IntoMap 注解将这些实例添加到 Map 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessorModule</span> &#123;<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoMap</span><br>    <span class="hljs-meta">@StringKey(&quot;add&quot;)</span> <span class="hljs-comment">// 键为 &quot;add&quot;</span><br>    Processor <span class="hljs-title function_">provideAddProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddProcessor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoMap</span><br>    <span class="hljs-meta">@StringKey(&quot;subtract&quot;)</span> <span class="hljs-comment">// 键为 &quot;subtract&quot;</span><br>    Processor <span class="hljs-title function_">provideSubtractProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubtractProcessor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，当你在依赖注入的地方请求一个 Map&lt;String, Processor&gt; 时，Dagger 将自动收集这些实例并以特定的键关联起来：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br>Map&lt;String, Processor&gt; processorMap; <span class="hljs-comment">// Dagger 将注入包含键值对的 Map</span><br><br><span class="hljs-comment">// 使用 processorMap 中的实例进行对应操作的处理</span><br><span class="hljs-type">Processor</span> <span class="hljs-variable">addProcessor</span> <span class="hljs-operator">=</span> processorMap.get(<span class="hljs-string">&quot;add&quot;</span>);<br><span class="hljs-type">Processor</span> <span class="hljs-variable">subtractProcessor</span> <span class="hljs-operator">=</span> processorMap.get(<span class="hljs-string">&quot;subtract&quot;</span>);<br></code></pre></td></tr></table></figure><p>这样，你就可以使用键值对来管理和获取不同类型的实例，很方便地进行依赖注入和使用。</p><br/><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>可参考NextCloud开源项目</p><p>https://github.com/nextcloud/talk-android/tree/master</p><p>https://github.com/nextcloud/android</p>]]></content>
    
    
    <summary type="html">dagger使用总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="android" scheme="https://blog.xxsu.xyz/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>mockserver部署总结</title>
    <link href="https://blog.xxsu.xyz/article/20276bc2/"/>
    <id>https://blog.xxsu.xyz/article/20276bc2/</id>
    <published>2023-12-09T06:58:00.000Z</published>
    <updated>2023-12-22T11:51:28.923Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><p>官方网址：https://www.mock-server.com/</p><p>容器部署：https://www.mock-server.com/mock_server&#x2F;running_mock_server.html#docker_container</p><br/><h2 id="命令行添加期望"><a href="#命令行添加期望" class="headerlink" title="命令行添加期望"></a>命令行添加期望</h2><p>官方例子： https://github.com/mock-server/mockserver/blob/master/mockserver-examples/curl_examples.md</p><p>期望添加失败，可能是端口不正确导致；可以用docker ps查看端口；如下图所示，本地访问应该使用32768这个端口；</p><p><img src="/./skill-mockserver/image-20231222133537654.png" alt="image-20231222133537654"></p><p>例子：</p><p>1、实现简单的接口mock：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">curl -X PUT <span class="hljs-string">&#x27;localhost:1090/mockserver/expectation&#x27;</span> \<br>-d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;httpRequest&quot;: &#123;</span><br><span class="hljs-string">    &quot;method&quot;: &quot;GET&quot;,</span><br><span class="hljs-string">    &quot;path&quot;: &quot;/test&quot;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;httpResponse&quot;: &#123;</span><br><span class="hljs-string">    &quot;body&quot;: &quot;OK&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>2、使用自定义的类回调</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">curl -v -X PUT <span class="hljs-string">&quot;http://localhost:1080/mockserver/expectation&quot;</span> -d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    &quot;httpRequest&quot; : &#123;</span><br><span class="hljs-string">        &quot;path&quot; : &quot;/some.*&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;httpResponseClassCallback&quot; : &#123;</span><br><span class="hljs-string">        &quot;callbackClass&quot; : &quot;org.mockserver.examples.mockserver.CallbackActionExamples$TestExpectationResponseCallback&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&#x27;</span> <br></code></pre></td></tr></table></figure><br/><h2 id="代码实现动态返回"><a href="#代码实现动态返回" class="headerlink" title="代码实现动态返回"></a>代码实现动态返回</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">cd mockserver-examples<br>mvn clean <span class="hljs-keyword">package</span>    #打包成mockserver-examples-<span class="hljs-number">5.15</span><span class="hljs-number">.0</span>.jar<br>拷贝 mockserver-examples-<span class="hljs-number">5.15</span><span class="hljs-number">.0</span>.jar 到libs目录下<br><br>docker run --rm -d -p <span class="hljs-number">1080</span>:<span class="hljs-number">1080</span> -v $(pwd)/expectation.json:/tmp/mockserver/expectation.json -v $(pwd)/config:/config -v $(pwd)/libs:/libs -w /tmp/mockserver --name my-mock-server mockserver/mockserver -logLevel INFO -serverPort <span class="hljs-number">1080</span><br><br>请求 http:<span class="hljs-comment">//localhost:1080/mockserver/dashboard</span><br></code></pre></td></tr></table></figure><br/><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>docker run在run后面添加–rm 只要关闭就自动删除。</p><p>查看所有的期望的id：<br> ​curl -X GET http://localhost:1080/mockserver/expectations​​</p><p>删除对应期望id的配置，其他保留：<br> ​curl -X PUT “http://localhost:1080/mockserver/clear" -d '{    "id": "676a5f8a-8b9b-4b79-9a49-b535f54f9e20" }'​​</p><p>列出当前MockServer中的所有请求和期望：result.json  是当前命令的路径：<br> ​curl -X PUT http://localhost:1090/mockserver/retrieve > result.json​​</p><p>put操作失败可能是端口不正确。</p><br/><h2 id="踩坑："><a href="#踩坑：" class="headerlink" title="踩坑："></a>踩坑：</h2><p>config中的mockserver.properties的功能没有仔细参考官网给的例子（https://raw.githubusercontent.com/mock-server/mockserver/master/mockserver.example.properties），参数配置不齐全；重要是这几个参数，导致配置文件一直没有生效；</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">mockserver.persistExpectations=<span class="hljs-literal">true</span><br>mockserver.persistedExpectationsPath=/tmp/mockserver/expectation.json<br>mockserver.initializationJsonPath=/tmp/mockserver/expectation.json<br>mockserver.watchInitializationJson=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><br/><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MockServer 和 EasyMock 都是用于进行测试和模拟的工具，但它们在实现和使用方式上有一些区别。MockServer相对重量级，学习成本较高，如果只是简单的接口测试，那还是使用EasyMock方便些。</p>]]></content>
    
    
    <summary type="html">mockserver部署总结</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mockserver" scheme="https://blog.xxsu.xyz/tags/mockserver/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用总结</title>
    <link href="https://blog.xxsu.xyz/article/65761caa/"/>
    <id>https://blog.xxsu.xyz/article/65761caa/</id>
    <published>2023-12-08T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.483Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><blockquote><p>Docker 是一个开源的容器化平台，主要用于打包、发布和运行应用程序。它的作用在于提供了一种轻量级、可移植、自包含的环境，使应用程序能够在不同的环境中快速部署和运行。</p></blockquote><br/><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>以下是一些常用的 Docker 命令：</p><ol><li>镜像相关命令：<ul><li>docker images：列出本地所有镜像。</li><li>docker pull &lt;镜像名&gt;：拉取镜像。</li><li>docker rmi &lt;镜像ID&gt;：删除指定镜像。</li></ul></li><li>容器相关命令：<ul><li>docker ps：列出正在运行的容器。</li><li>docker ps -a：列出所有容器，包括已停止的。</li><li>docker inspect <container_name_or_id> 查看容器的详细信息。</li><li>docker run &lt;镜像名&gt;：运行一个容器。</li><li>docker start &lt;容器ID或名称&gt;：启动一个停止的容器。</li><li>docker stop &lt;容器ID或名称&gt;：停止一个运行中的容器。</li><li>docker rm &lt;容器ID或名称&gt;：删除一个容器。</li></ul></li><li>容器日志：<ul><li>docker logs &lt;容器ID或名称&gt;：查看容器日志。</li><li>docker logs -f &lt;容器ID或名称&gt;：实时查看容器日志。</li></ul></li><li>容器操作：<ul><li>docker exec -it &lt;容器ID或名称&gt; &lt;命令&gt;：在运行中的容器中执行命令。</li><li>docker cp &lt;本地路径&gt; &lt;容器ID或名称&gt;:&lt;容器内路径&gt;：将本地文件复制到容器中。</li></ul></li><li>网络相关命令：<ul><li>docker network ls：列出 Docker 网络。</li><li>docker network inspect &lt;网络名称&gt;：查看网络详细信息。</li></ul></li><li>其他命令：<ul><li>docker-compose up&#x2F;down：通过 Docker Compose 启动&#x2F;停止服务。</li><li>docker version：查看 Docker 版本信息。</li><li>docker info：查看 Docker 系统信息。</li></ul></li></ol><br/><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><p>在docker inspect输出结果中，查找 “IPAddress” 和 “HostPort” 字段，分别对应容器的 IP 地址和端口号。</p><p><strong>查看挂载的源文件</strong>： docker inspect my-container | grep Source</p><p><strong>修改容器的名称</strong>： docker rename &lt;容器ID或容器名&gt; &lt;新容器名&gt;   。需要注意的是，容器名不能包含特殊字符（如 &#x2F;、: 等）以及空格。</p><p>为正在运行的容器进行文件挂载：docker exec -it -v &#x2F;path&#x2F;to&#x2F;local&#x2F;file:&#x2F;path&#x2F;to&#x2F;container&#x2F;file CONTAINER COMMAND</p><p><strong>如何保证容器停止后重启内容数据保留？</strong></p><p>使用volume来创建Docker 卷，例如 docker volume create xx-data，并在启动时使用-v 将docker卷关联到本地。</p><br/><h2 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker Compose简介"></a>Docker Compose简介</h2><blockquote><p>Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。它允许您通过一个单独的配置文件来定义和管理多个容器，这些容器可以相互协作组成一个完整的应用程序。</p></blockquote><br/><h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><ol><li>创建一个 docker-compose.yml 文件：在项目目录中创建一个名为 docker-compose.yml 的配置文件。</li><li>定义服务：在 docker-compose.yml 文件中，可以定义每个服务的配置。每个服务通常对应一个容器，可以指定容器的镜像、端口映射、环境变量、数据卷等。</li><li>定义服务间的关系：如果应用程序由多个服务组成，可以在 docker-compose.yml 文件中定义它们之间的依赖关系和通信方式。这样 Docker Compose 就知道如何启动和连接这些服务。</li><li>启动应用程序：使用 docker-compose up 命令，Docker Compose 将根据配置文件创建和启动所有的服务。</li><li>停止应用程序：使用 docker-compose down 命令，Docker Compose 将停止并删除应用程序中的所有服务和相关容器。</li></ol>]]></content>
    
    
    <summary type="html">Docker使用总结</summary>
    
    
    
    <category term="容器" scheme="https://blog.xxsu.xyz/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="Docker" scheme="https://blog.xxsu.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Flutter FFI源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/96ba32cc/"/>
    <id>https://blog.xxsu.xyz/article/96ba32cc/</id>
    <published>2023-12-07T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.480Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="ffi调用原理"><a href="#ffi调用原理" class="headerlink" title="ffi调用原理"></a>ffi调用原理</h2><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> DynamicLibrary nativeAddLib = Platform.isAndroid<br>    ? DynamicLibrary.open(<span class="hljs-string">&#x27;libnative_add.so&#x27;</span>)<br>    : DynamicLibrary.process();<br></code></pre></td></tr></table></figure><p>由此可见，调用方法主要是先加载整个动态链接库，再进一步调用库中对应的方法。</p><p>好在Android studio有提供专门的ffi插件模板，可以自动创建ffi插件，统一对动态链接库进行包装，提供对flutter可以调用的方法。</p><br/><h2 id="ffi插件使用"><a href="#ffi插件使用" class="headerlink" title="ffi插件使用"></a>ffi插件使用</h2><h3 id="普通方法调用"><a href="#普通方法调用" class="headerlink" title="普通方法调用"></a>普通方法调用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sumPtr =<br>    _lookup&lt;ffi.NativeFunction&lt;ffi.IntPtr <span class="hljs-built_in">Function</span>(ffi.IntPtr, ffi.IntPtr)&gt;&gt;(<br>        <span class="hljs-string">&#x27;sum&#x27;</span>);<br><span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sum = _sumPtr.asFunction&lt;<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br></code></pre></td></tr></table></figure><br/><h3 id="异步方法调用"><a href="#异步方法调用" class="headerlink" title="异步方法调用"></a>异步方法调用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">int</span>&gt; sumAsync(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> SendPort helperIsolateSendPort = <span class="hljs-keyword">await</span> _helperIsolateSendPort;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> requestId = _nextSumRequestId++;<br>  <span class="hljs-keyword">final</span> _SumRequest request = _SumRequest(requestId, a, b);<br>  <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">int</span>&gt; completer = Completer&lt;<span class="hljs-built_in">int</span>&gt;();<br>  _sumRequests[requestId] = completer;<br>  helperIsolateSendPort.send(request);<br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;<br></code></pre></td></tr></table></figure><p>开启一个helperIsolate，拿到helperIsolateSendPort，之后可以复用该SendPort。</p><p>_helperIsolateSendPort 是一个在定义时立即执行的异步函数表达式（immediately invoked asynchronous function expression，IIFE），它会在定义时执行一次，然后将结果赋给 _helperIsolateSendPort 变量。代码中巧妙使用了completer，结合final Map&lt;int, Completerint&gt;&gt; _sumRequests &#x3D; &lt;int,Completer<int>&gt;{};实现了请求数据和completer的一一对应。</p><p>源码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">The SendPort belonging to the helper isolate.</span></span><br>Future&lt;SendPort&gt; _helperIsolateSendPort = () <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">// The helper isolate is going to send us back a SendPort, which we want to</span><br>  <span class="hljs-comment">// wait for.</span><br>  <span class="hljs-keyword">final</span> Completer&lt;SendPort&gt; completer = Completer&lt;SendPort&gt;();<br><br>  <span class="hljs-comment">// Receive port on the main isolate to receive messages from the helper.</span><br>  <span class="hljs-comment">// We receive two types of messages:</span><br>  <span class="hljs-comment">// 1. A port to send messages on.</span><br>  <span class="hljs-comment">// 2. Responses to requests we sent.</span><br>  <span class="hljs-keyword">final</span> ReceivePort receivePort = ReceivePort()<br>    ..listen((<span class="hljs-built_in">dynamic</span> data) &#123;<br>      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> SendPort) &#123;<br>        <span class="hljs-comment">// The helper isolate sent us the port on which we can sent it requests.</span><br>        completer.complete(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> _SumResponse) &#123;<br>        <span class="hljs-comment">// The helper isolate sent us a response to a request we sent.</span><br>        <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">int</span>&gt; completer = _sumRequests[data.id]!;<br>        _sumRequests.remove(data.id);<br>        completer.complete(data.result);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">&#x27;Unsupported message type: <span class="hljs-subst">$&#123;data.runtimeType&#125;</span>&#x27;</span>);<br>    &#125;);<br><br>  <span class="hljs-comment">// Start the helper isolate.</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn((SendPort sendPort) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> ReceivePort helperReceivePort = ReceivePort()<br>      ..listen((<span class="hljs-built_in">dynamic</span> data) &#123;<br>        <span class="hljs-comment">// On the helper isolate listen to requests and respond to them.</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> _SumRequest) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> result = _bindings.sum_long_running(data.a, data.b);<br>          <span class="hljs-keyword">final</span> _SumResponse response = _SumResponse(data.id, result);<br>          sendPort.send(response);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">&#x27;Unsupported message type: <span class="hljs-subst">$&#123;data.runtimeType&#125;</span>&#x27;</span>);<br>      &#125;);<br><br>    <span class="hljs-comment">// Send the port to the main isolate on which we can receive requests.</span><br>    sendPort.send(helperReceivePort.sendPort);<br>  &#125;, receivePort.sendPort);<br><br>  <span class="hljs-comment">// Wait until the helper isolate has sent us back the SendPort on which we</span><br>  <span class="hljs-comment">// can start sending requests.</span><br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;();<br></code></pre></td></tr></table></figure><br/><h3 id="ffigen插件"><a href="#ffigen插件" class="headerlink" title="ffigen插件"></a>ffigen插件</h3><p>dart在调用c方法时，是不可以直接通过方法名调用的，需要像jni那样包装下。而ffigen插件主要的功能就是提供自动包装转化功能。</p><p>如下所示，将c的_sum方法转为dart的_sum方法，之后便可以直接调用了。</p><p>插件官网： https://pub.dev/packages/ffigen</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ffi&#x27;</span> <span class="hljs-keyword">as</span> ffi;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeLibrary</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> ffi.Pointer&lt;T&gt; <span class="hljs-built_in">Function</span>&lt;T <span class="hljs-keyword">extends</span> ffi.NativeType&gt;(<span class="hljs-built_in">String</span> symbolName)<br>      _lookup;<br>  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)<br>      : _lookup = dynamicLibrary.lookup;<br>  NativeLibrary.fromLookup(<br>      ffi.Pointer&lt;T&gt; <span class="hljs-built_in">Function</span>&lt;T <span class="hljs-keyword">extends</span> ffi.NativeType&gt;(<span class="hljs-built_in">String</span> symbolName)<br>          lookup)<br>      : _lookup = lookup;<br><br>  <span class="hljs-built_in">int</span> sum(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> _sum(a, b);<br>  &#125;<br><br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sumPtr = _lookup&lt;ffi.NativeFunction&lt;ffi.Int <span class="hljs-built_in">Function</span>(ffi.Int, ffi.Int)&gt;&gt;(<span class="hljs-string">&#x27;sum&#x27;</span>);<br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sum = _sumPtr.asFunction&lt;<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="是否可以调用c-方法呢？"><a href="#是否可以调用c-方法呢？" class="headerlink" title="是否可以调用c++方法呢？"></a>是否可以调用c++方法呢？</h3><p>直接调用是不支持的，不过可以通过c间接调用。方式和JNI类似，需要使用extern “C”包裹C++方法的实现，然后打包成动态链接库，通过DynamicLibrary.open进行加载。</p><p>官方文档：https://flutter.cn/docs/development/platform-integration/android/c-interop</p>]]></content>
    
    
    <summary type="html">FlutterFFI源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Flutter" scheme="https://blog.xxsu.xyz/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>c++ xlog源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/5ee48928/"/>
    <id>https://blog.xxsu.xyz/article/5ee48928/</id>
    <published>2023-12-06T06:58:00.000Z</published>
    <updated>2023-12-22T06:48:22.475Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><br/><h2 id="库简介"><a href="#库简介" class="headerlink" title="库简介"></a>库简介</h2><p>xlog属于mars项目的一个小组件，主要解决线上程序崩溃后日志消失的问题。崩溃日志往往在内存中，程序crash后，无法记录内存中的日志，导致无法捕获到对应关键的crash日志信息。该库主要采用mmap的方法进行日志系统设计，主要功能包含压缩、加密、写入文件等。</p><p>源码地址：https://github.com/Tencent/mars/tree/49c4bcf49fd8a80bfc8e1efaabdc71202542f4d3/mars/xlog</p><br/><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>开辟一块内存，对文件进行映射，日志到来时通通写入到该内存中，当内存内容达到阈值时，开始将内存中的内容上锁，另一个线程开始工作，将该内存中的日志信息写入到硬盘文件中。这里的内存也叫高速缓冲区，避免了频繁地对文件写操作。</p><br/><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为啥会映射一小块，等到小块满了之后再挨个读取写入到文件中，而不是一开始就对整个文件进行映射呢？或者采用滑动窗口方式，先映射一小块，满了再往后滑动窗口，实现文件分块映射呢？</p><p>看源码发现项目中主要使用的是boost的方法来做内存映射。</p><p>boost库中的文件映射源码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Path&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mapped_file::open</span><span class="hljs-params">(<span class="hljs-type">const</span> basic_mapped_file_params&lt;Path&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123; delegate_.<span class="hljs-built_in">open_impl</span>(p); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Path&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mapped_file::open</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Path&amp; path, mapmode flags, </span></span><br><span class="hljs-params"><span class="hljs-function">    size_type length, stream_offset offset )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">param_type <span class="hljs-title">p</span><span class="hljs-params">(path)</span></span>;<br>    p.flags = flags;<br>    p.length = length;<br>    p.offset = offset;<br>    <span class="hljs-built_in">open</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码来看似乎是可行的，xlog主要是使用第一个open方法进行映射文件，那第二个方法呢？这里我做了个小实验，使用第二个open方法进行文件映射，遗憾的是结果并不成功，会报错。内部是不支持，无论是更改窗口大小或者更改偏移量offset，都是会映射失败的，有感兴趣的朋友可以尝试下。</p>]]></content>
    
    
    <summary type="html">日志库xlog源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="C++" scheme="https://blog.xxsu.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>FlutterBoost源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/a56a3a15/"/>
    <id>https://blog.xxsu.xyz/article/a56a3a15/</id>
    <published>2023-12-04T06:58:00.000Z</published>
    <updated>2023-12-22T05:26:41.859Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>FlutterBoost 的理念是使用 Flutter 就像使用 WebView 一样简单。FlutterBoost 会为您处理页面分辨率。唯一需要关心的是页面的名称（通常可以是 URL）。</p></blockquote><p>官方源码： https://github.com/alibaba/flutter_boost</p><br/><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ul><li>Flutter SDK升级不需要Boost升级</li><li>简化架构</li><li>简化界面</li><li>双端接口统一设计</li><li>解决了首要问题</li><li>Android不需要区分AndroidX和Support</li></ul><br/><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="FlutterApplication初始化"><a href="#FlutterApplication初始化" class="headerlink" title="FlutterApplication初始化"></a>FlutterApplication初始化</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 1. initialize default engine</span><br><span class="hljs-comment">// 2. set delegate</span><br><span class="hljs-comment">// 3. register ActivityLifecycleCallbacks</span><br></code></pre></td></tr></table></figure><p>声明周期监听，前后台变化isBackForegroundEventOverridden参数控制，只要没有复写前后台方法，那么默认原生的前后台变化和flutter同步，同时解决对外提供的currentActivity方法。</p><p>预加载操作：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (!engine.getDartExecutor().isExecutingDart()) &#123;<br>    <span class="hljs-comment">// Pre-warm the cached FlutterEngine.</span><br>    engine.getNavigationChannel().setInitialRoute(options.initialRoute());<br>    engine.getDartExecutor().executeDartEntrypoint(<span class="hljs-keyword">new</span> DartExecutor.DartEntrypoint(<br>            FlutterMain.findAppBundlePath(), options.dartEntrypoint()), options.dartEntrypointArgs());<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="flutterview构造"><a href="#flutterview构造" class="headerlink" title="flutterview构造"></a>flutterview构造</h3><p>flutterboost在构造flutterview时传入一个surfaceview或者textureview，为啥会传入这两个呢，而不是view？主要的原因还是flutter页面的会有大量的图形渲染的操作，需要一个支持硬件加速的view的来显示。</p><p>将surface进行传入：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Start rendering on the previous surface.</span><br><span class="hljs-comment">// This surface is typically `FlutterSurfaceView` or `FlutterTextureView`.</span><br>renderSurface.attachToRenderer(renderer);<br></code></pre></td></tr></table></figure><p>下面是flutterview的创建过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><br>View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(</span><br><span class="hljs-params">    LayoutInflater inflater,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> ViewGroup container,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> flutterViewId,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> shouldDelayFirstAndroidViewDraw)</span> &#123;<br>  Log.v(TAG, <span class="hljs-string">&quot;Creating FlutterView.&quot;</span>);<br>  ensureAlive();<br><br>  <span class="hljs-keyword">if</span> (host.getRenderMode() == RenderMode.surface) &#123;<br>    <span class="hljs-type">FlutterSurfaceView</span> <span class="hljs-variable">flutterSurfaceView</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterSurfaceView</span>(<br>            host.getContext(), host.getTransparencyMode() == TransparencyMode.transparent);<br><br>    <span class="hljs-comment">// Allow our host to customize FlutterSurfaceView, if desired.</span><br>    host.onFlutterSurfaceViewCreated(flutterSurfaceView);<br><br>    <span class="hljs-comment">// Create the FlutterView that owns the FlutterSurfaceView.</span><br>    flutterView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterView</span>(host.getContext(), flutterSurfaceView);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">FlutterTextureView</span> <span class="hljs-variable">flutterTextureView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterTextureView</span>(host.getContext());<br><br>    flutterTextureView.setOpaque(host.getTransparencyMode() == TransparencyMode.opaque);<br><br>    <span class="hljs-comment">// Allow our host to customize FlutterSurfaceView, if desired.</span><br>    host.onFlutterTextureViewCreated(flutterTextureView);<br><br>    <span class="hljs-comment">// Create the FlutterView that owns the FlutterTextureView.</span><br>    flutterView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterView</span>(host.getContext(), flutterTextureView);<br>  &#125;<br><br>  <span class="hljs-comment">// Add listener to be notified when Flutter renders its first frame.</span><br>  flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener);<br><br>  Log.v(TAG, <span class="hljs-string">&quot;Attaching FlutterEngine to FlutterView.&quot;</span>);<br>  flutterView.attachToFlutterEngine(flutterEngine);<br>  flutterView.setId(flutterViewId);<br><br>  <span class="hljs-type">SplashScreen</span> <span class="hljs-variable">splashScreen</span> <span class="hljs-operator">=</span> host.provideSplashScreen();<br><br>  <span class="hljs-keyword">if</span> (splashScreen != <span class="hljs-literal">null</span>) &#123;<br>    Log.w(<br>        TAG,<br>        <span class="hljs-string">&quot;A splash screen was provided to Flutter, but this is deprecated. See&quot;</span><br>            + <span class="hljs-string">&quot; flutter.dev/go/android-splash-migration for migration steps.&quot;</span>);<br>    <span class="hljs-type">FlutterSplashView</span> <span class="hljs-variable">flutterSplashView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterSplashView</span>(host.getContext());<br>    flutterSplashView.setId(ViewUtils.generateViewId(FLUTTER_SPLASH_VIEW_FALLBACK_ID));<br>    flutterSplashView.displayFlutterViewWithSplash(flutterView, splashScreen);<br><br>    <span class="hljs-keyword">return</span> flutterSplashView;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (shouldDelayFirstAndroidViewDraw) &#123;<br>    delayFirstAndroidViewDraw(flutterView);<br>  &#125;<br>  <span class="hljs-keyword">return</span> flutterView;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="Pigeon插件使用"><a href="#Pigeon插件使用" class="headerlink" title="Pigeon插件使用"></a>Pigeon插件使用</h3><p>通过查看flutterBoost源码可以发现，内部flutter和原生通信的主要借助了一个名叫Pigeon的代码生成器工具。Pigeon是一个flutter插件，主要有以下优点：</p><ul><li>自动生成通信代码：根据开发者定义的数据结构和方法生成相应的Dart和原生平台的通信代码，简化了跨平台通信的实现过程。</li><li>定义消息传递格式： 开发者可以使用Pigeon定义数据结构和方法，包括参数和返回值的类型、方法的名称等，以便在Flutter和原生代码之间进行消息传递。</li><li>支持异步通信：能够处理异步方法调用，允许Flutter与原生代码之间进行异步操作。</li><li>增强了类型安全性： 通过Pigeon生成的代码，可以提供类型安全性，避免在不同平台之间传递数据时的类型错误。</li></ul><p>@HostApi()&#x2F;&#x2F; 用于Flutter调用原生的方法，原生方法实现</p><p>@FlutterApi()&#x2F;&#x2F; 用于原生调用Flutter的方法，Flutter方法实现</p><p>最终自动生成的接口方法等可参考Messages类。</p><blockquote><p>思考：如何自动生成代码的呢？</p><p>build_runner和source_gen</p></blockquote><br/><h3 id="自定义的FlutterBoostPlugin插件"><a href="#自定义的FlutterBoostPlugin插件" class="headerlink" title="自定义的FlutterBoostPlugin插件"></a>自定义的FlutterBoostPlugin插件</h3><p>为何会有flutter插件，主要是允许开发者在 Flutter 应用中集成原生代码或第三方库，调用 flutterEngine.getPlugins() 方法可以获得当前 Flutter 引擎中加载的所有插件的列表。</p><p>插件注册多数情况下是在原生端完成，利用原生平台的特定功能和能力，极少数是在flutter端注册的。</p><p>来看看FlutterBoostPlugin插件的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlutterBoostPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlutterPlugin</span>, NativeRouterApi, ActivityAware &#123;<br></code></pre></td></tr></table></figure><p>NativeRouterApi：主要是原生导航相关的接口方法，用于在flutter端调用；</p><p>ActivityAware：用于在 Flutter 插件中获取和管理 Android Activity 的接口，在Activity 生命周期中接收回调。</p><p>功能作用：</p><p>用于在 Flutter 和原生 Android（或 iOS）之间建立桥接，提供了一种在原生应用中嵌入 Flutter 页面的机制。它的主要功能包括：页面路由管理、混合开发支持、生命周期管理、跨平台支持等。</p><br/><h3 id="FlutterViewContainer"><a href="#FlutterViewContainer" class="headerlink" title="FlutterViewContainer"></a>FlutterViewContainer</h3><p>实现类主要有：FlutterBoostActivity、FlutterBoostFragment、FlutterBoostView；</p><p>其中FlutterBoostView继承于LifecycleView、而LifecycleView继承于FrameLayout；</p><p>ViewContainer的显示过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onContainerAppeared</span><span class="hljs-params">(FlutterViewContainer container, Runnable onPushRouteComplete)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uniqueId</span> <span class="hljs-operator">=</span> container.getUniqueId();<br>    <span class="hljs-keyword">if</span> (isDebugLoggingEnabled()) Log.d(TAG, <span class="hljs-string">&quot;#onContainerAppeared: &quot;</span> + uniqueId + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">this</span>);<br>    FlutterContainerManager.instance().activateContainer(uniqueId, container);<br>    pushRoute(uniqueId, container.getUrl(), container.getUrlParams(), reply -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (FlutterContainerManager.instance().isTopContainer(uniqueId)) &#123;<br>            <span class="hljs-keyword">if</span> (onPushRouteComplete != <span class="hljs-literal">null</span>) &#123;<br>                onPushRouteComplete.run();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//onContainerDisappeared并非异步触发，为了匹配对应，onContainerShow也不做异步</span><br>    onContainerShow(uniqueId);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="BoostInterceptor使用"><a href="#BoostInterceptor使用" class="headerlink" title="BoostInterceptor使用"></a>BoostInterceptor使用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;T&gt; pushWithInterceptor&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>      <span class="hljs-built_in">String?</span> name, <span class="hljs-built_in">bool</span> isFromHost, <span class="hljs-built_in">bool</span> isFlutterPage,<br>      &#123;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;? arguments,<br>      <span class="hljs-built_in">String?</span> uniqueId,<br>      <span class="hljs-built_in">bool?</span> withContainer,<br>      <span class="hljs-built_in">bool</span> opaque = <span class="hljs-keyword">true</span>&#125;) &#123;<br>    Logger.log(<span class="hljs-string">&#x27;pushWithInterceptor, uniqueId=<span class="hljs-subst">$uniqueId</span>, name=<span class="hljs-subst">$name</span>&#x27;</span>);<br>    <span class="hljs-keyword">var</span> pushOption = BoostInterceptorOption(name,<br>        uniqueId: uniqueId,<br>        isFromHost: isFromHost,<br>        arguments: arguments ?? &lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&#123;&#125;);<br>    InterceptorState&lt;BoostInterceptorOption&gt;? state =<br>        InterceptorState&lt;BoostInterceptorOption&gt;(pushOption);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> interceptor <span class="hljs-keyword">in</span> interceptors) &#123;<br>      <span class="hljs-keyword">final</span> pushHandler = PushInterceptorHandler();<br>      interceptor.onPrePush(state!.data, pushHandler);<br><br>      <span class="hljs-comment">// user resolve or do nothing</span><br>      <span class="hljs-keyword">if</span> (pushHandler.state?.type != InterceptorResultType.next) &#123;<br>        Logger.log(<span class="hljs-string">&#x27;The page was intercepted by user. name:<span class="hljs-subst">$name</span>, &#x27;</span><br>            <span class="hljs-string">&#x27;isFromHost=<span class="hljs-subst">$isFromHost</span>, isFlutterPage=<span class="hljs-subst">$isFlutterPage</span>&#x27;</span>);<br>        <span class="hljs-keyword">return</span> Future&lt;T&gt;.value(state.data <span class="hljs-keyword">as</span> T);<br>      &#125;<br>      state = pushHandler.state <span class="hljs-keyword">as</span> InterceptorState&lt;BoostInterceptorOption&gt;?;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (state?.type == InterceptorResultType.next) &#123;<br>      pushOption = state!.data;<br>      <span class="hljs-keyword">if</span> (isFromHost) &#123;<br>        pushContainer(name,<br>            uniqueId: pushOption.uniqueId,<br>            isFromHost: isFromHost,<br>            arguments: pushOption.arguments);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFlutterPage) &#123;<br>          <span class="hljs-keyword">return</span> pushWithResult(pushOption.name,<br>              uniqueId: pushOption.uniqueId,<br>              arguments: pushOption.arguments,<br>              withContainer: withContainer!,<br>              opaque: opaque);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">final</span> params = CommonParams()<br>            ..pageName = pushOption.name<br>            ..arguments = pushOption.arguments;<br>          nativeRouterApi.pushNativeRoute(params);<br>          <span class="hljs-keyword">return</span> pendNativeResult(pushOption.name);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Future&lt;T&gt;.value();<br>  &#125;<br></code></pre></td></tr></table></figure><br/><h3 id="BoostFlutterBinding"><a href="#BoostFlutterBinding" class="headerlink" title="BoostFlutterBinding"></a>BoostFlutterBinding</h3><p>主要作用：接管flutter的生命周期。</p><p>BoostFlutterBinding对WidgetsFlutterBinding进行了扩展，复写了initInstances和handleAppLifecycleStateChanged这两个方法。</p><p>思考：BoostFlutterBinding是如何拦截到生命周期进行处理的呢？</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>  ...<br>  CustomFlutterBinding();<br>  ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFlutterBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WidgetsFlutterBinding</span></span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">BoostFlutterBinding</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>从官方给的demo看必须要new一个FlutterBinding实例才可以，其实原理和WidgetsFlutterBinding的ensureInitialized()方法类似。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> WidgetsBinding ensureInitialized() &#123;<br>  <span class="hljs-keyword">if</span> (WidgetsBinding._instance == <span class="hljs-keyword">null</span>) &#123;<br>    WidgetsFlutterBinding();<br>  &#125;<br>  <span class="hljs-keyword">return</span> WidgetsBinding.instance;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BoostContainer使用"><a href="#BoostContainer使用" class="headerlink" title="BoostContainer使用"></a>BoostContainer使用</h3><br/><h3 id="如何理解BoostContainerWidget"><a href="#如何理解BoostContainerWidget" class="headerlink" title="如何理解BoostContainerWidget"></a>如何理解BoostContainerWidget</h3><p>持有container，小组件所属的container；</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">The Widget build for a [BoostContainer]</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">It overrides the &quot;==&quot; and &quot;hashCode&quot;,</span></span><br><span class="hljs-comment">/// <span class="language-markdown">to avoid rebuilding when its parent element call element.updateChild</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoostContainerWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  BoostContainerWidget(&#123;LocalKey? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.container&#125;)<br>      : <span class="hljs-keyword">super</span>(key: container.key);<br><br>  <span class="hljs-comment">/// <span class="language-markdown">The container this widget belong</span></span><br>  <span class="hljs-keyword">final</span> BoostContainer container;<br></code></pre></td></tr></table></figure><p>BoostContainerWidget外面包裹的是OverlayEntry，源码如下，该OverlayEntry是不透明，且状态保留的，可以进行复用。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerOverlayEntry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OverlayEntry</span> </span>&#123;<br>  ContainerOverlayEntry(BoostContainer container)<br>      : containerUniqueId = container.pageInfo.uniqueId,<br>        <span class="hljs-keyword">super</span>(<br>            builder: (ctx) =&gt; BoostContainerWidget(container: container),<br>            opaque: <span class="hljs-keyword">true</span>,<br>            maintainState: <span class="hljs-keyword">true</span>);<br><br>  <span class="hljs-comment">/// <span class="language-markdown">This overlay&#x27;s id, which is the same as the it&#x27;s related container</span></span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String?</span> containerUniqueId;<br></code></pre></td></tr></table></figure><br/><h3 id="flutter页面核心部分"><a href="#flutter页面核心部分" class="headerlink" title="flutter页面核心部分"></a>flutter页面核心部分</h3><p>页面的父widget是一个Overlay组件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">      child: Listener(<br>          onPointerDown: _handlePointerDown,<br>          onPointerUp: _handlePointerUpOrCancel,<br>          onPointerCancel: _handlePointerUpOrCancel,<br>          child: Overlay(<br>            key: overlayKey,<br>            initialEntries: <span class="hljs-keyword">const</span> &lt;OverlayEntry&gt;[],<br>          ))));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双层路由栈"><a href="#双层路由栈" class="headerlink" title="双层路由栈"></a>双层路由栈</h3><br/><h2 id="路由导航–NavigatorExt"><a href="#路由导航–NavigatorExt" class="headerlink" title="路由导航–NavigatorExt"></a>路由导航–NavigatorExt</h2><p>这个类让用户调用“Navigator.pop()”等于BoostNavigator.instance.pop()</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Future&lt;T?&gt; pushNamed&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<span class="hljs-built_in">String</span> routeName,<br>    &#123;<span class="hljs-built_in">Object?</span> arguments&#125;) &#123;<br>...<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> pop&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;([T? result]) &#123;<br>  <span class="hljs-comment">// Taking over container page</span><br>  <span class="hljs-keyword">if</span> (!canPop()) &#123;<br>    BoostNavigator.instance.pop(result ?? &#123;&#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">super</span>.pop(result);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的源码看出，只是把pop方法复写了，为啥可以实现等价调用呢？是在什么时候调用到BoostNavigator.instance.pop()的呢？</p><p>继续，进入Navigator.of(context)方法查看，可以发现它会调用findAncestorStateOfType来查找，从父节点找最近的State，实现如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> NavigatorState of(<br> BuildContext context, &#123;<br> <span class="hljs-built_in">bool</span> rootNavigator = <span class="hljs-keyword">false</span><br>&#125;) &#123;<br>...<br>navigator = navigator ?? context.findAncestorStateOfType&lt;NavigatorState&gt;();<br></code></pre></td></tr></table></figure><br/><h3 id="BoostContainerState"><a href="#BoostContainerState" class="headerlink" title="BoostContainerState"></a>BoostContainerState</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Widget build(BuildContext context) &#123;<br>  <span class="hljs-keyword">return</span> HeroControllerScope(<br>      controller: HeroController(),<br>      child: NavigatorExt(<br>        key: container._navKey,<br>        pages: <span class="hljs-built_in">List</span>&lt;Page&lt;<span class="hljs-built_in">dynamic</span>&gt;&gt;.of(container.pages),<br>        onPopPage: (route, result) &#123;<br>          <span class="hljs-keyword">if</span> (route.didPop(result)) &#123;<br>            <span class="hljs-keyword">assert</span>(route.settings <span class="hljs-keyword">is</span> BoostPage);<br>            _updatePagesList(route.settings <span class="hljs-keyword">as</span> BoostPage, result);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;,<br>        observers: &lt;NavigatorObserver&gt;[<br>          BoostNavigatorObserver(),<br>        ],<br>      ));<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>flutterboost核心使用单引擎处理flutter，原生页面跳转flutter页面，用到了一个flutteractivity类。</li><li>flutterfragment主要是在fragment中集成flutter，flutteractivity则是在activity中展示完整的flutter页面，而flutterfragmentactivity则是在activity页面中展示部分flutter页面。</li><li>package io.flutter.embedding.android：主要是放一些Android中展示flutter相关的一些工具类或者接口等。例如要在原生页面中展示一个flutterview，则需要把自定义的类写到这个包中；</li><li>flutterview的构造需要一个surfaceview或者textureview来显示flutter内容，为啥一定需要这么两个中的一个，因为他们都支持硬件加速，flutterview会涉及到大量的图像渲染内容，且是在原生中显示，则需要一个view来承接内容。</li><li>flutterboost主要是通过Pigeon插件来实现原生交互，flutter端的页面均继承于OverlayEntry，插件有自定义Navigator，用于对原来的Navigator.pop等方法进行补充。在原生页面中打开flutter页面，本质上是启动一个Activity来承载显示flutter的view，如果是跳转不同的flutter页面，可以通过url来定位，并且flutter端有自定义的拦截器，可以对跳转等操作进行拦截处理。</li></ol>]]></content>
    
    
    <summary type="html">FlutterBoost源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Flutter" scheme="https://blog.xxsu.xyz/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>FlutterRedux源码剖析</title>
    <link href="https://blog.xxsu.xyz/article/fa044df7/"/>
    <id>https://blog.xxsu.xyz/article/fa044df7/</id>
    <published>2023-12-03T06:28:00.000Z</published>
    <updated>2023-12-22T07:37:15.989Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>当前最新版：flutter_redux: ^0.10.0</p><p>源码：https://github.com/brianegan/flutter_redux&#x2F;blob&#x2F;master&#x2F;lib&#x2F;flutter_redux.dart</p><h2 id="flutter-redux原理"><a href="#flutter-redux原理" class="headerlink" title="flutter_redux原理"></a>flutter_redux原理</h2><p>flutter_redux 是一个 Flutter 库，它提供了将 Redux 状态管理模式与 Flutter 框架无缝集成的能力。它的原理主要基于以下几个要素：</p><ol><li>Redux 架构: Redux 是一种用于管理应用状态的设计模式，它将应用的状态存储在单一的不可变对象中，通过使用纯函数来修改状态。核心概念包括 Store（存储应用状态的容器）、Action（描述状态变化的动作）、Reducer（处理状态变化的纯函数）和 Middleware（处理额外操作的扩展）。</li><li>Store 的集成: flutter_redux 将 Redux 中的 Store 与 Flutter 的 InheritedWidget 有机地结合在一起。它通过 StoreProvider 将 Redux 的 Store 提供给整个 Flutter Widget 树。</li><li>数据流管理: 当应用状态发生变化时，Redux 的 Store 会调用注册的 Reducer 函数，生成新的状态。flutter_redux 利用 StoreConnector 将特定部件与 Store 关联起来，以便在状态变化时更新相关部件。</li><li>StoreConnector: 这个 Widget 允许 Flutter 组件订阅 Store 中的特定状态，并在状态发生变化时重新构建自身。通过传递 converter 函数，StoreConnector 可以将全局状态中的一部分映射到当前部件所需的局部状态。</li><li>Dispatch 动作: 通过 Store 的 dispatch 方法，可以派发 Action 到 Reducer，从而触发状态的变化。StoreConnector 可以使用 Store 的 dispatch 方法来发送 Action。</li></ol><br/><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="StoreProvider类"><a href="#StoreProvider类" class="headerlink" title="StoreProvider类"></a>StoreProvider类</h3><p>继承于InheritedWidget，StoreProvider 在 Flutter Redux 中扮演着将 Redux store 与 Flutter Widget 树连接起来的重要角色，使得状态管理变得更加简洁高效。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;<span class="hljs-built_in">bool</span> listen = <span class="hljs-keyword">true</span>&#125;) &#123;<br>  <span class="hljs-keyword">final</span> provider = (listen<br>      ? context.dependOnInheritedWidgetOfExactType&lt;StoreProvider&lt;S&gt;&gt;()<br>      : context<br>          .getElementForInheritedWidgetOfExactType&lt;StoreProvider&lt;S&gt;&gt;()<br>          ?.widget) <span class="hljs-keyword">as</span> StoreProvider&lt;S&gt;?;<br><br>  <span class="hljs-keyword">if</span> (provider == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> StoreProviderError&lt;StoreProvider&lt;S&gt;&gt;();<br><br>  <span class="hljs-keyword">return</span> provider._store;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="dependOnInheritedWidgetOfExactType"><a href="#dependOnInheritedWidgetOfExactType" class="headerlink" title="dependOnInheritedWidgetOfExactType"></a>dependOnInheritedWidgetOfExactType</h3><p>该方法用于在Widget树上获取离当前widget最近的一个父级InheritFromWidget，原因是在初始化完成后，Widget树中的InheritFromWidget也可能会发生变化，所以正确的做法应该在build（）方法或didChangeDependencies()中调用它。</p><br/><h3 id="getElementForInheritedWidgetOfExactType"><a href="#getElementForInheritedWidgetOfExactType" class="headerlink" title="getElementForInheritedWidgetOfExactType"></a>getElementForInheritedWidgetOfExactType</h3><p>返回最近的 Widget 元素：根据传入的泛型类型 T，寻找在当前 Widget 树中最近的对应 InheritedWidget 子类的元素，如果找不到，则返回 null。</p><p>不建立依赖关系：与 dependOnInheritedWidgetOfExactType 不同，该方法获取元素但不建立依赖关系。</p><p>不应在 State.dispose 中调用：因为在 dispose 阶段，元素树已经不稳定。如果需要在 dispose 阶段引用祖先元素，应该在 State.didChangeDependencies 中调用 dependOnInheritedWidgetOfExactType 来保存对祖先的引用。但在 State.deactivate 中调用是安全的，因为这个方法在部件从树中移除时被调用。</p><br/><h3 id="StoreConnector类"><a href="#StoreConnector类" class="headerlink" title="StoreConnector类"></a>StoreConnector类</h3><p>StoreConnector 是 flutter_redux 库中的一个关键部件，用于根据 Redux 的 Store 状态构建部件，继承于StatelessWidget。其主要功能和作用如下：</p><ul><li>根据 Store 状态构建部件: StoreConnector 根据 Redux 中的 Store 状态来构建 Flutter 组件，这允许你根据应用状态动态地构建 UI。</li><li>使用 converter 函数转换状态: 在执行 builder 之前，converter 函数会将 Store 转换成更特定的 ViewModel。这有助于将全局状态映射为当前部件所需的局部状态。</li><li>依赖 ViewModel 更新重建部件: 每当 Store 发生变化时，StoreConnector 会根据 ViewModel 的变化重新构建部件。为了正确执行此功能，你需要为 ViewModel 实现 &#x3D;&#x3D; 和 hashCode 方法，并在创建 StoreConnector 时设置 distinct 选项为 true。这样可以确保只有当 ViewModel 发生实际变化时，部件才会被重建，提高性能并避免不必要的重建。</li></ul><p>总之，StoreConnector 充当了连接 Redux 的 Store 和 Flutter 部件的桥梁，通过 converter 将全局状态转换为局部状态，并利用 ViewModel 变化来优化部件的重建。这样可以实现有效的状态管理和动态 UI 构建。</p><br/><h3 id="Store类"><a href="#Store类" class="headerlink" title="Store类"></a>Store<state>类</h3><p>它在 flutter_redux 库中扮演着存储和管理应用状态的角色。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>&lt;<span class="hljs-title">State</span>&gt; </span>&#123;<br>  Reducer&lt;State&gt; reducer;<br>  <span class="hljs-keyword">final</span> StreamController&lt;State&gt; _changeController;<br>  <span class="hljs-keyword">late</span> State _state;<br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;NextDispatcher&gt; _dispatchers;<br></code></pre></td></tr></table></figure><br/><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Store(<br>  <span class="hljs-keyword">this</span>.reducer, &#123;<br>  <span class="hljs-keyword">required</span> State initialState,<br>  <span class="hljs-built_in">List</span>&lt;Middleware&lt;State&gt;&gt; middleware = <span class="hljs-keyword">const</span> [],<br>  <span class="hljs-built_in">bool</span> syncStream = <span class="hljs-keyword">false</span>,<br>  <span class="hljs-built_in">bool</span> distinct = <span class="hljs-keyword">false</span>,<br>&#125;) : _changeController = StreamController.broadcast(<span class="hljs-keyword">sync</span>: syncStream) &#123;<br>  _state = initialState;<br>  _dispatchers = _createDispatchers(<br>    middleware,<br>    _createReduceAndNotify(distinct),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的distinct如果设置为 true，如果从 [reducer] 返回的新状态 响应操作等于之前的状态，则 Store 将不会发出 onChange 事件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">NextDispatcher _createReduceAndNotify(<span class="hljs-built_in">bool</span> distinct) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dynamic</span> action) &#123;<br>    <span class="hljs-keyword">final</span> state = reducer(_state, action);<br><br>    <span class="hljs-keyword">if</span> (distinct &amp;&amp; state == _state) <span class="hljs-keyword">return</span>;<br><br>    _state = state;<br>    _changeController.add(state);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="Dispatchers创建"><a href="#Dispatchers创建" class="headerlink" title="Dispatchers创建"></a>Dispatchers创建</h3><p>形成一个拦截链对action处理</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span>&lt;NextDispatcher&gt; _createDispatchers(<br>  <span class="hljs-built_in">List</span>&lt;Middleware&lt;State&gt;&gt; middleware,<br>  NextDispatcher reduceAndNotify,<br>) &#123;<br>  <span class="hljs-keyword">final</span> dispatchers = &lt;NextDispatcher&gt;[]..add(reduceAndNotify);<br><br>  <span class="hljs-comment">// Convert each [Middleware] into a [NextDispatcher]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> nextMiddleware <span class="hljs-keyword">in</span> middleware.reversed) &#123;<br>    <span class="hljs-keyword">final</span> next = dispatchers.last;<br><br>    dispatchers.add(<br>      (<span class="hljs-built_in">dynamic</span> action) =&gt; nextMiddleware(<span class="hljs-keyword">this</span>, action, next),<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dispatchers.reversed.toList();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">dynamic</span> dispatch(<span class="hljs-built_in">dynamic</span> action) &#123;<br>  <span class="hljs-keyword">return</span> _dispatchers[<span class="hljs-number">0</span>](action);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用dispatch方法，_dispatchers中的头一个处理器进行处理，根据action得到新的state值，根据distinct判断是否去重，拿到新的state值后添加到_changeController中，_changeController.add(state);</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _createStream() &#123;<br>  _stream = widget.store.onChange<br>      .where(_ignoreChange)<br>      .map((_) =&gt; widget.converter(widget.store))<br>      .transform(StreamTransformer.fromHandlers(<br>        handleError: _handleConverterError,<br>      ))<br>      <span class="hljs-comment">// Don&#x27;t use `Stream.distinct` because it cannot capture the initial</span><br>      <span class="hljs-comment">// ViewModel produced by the `converter`.</span><br>      .where(_whereDistinct)<br>      <span class="hljs-comment">// After each ViewModel is emitted from the Stream, we update the</span><br>      <span class="hljs-comment">// latestValue. Important: This must be done after all other optional</span><br>      <span class="hljs-comment">// transformations, such as ignoreChange.</span><br>      .transform(StreamTransformer.fromHandlers(<br>        handleData: _handleChange,<br>      ))<br>      <span class="hljs-comment">// Handle any errors from converter/onWillChange/onDidChange</span><br>      .transform(StreamTransformer.fromHandlers(<br>        handleError: _handleError,<br>      ));<br>&#125;<br></code></pre></td></tr></table></figure><p>如上源码所示，得到新的state后就会通知到onChange进行处理。这里有个_whereDistinct方法，</p><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> _whereDistinct(ViewModel vm) &#123;<br>  <span class="hljs-keyword">if</span> (widget.distinct) &#123;<br>    <span class="hljs-keyword">return</span> vm != _latestValue;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里的distinct主要用来判断生成后的viewmodel的是否一致，区别于Stream.distinct。</p>]]></content>
    
    
    <summary type="html">FlutterRedux源码剖析</summary>
    
    
    
    <category term="框架" scheme="https://blog.xxsu.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Flutter" scheme="https://blog.xxsu.xyz/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>碎片</title>
    <link href="https://blog.xxsu.xyz/article/88d274c3/"/>
    <id>https://blog.xxsu.xyz/article/88d274c3/</id>
    <published>2021-09-25T07:46:00.000Z</published>
    <updated>2021-10-19T01:37:37.501Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h2><p>错误日志：</p><p>Could not inflate Behavior subclass FloatingActionButton</p><p>解决方案：FloatingActionButton的layout_behavior使用完整路径，不要使用相对路径；</p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>setPriority在Thread.start()之前</p><h2 id="merge失败"><a href="#merge失败" class="headerlink" title="merge失败"></a>merge失败</h2><p>如下所示，重复写了，导致merge资源失败，并没有报出具体错误位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br></code></pre></td></tr></table></figure><h2 id="所有命令失效"><a href="#所有命令失效" class="headerlink" title="所有命令失效"></a>所有命令失效</h2><p>export PATH&#x3D;”&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;X11&#x2F;bin”</p>]]></content>
    
    
    <summary type="html">快速提高命令输入效率</summary>
    
    
    
    <category term="技巧" scheme="https://blog.xxsu.xyz/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="bat命令" scheme="https://blog.xxsu.xyz/tags/bat%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>字节码插桩</title>
    <link href="https://blog.xxsu.xyz/article/cad98d1c/"/>
    <id>https://blog.xxsu.xyz/article/cad98d1c/</id>
    <published>2021-09-12T07:46:00.000Z</published>
    <updated>2021-10-19T01:37:37.513Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ASM简介"><a href="#ASM简介" class="headerlink" title="ASM简介"></a>ASM简介</h2><p>ASM提供了两种API来生成和转换已编译类:</p><ul><li>核心API，以基于事件形式来表示类；</li><li>树API，以基于对象形式来表示类;</li></ul><p>应用场景：ButterKnife，Dagger、无痕埋点，性能监控等</p><h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p>基于事件的API把类看作是一系列事件来表示，每一个类的事件表示一个类的元素。类似解析XML的SAX。</p><p>基于对象的API将类表示成一棵对象树，每个对象表示类的一部分。类似解析XML的DOM</p><ul><li>事件API内存占用少于对象API，因为事件API不需要在内存中创建和存储对象树</li><li>事件API实现难度比对象API大，因为事件API在任意时刻类中只有一个元素可使用，但是对象API能获得整个类。</li></ul><h2 id="字节代码指令"><a href="#字节代码指令" class="headerlink" title="字节代码指令"></a>字节代码指令</h2><p>字节代码指令由一个标识该指令的操作码和固定数目的参数组成:</p><ul><li>操作码是一个无符号字节值——即字节代码名，由助记符号标识</li><li>参数是静态值，确定了精确的指令行为，在操作码之后给出</li></ul><p><strong>ILOAD</strong>, <strong>LLOAD</strong>, <strong>FLOAD</strong>, <strong>DLOAD</strong> 和 <strong>ALOAD</strong> 指令读取一个局部变量，并将它的值压到操作数栈中。</p><p>它们的参数是必须读取的局部变量的索引 <em>i</em>。</p><p><strong>ILOAD</strong> 用于加载一个 <strong>boolean</strong>、<strong>byte</strong>、 <strong>char</strong>、<strong>short</strong> 或 <strong>int</strong> 局部变量。</p><p><strong>LLOAD</strong>、<strong>FLOAD</strong> 和 <strong>DLOAD</strong> 分别用于加载 <strong>long</strong>、<strong>float</strong> 或 <strong>double</strong> 值。(<strong>LLOAD</strong> 和 <strong>DLOAD</strong> 实际加载两个槽 <em>i</em> 和 <em>i</em>+1)。</p><p>最后，<strong>ALOAD</strong> 用于加载任意非基元值，即对 象和数组引用。</p><p>与之对应，<strong>ISTORE</strong>、<strong>LSTORE</strong>、<strong>FSTORE</strong>、<strong>DSTORE</strong> 和 <strong>ASTORE</strong> 指令从操作数栈 中弹出一个值，并将它存储在由其索引 i 指定的局部变量中。</p><p><strong>POP</strong>弹出栈顶部的值</p><p><strong>DUP</strong>压入顶部栈值的一个副本</p><p><strong>SWAP</strong>弹出两个值，并按逆序压入它们</p><p><strong>ACONST</strong>_<strong>NULL</strong>压入<strong>null</strong> </p><p><strong>ICONST</strong><em><strong>0</strong>压入 <strong>int</strong> 值 0</em></p><p><strong>FCONST</strong>_<strong>0</strong> 压入 <strong>0f</strong></p><p><strong>DCONST_0</strong> 压入 <strong>0d</strong></p><p><strong>BIPUSH</strong> <em>b</em> 压入字节值 <em>b</em></p><p><strong>SIPUSH</strong> <em>s</em> 压入 <strong>short</strong> 值 <em>s</em></p><p><strong>LDC</strong> <em>cst</em> 压入任意 <strong>int</strong>、<strong>float</strong>、<strong>long</strong>、<strong>double</strong>、<strong>String</strong> 或 **class **常量 <strong>cst</strong> </p><p><strong>xADD</strong>、<strong>xSUB</strong>、<strong>xMUL</strong>、<strong>xDIV</strong> 和 <strong>xREM</strong> 对应于**+<strong>、</strong>-<strong>、</strong><em><strong>、</strong>&#x2F;<strong>和</strong>%<strong>运算，其中 <strong>x</strong> 为 <strong>I</strong>、 <strong>L</strong>、</strong>F</em>* 或 <strong>D</strong> 之一</p><p>类似地，还有其他对应于**&lt;&lt;<strong>、**&gt;&gt;<strong>、</strong>&gt;&gt;&gt;<strong>、</strong>|<strong>、</strong>&amp;<strong>和</strong>^</strong>运算的指令，用于处理<strong>int</strong>和<strong>long</strong>值。</p><p><strong>I2F</strong>, <strong>F2D</strong>, <strong>L2D</strong> 等将数值由一种数值类型转换为另一种 类型。</p><p><strong>CHECKCAST</strong> <em>t</em> 将一个引用值转换为类型 <em>t</em>。</p><p><strong>NEW</strong> <em>type</em>指令将 一个 <em>type</em> 类型的新对象压入栈中</p><p><strong>GETFIELD</strong> <em>owner name desc</em> 弹出一个对象引用，并压入其 <em>name</em> 字段中的值。</p><p><strong>PUTFIELD</strong> <em>owner name desc</em> 弹出一个值和一个对象引用，并将这个值存储在它的 <em>name</em> 字段中</p><p><strong>INVOKEVIRTUAL</strong> <em>owner name desc</em> 调用在 类 <em>owner</em> 中定义的 <em>name</em> 方法，其方法描述符为 <em>desc</em></p><p><strong>INVOKESTATIC</strong> 用于静态方法</p><p><strong>INVOKESPECIAL</strong> 用于私有方法和构造器</p><p><strong>INVOKEINTERFACE</strong> 用于接口中定义的方法</p><p><strong>INVOKEDYNAMIC</strong>  用于新动态方法调用机制（对于 Java 7 中的类）</p><p><strong>x</strong> <strong>ALOAD</strong>指令弹出一个索引和一个数组，并压入此索引处数组元素的值。</p><p><strong>x</strong> <strong>ASTORE</strong> 指令弹出一个值、一个索引和一个数组，并将这个值存储在该数组的这一索引处</p><p><strong>x</strong> 可以是 <strong>I</strong>、<strong>L</strong>、<strong>F</strong>、<strong>D</strong> 或 <strong>A</strong>，还可以是 <strong>B</strong>、<strong>C</strong> 或 <strong>S</strong>。</p><p><strong>IFEQ</strong> <em>label</em> 从栈中弹出一个 <strong>int</strong> 值，如果这个值为 0，则跳转到由这个 <em>label</em> 指定的指令处</p><p><strong>IFNE</strong> 或 <strong>IFGE</strong></p><p><strong>TABLESWITCH</strong> 和<strong>LOOKUPSWITCH</strong> 对应于 <strong>switch</strong> Java 指令。</p><p><strong>x</strong> <strong>RETURN</strong>和<strong>RETURN</strong>指令用于终止一个方法的执行，并将其结果返回给调用者</p><p><strong>RETURN</strong> 用于返回 <strong>void</strong> 的方法，**x ** <strong>RETURN</strong> 用于其他方法。</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pkg;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bean</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> f;<br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getF</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.f;<br>      &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setF</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span> &#123;<br>       <span class="hljs-built_in">this</span>.f = f;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>getter</strong> 方法的字节码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ALOAD 0<br>GETFIELD pkg/Bean f I<br>IRETURN<br></code></pre></td></tr></table></figure><p><strong>setter</strong> 方法的字节码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ALOAD 0<br>ILOAD 1<br>PUTFIELD pkg/Bean f I<br>RETURN<br></code></pre></td></tr></table></figure><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndSetF</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span> &#123;<br>      <span class="hljs-keyword">if</span> (f &gt;= <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">this</span>.f = f;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">ILOAD <span class="hljs-number">1</span><br>IFLT label<br>ALOAD <span class="hljs-number">0</span><br>ILOAD <span class="hljs-number">1</span><br>PUTFIELD pkg/Bean f I GOTO end<br><span class="hljs-attr">label:</span><br>      NEW java<span class="hljs-regexp">/lang/</span>IllegalArgumentException<br>      DUP<br>      INVOKESPECIAL java<span class="hljs-regexp">/lang/</span>IllegalArgumentException &lt;init&gt; ()V<br>      ATHROW<br><span class="hljs-attr">end:</span><br>RETURN<br></code></pre></td></tr></table></figure><h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> d)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>       Thread.sleep(d);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>       e.printStackTrace();<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">TRYCATCHBLOCK <span class="hljs-keyword">try</span> <span class="hljs-keyword">catch</span> <span class="hljs-keyword">catch</span> java<span class="hljs-regexp">/lang/</span>InterruptedException <span class="hljs-attr">try:</span><br>      LLOAD <span class="hljs-number">0</span><br>      INVOKESTATIC java<span class="hljs-regexp">/lang/</span>Thread sleep (J)V<br>      RETURN<br><span class="hljs-attr">catch:</span><br>      INVOKEVIRTUAL java<span class="hljs-regexp">/lang/</span>InterruptedException printStackTrace ()V<br>      RETURN<br></code></pre></td></tr></table></figure><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><p>visitFieldInsn ： 访问某个成员变量的指令，支持GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.</p><p>visitFrame ：访问当前局部变量表和操作数栈中元素的状态，参数就是局部变量表和操作数栈的内容</p><p>visitIincInsn ： 访问自增指令</p><p>visitVarInsn ：访问局部变量指令，就是取局部变量变的值放入操作数栈</p><p>visitMethodInsn ：访问方法指令，就是调用某个方法，支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.</p><p>visitInsn ： 访问无操作数的指令，例如nop，duo等等</p><p>visitTypeInsn：访问type指令，即将一个类的全限定名作为参数然后new一个对象压入操作数栈中</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>自定义插件（官网）： https://docs.gradle.org/current/userguide/custom_plugins.html</p><p>asm文档（官网）：https://www.javadoc.io/doc/org.ow2.asm/asm/4.0/org/objectweb/asm/MethodVisitor.html</p>]]></content>
    
    
    <summary type="html">对编译后的class文件进行修改或替换操作</summary>
    
    
    
    <category term="Android" scheme="https://blog.xxsu.xyz/categories/Android/"/>
    
    
    <category term="ASM插桩" scheme="https://blog.xxsu.xyz/tags/ASM%E6%8F%92%E6%A1%A9/"/>
    
  </entry>
  
  <entry>
    <title>插件kotlin化</title>
    <link href="https://blog.xxsu.xyz/article/32d3c5f7/"/>
    <id>https://blog.xxsu.xyz/article/32d3c5f7/</id>
    <published>2021-08-13T07:46:00.000Z</published>
    <updated>2021-10-19T01:37:37.509Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>新版本的官方Gradle插件，都已经全部使用Kotlin来编写。用法比较简洁，如下所示</p><p>文件改变：</p><p>buld.gradle.kts</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">plugins &#123;<br>    `java-gradle-plugin`<br>    id(<span class="hljs-string">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version <span class="hljs-string">&quot;1.3.72&quot;</span><br>&#125;<br><br>repositories &#123;<br>    mavenCentral()<br>    google()<br>    jcenter()<br>&#125;<br><br>dependencies &#123;<br>    implementation(platform(<span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-bom&quot;</span>))<br>    implementation(<span class="hljs-string">&quot;com.android.tools.build:gradle:4.1.1&quot;</span>)<br>    implementation(<span class="hljs-string">&quot;org.ow2.asm:asm:9.1&quot;</span>)<br>&#125;<br><br>gradlePlugin &#123;<br>    <span class="hljs-keyword">val</span> greeting <span class="hljs-keyword">by</span> plugins.creating &#123;<br>        id = <span class="hljs-string">&quot;asmtest&quot;</span><br>        implementationClass = <span class="hljs-string">&quot;com.yw.asm.MyPlugin&quot;</span><br>    &#125;<br>&#125;<br><br>java.sourceCompatibility = JavaVersion.VERSION_1_8<br>java.targetCompatibility = JavaVersion.VERSION_1_8<br></code></pre></td></tr></table></figure><blockquote><p>tips：通过gradle init命令可以生成Kotlin版本的插件默认代码</p></blockquote>]]></content>
    
    
    <summary type="html">gradle插件经历java、groovy，最后到kotlin，语法更加简洁高效</summary>
    
    
    
    <category term="Android" scheme="https://blog.xxsu.xyz/categories/Android/"/>
    
    
    <category term="插件kotlin化" scheme="https://blog.xxsu.xyz/tags/%E6%8F%92%E4%BB%B6kotlin%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>自定义插件</title>
    <link href="https://blog.xxsu.xyz/article/a2759747/"/>
    <id>https://blog.xxsu.xyz/article/a2759747/</id>
    <published>2021-08-12T07:46:00.000Z</published>
    <updated>2021-10-19T01:37:37.514Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="自定义Gradle-插件"><a href="#自定义Gradle-插件" class="headerlink" title="自定义Gradle-插件"></a>自定义Gradle-插件</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在gradle中，插件大概可以分为三种类型，第一种是.gradle文件的插件，通过apply from的方式进行引用；第二种是插件对象，通过apply plugin的方式进行引用；第三种是单独项目的插件。</p><p>.gradle 形式的用得并不多，相对比较简单。这里主要介绍对象型插件的自定义方式。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br><br>repositories &#123;<br>    google()<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br><br>    implementation <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    implementation gradleApi()<br>    implementation localGroovy()<br><br>    implementation <span class="hljs-string">&#x27;org.ow2.asm:asm:9.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.ow2.asm:asm-util:9.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.ow2.asm:asm-commons:9.2&#x27;</span><br>&#125;<br><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            id = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>            implementationClass = <span class="hljs-string">&#x27;com.xs.track_asm.TrackPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>group = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br><br>uploadArchives &#123;<br>    repositories.mavenDeployer &#123;<br>        pom.groupId = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>        pom.artifactId = <span class="hljs-string">&#x27;track_asm&#x27;</span><br>        pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>        repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../repos&#x27;</span>))<br>    &#125;<br>&#125;<br><br><br>java &#123;<br>    sourceCompatibility = JavaVersion.VERSION_1_8<br>    targetCompatibility = JavaVersion.VERSION_1_8<br>&#125;<br><br><br><br>sourceSets &#123;<br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/groovy&#x27;</span><br>        &#125;<br><br>        resources &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/resources&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>从gradle-7.0开始，apply plugin: ‘maven’  被移除掉了，因此uploadArchives 等方法将无法使用。需要用maven-publish 进行替换。</p><h2 id="gradle7-0之前"><a href="#gradle7-0之前" class="headerlink" title="gradle7.0之前"></a>gradle7.0之前</h2><p>导入maven</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">apply plugin: <span class="hljs-string">&#x27;maven&#x27;</span><br></code></pre></td></tr></table></figure><p>发布配置</p><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">uploadArchives &#123;<br>    repositories.mavenDeployer &#123;<br>        pom.groupId = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>        pom.artifactId = <span class="hljs-string">&#x27;track_asm&#x27;</span><br>        pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>        repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../repos&#x27;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发布命令：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">./gradlew uploadArchives<br></code></pre></td></tr></table></figure><h2 id="gradle7-0之后"><a href="#gradle7-0之后" class="headerlink" title="gradle7.0之后"></a>gradle7.0之后</h2><p>导入maven</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br></code></pre></td></tr></table></figure><p>发布配置</p><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">publishing &#123;<br>    publications &#123;<br>        mavenJava(MavenPublication) &#123;<br>            groupId <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>            artifactId <span class="hljs-string">&#x27;track_asm&#x27;</span><br>            version <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>        &#125;<br>    &#125;<br><br>    repositories &#123;<br>        maven &#123; url uri(<span class="hljs-string">&#x27;../repos&#x27;</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发布命令：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">./gradlew publish<br></code></pre></td></tr></table></figure><h3 id="权限拒绝"><a href="#权限拒绝" class="headerlink" title="权限拒绝"></a>权限拒绝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">zsh: permission denied: ./gradlew<br></code></pre></td></tr></table></figure><p>执行： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">chmod +x gradlew<br></code></pre></td></tr></table></figure><h2 id="打包文档"><a href="#打包文档" class="headerlink" title="打包文档"></a>打包文档</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">javadoc &#123;<br>    options &#123;<br>        <span class="hljs-comment">//防止注释出现乱码</span><br>        encoding <span class="hljs-string">&quot;UTF-8&quot;</span><br>        charSet <span class="hljs-string">&#x27;UTF-8&#x27;</span><br>        author <span class="hljs-literal">true</span><br>        version <span class="hljs-literal">true</span><br>        links <span class="hljs-string">&quot;http://docs.oracle.com/javase/7/docs/api&quot;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h2><p>优点：在buildSrc中定义的插件，可以直接在其他module中运用</p><p>即直接apply具体的类，而不是其发布名称，不管做什么修改，都能马上体现，而不需要等到重新发布版本。</p>]]></content>
    
    
    <summary type="html">对需要封装的逻辑进一步封装，以插件的形式进行依赖</summary>
    
    
    
    <category term="Android" scheme="https://blog.xxsu.xyz/categories/Android/"/>
    
    
    <category term="自定义插件" scheme="https://blog.xxsu.xyz/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
</feed>
