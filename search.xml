<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bat命令</title>
    <url>/article/ad6c93b9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="批处理程序"><a href="#批处理程序" class="headerlink" title="批处理程序"></a>批处理程序</h2><blockquote>
<p>bat文件，常用于文件的批量处理，对提高工作效率很帮助。命令很简单，短短几句，掌握了之后可节约很多的时间。下面做个简单的总结，当然要全部掌握，以下这些是不够的，还需多练习，挖掘出更多的用法。</p>
</blockquote>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>%~dp0  ：当前执行bat的目录，运行过程不会变化；</p>
<p>%cd%  ：bat 脚本执行时，运行的目录，随bat运行变化；</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>set &#x2F;p string&#x3D;请输入：</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 用于输出字符串，和输出内容之间一般用空格隔离，当然也可以用逗号，推荐使用空格（在特殊情况下逗号不被允许使用）</p>
<p>举例：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><code class="hljs bat"><span class="hljs-comment">rem 关闭回显</span><br>@<span class="hljs-built_in">echo</span> off  <br></code></pre></td></tr></table></figure>



<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>%1~9 表示参数的占位符，%0不用于参数表示，表示批处理文件本身；若大于9个参数乃至更多的参数，请使用shift 标识符；</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>[&gt;&gt;]和[&gt;] 的区别，一个是追加，一个是重新写入；</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的三大功能：截取、替换、合并</p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight bat"><table><tr><td class="code"><pre><code class="hljs bat"><span class="hljs-keyword">IF</span> [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">ERRORLEVEL</span> number command<br><span class="hljs-keyword">IF</span> [<span class="hljs-keyword">NOT</span>] string1==string2 command<br><span class="hljs-keyword">IF</span> [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">EXIST</span> filename command<br></code></pre></td></tr></table></figure>



<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>文件目录操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for [option] %%i in () do ()<br></code></pre></td></tr></table></figure>

<p>&#x2F;d  :匹配目录名</p>
<p>&#x2F;r：递归</p>
<p>&#x2F;l：增量递增</p>
<p>&#x2F;f：内容提取</p>
<h2 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h2><p>setlocal和endlocal  </p>
<h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><p>call  调用bat文件，</p>
<p>goto到子程序，可采用 exit &#x2F;b %errorlevel%  返回给父进程</p>
<h2 id="路径栈"><a href="#路径栈" class="headerlink" title="路径栈"></a>路径栈</h2><p>pushd 和popd 路径压栈，出栈</p>
<h2 id="调用程序"><a href="#调用程序" class="headerlink" title="调用程序"></a>调用程序</h2><p>start 开启程序</p>
<h2 id="宏使用"><a href="#宏使用" class="headerlink" title="宏使用"></a>宏使用</h2><p>$g  :重定向到设备或文件</p>
<p>$g$g:追加到文件末尾</p>
<p>$b:将宏输出给命令，同管道</p>
<p>$t:命令分隔符</p>
<p>$1-9:参数</p>
<p>$*:后续命令</p>
<p>echo off …. echo on，使得整个宏运行时不会多次换行</p>
<p>更多内容后续更新，点关注不迷路…</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>bat命令</tag>
      </tags>
  </entry>
  <entry>
    <title>优美的句子</title>
    <url>/article/35fb243/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="统计单词个数"><a href="#统计单词个数" class="headerlink" title="统计单词个数"></a>统计单词个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Good morning. Have a good class. &quot;</span> + <span class="hljs-string">&quot;Have a good visit. Have fun!&quot;</span>;<br>		Stream.of(text.split(<span class="hljs-string">&quot;[\\s+\\p&#123;P&#125;]&quot;</span>)).parallel().filter(e -&gt; e.length() &gt; <span class="hljs-number">0</span>)<br>				.collect(Collectors.groupingBy(String::toLowerCase, TreeMap::<span class="hljs-keyword">new</span>, Collectors.counting()))<br>				.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot; &quot;</span> + v));<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<br/>

<h2 id="计算文件大小"><a href="#计算文件大小" class="headerlink" title="计算文件大小"></a>计算文件大小</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">(File file)</span> &#123;<br>		<span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>			<span class="hljs-keyword">return</span> file.length();<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">return</span> Files.list(file.toPath()).parallel().mapToLong(e -&gt; getSize(e.toFile())).sum();<br>			&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>		<span class="hljs-type">String</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> in.nextLine();<br>		System.out.println(getSize(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dir)) + <span class="hljs-string">&quot;bytes&quot;</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA并发编程-原子性、可见性、有序性</title>
    <url>/article/1a8f4df9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，是不可被中断的。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">233</span>;        <span class="hljs-comment">//语句1</span><br>b = a;          <span class="hljs-comment">//语句2</span><br>a++;            <span class="hljs-comment">//语句3</span><br>a = a + <span class="hljs-number">1</span>;      <span class="hljs-comment">//语句4</span><br></code></pre></td></tr></table></figure>

<p>其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>a++和 a &#x3D; a+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>Java内存模型只提供了基本的读取和赋值原子操作保证，若要对大范围的操作提供原子保证，可以通过synchronized和Lock来实现，来达到线程安全。</p>
<h2 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile保证了不同线程对这个变量进行操作时的可见性</p>
<p>1）一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的（拷贝副本》修改副本》刷新回主存）；</p>
<p>2）禁止进行指令重排序；</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1:</span><br>result = init();   <span class="hljs-comment">//语句1</span><br>flag = <span class="hljs-literal">true</span>;       <span class="hljs-comment">//语句2</span><br> <br><span class="hljs-comment">//线程2:</span><br><span class="hljs-keyword">while</span>(!flag )&#123;<br>  Thread.sleep();<br>&#125;<br>doSomething(result);<br></code></pre></td></tr></table></figure>

<p>若flag未加volatile 修饰，可能先于语句1执行，在多线程环境下，result还未取到结果，可flag已为true，线程2误以为result有值，便开始执行doSomething…，最后发生异常~</p>
<p>除此之外，常见用volatile 关键字的地方还有双重判空的单例模式；</p>
<p>因 volatile关键字会在内存中产生一个内存屏障，起到阻挡作用，禁止了指令的重排。</p>
<h3 id="synchronized和Lock"><a href="#synchronized和Lock" class="headerlink" title="synchronized和Lock"></a>synchronized和Lock</h3><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>即程序执行的顺序按照代码的先后顺序执行。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”；但并不是100%，毕竟volatile无法保证操作的原子性；</p>
<p>synchronized关键字通过加锁可以使线程达到同步，但是会产生阻塞，涉及到<strong>用户模式</strong>和<strong>内核模式</strong>的转换，这会很影响程序执行的效率。那么存在不用加锁的吗？当然有—无锁机制CAS，原子类的实现原理，放在后面讲解，这里不做讨论。</p>
<p>通过使用以及原理对比，我们可以发现，volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性！</p>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p>摘自—-《深入理解Java虚拟机》</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA并发编程-阻塞队列之ArrayBlockingQueue详解</title>
    <url>/article/5a190551/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue 有两个构造方法，一个带fair，一个不带fair；</p>
<p>fair为true：表示公平锁机制，FIFO；</p>
<p>fair为false：表示非公平机制，随机；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(capacity, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>阻塞队列，使用 一个ReentrantLock 和两个Condition 保证队列的安全；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.add(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加元素主要依赖于offer方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offer(e))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由上可知，ArrayBlockingQueue 添加元素的最终方法还是offer方法；</p>
<p>offer 方法一共有两个，一个是延时添加，一个是非延时添加；</p>
<h3 id="offer-E-e"><a href="#offer-E-e" class="headerlink" title="offer(E e)"></a>offer(E e)</h3><p>带有返回值的添加，lock加锁保证原子操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (count == items.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            enqueue(e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="offer-E-e-long-timeout-TimeUnit-unit"><a href="#offer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="offer(E e, long timeout, TimeUnit unit)"></a>offer(E e, long timeout, TimeUnit unit)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    checkNotNull(e);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">//lockInterruptibly() 方法的作用：如果当前线程未被中断则获得锁,如果当前线程被中断则出现异常。</span><br>    lock.lockInterruptibly();<span class="hljs-comment">//注意事项：该处不能放入try中，不然当程序执行到finally处，将产生IllegalMonitorStateException 异常！！！</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            nanos = notFull.awaitNanos(nanos);<br>        &#125;<br>        enqueue(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<span class="hljs-comment">// 这里配对释放锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="lockInterruptibly和lock的区别"><a href="#lockInterruptibly和lock的区别" class="headerlink" title="lockInterruptibly和lock的区别"></a>lockInterruptibly和lock的区别</h4><blockquote>
<pre><code>lock.lockInterruptibly()：如果当前线程未被中断则获得锁,如果当前线程被中断则出现异常；
lock.lock()：即使调用了线程的interrupt()方法,也没有真正的中断线程，只是会产生中断异常，依然获取锁定
</code></pre>
</blockquote>
<h3 id="awaitNanos-long-nanosTimeout"><a href="#awaitNanos-long-nanosTimeout" class="headerlink" title="awaitNanos(long nanosTimeout)"></a>awaitNanos(long nanosTimeout)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-comment">//等待截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>            transferAfterCancelledWait(node);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        nanosTimeout = deadline - System.nanoTime();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)<br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>    <span class="hljs-comment">//返回剩余等待时间</span><br>    <span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="enqueue-E-x"><a href="#enqueue-E-x" class="headerlink" title="enqueue(E x)"></a>enqueue(E x)</h3><p>添加进入队列，通过源码可以看到，这里其实是数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[putIndex] == null;</span><br>    <br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = x;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="put-E-e"><a href="#put-E-e" class="headerlink" title="put(E e)"></a>put(E e)</h2><p>和offer方法类似，不同之处在于没有返回值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="poll-long-timeout-TimeUnit-unit"><a href="#poll-long-timeout-TimeUnit-unit" class="headerlink" title="poll(long timeout, TimeUnit unit)"></a>poll(long timeout, TimeUnit unit)</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            nanos = notEmpty.awaitNanos(nanos);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-literal">null</span> : dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** items index for next take, poll, peek or remove */</span><br><span class="hljs-type">int</span> takeIndex;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> itemAt(takeIndex); <span class="hljs-comment">// null when queue is empty</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="itemAt-int-i"><a href="#itemAt-int-i" class="headerlink" title="itemAt(int i)"></a>itemAt(int i)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> E <span class="hljs-title function_">itemAt</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) items[i];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue()"></a>dequeue()</h3><p>出队操作，元素置空，并返回出队元素；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[takeIndex] != null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<br>    notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="elementDequeued"><a href="#elementDequeued" class="headerlink" title="elementDequeued()"></a>elementDequeued()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">elementDequeued</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>        queueIsEmpty();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (takeIndex == <span class="hljs-number">0</span>)<br>        takeIndexWrapped();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="queueIsEmpty"><a href="#queueIsEmpty" class="headerlink" title="queueIsEmpty()"></a>queueIsEmpty()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">queueIsEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        <span class="hljs-type">Itr</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> p.get();<br>        <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">null</span>) &#123;<br>            p.clear();<br>            it.shutdown();<br>        &#125;<br>    &#125;<br>    head = <span class="hljs-literal">null</span>;<br>    itrs = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared state for currently active iterators, or null if there</span><br><span class="hljs-comment"> * are known not to be any.  Allows queue operations to update</span><br><span class="hljs-comment"> * iterator state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">Itrs</span> <span class="hljs-variable">itrs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>



<h3 id="takeIndexWrapped"><a href="#takeIndexWrapped" class="headerlink" title="takeIndexWrapped()"></a>takeIndexWrapped()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">takeIndexWrapped</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-keyword">if</span> (isDetached())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (itrs.cycles - prevCycles &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// All the elements that existed at the time of the last</span><br>        <span class="hljs-comment">// operation are gone, so abandon further iteration.</span><br>        shutdown();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> count;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">putIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putIndex;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> takeIndex;<br>            <span class="hljs-keyword">do</span> &#123;<br>                items[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (++i == items.length)<br>                    i = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">while</span> (i != putIndex);<br>            takeIndex = putIndex;<br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>                itrs.queueIsEmpty();<br>            <span class="hljs-keyword">for</span> (; k &gt; <span class="hljs-number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)<br>                notFull.signal();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="removedAt-int-removedIndex"><a href="#removedAt-int-removedIndex" class="headerlink" title="removedAt(int removedIndex)"></a>removedAt(int removedIndex)</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">removedAt</span><span class="hljs-params">(<span class="hljs-type">int</span> removedIndex)</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-keyword">if</span> (isDetached())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cycles</span> <span class="hljs-operator">=</span> itrs.cycles;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">takeIndex</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.takeIndex;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevCycles</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prevCycles;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevTakeIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prevTakeIndex;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> items.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cycleDiff</span> <span class="hljs-operator">=</span> cycles - prevCycles;<br>    <span class="hljs-keyword">if</span> (removedIndex &lt; takeIndex)<br>        cycleDiff++;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">removedDistance</span> <span class="hljs-operator">=</span><br>        (cycleDiff * len) + (removedIndex - prevTakeIndex);<br>    <span class="hljs-comment">// assert removedDistance &gt;= 0;</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.cursor;<br>    <span class="hljs-keyword">if</span> (cursor &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> distance(cursor, prevTakeIndex, len);<br>        <span class="hljs-keyword">if</span> (x == removedDistance) &#123;<br>            <span class="hljs-keyword">if</span> (cursor == putIndex)<br>                <span class="hljs-built_in">this</span>.cursor = cursor = NONE;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; removedDistance) &#123;<br>            <span class="hljs-comment">// assert cursor != prevTakeIndex;</span><br>            <span class="hljs-built_in">this</span>.cursor = cursor = dec(cursor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lastRet;<br>    <span class="hljs-keyword">if</span> (lastRet &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> distance(lastRet, prevTakeIndex, len);<br>        <span class="hljs-keyword">if</span> (x == removedDistance)<br>            <span class="hljs-built_in">this</span>.lastRet = lastRet = REMOVED;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; removedDistance)<br>            <span class="hljs-built_in">this</span>.lastRet = lastRet = dec(lastRet);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.nextIndex;<br>    <span class="hljs-keyword">if</span> (nextIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> distance(nextIndex, prevTakeIndex, len);<br>        <span class="hljs-keyword">if</span> (x == removedDistance)<br>            <span class="hljs-built_in">this</span>.nextIndex = nextIndex = REMOVED;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; removedDistance)<br>            <span class="hljs-built_in">this</span>.nextIndex = nextIndex = dec(nextIndex);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor &lt; <span class="hljs-number">0</span> &amp;&amp; nextIndex &lt; <span class="hljs-number">0</span> &amp;&amp; lastRet &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.prevTakeIndex = DETACHED;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="ArrayBlockingQueue的迭代器"><a href="#ArrayBlockingQueue的迭代器" class="headerlink" title="ArrayBlockingQueue的迭代器"></a>ArrayBlockingQueue的迭代器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Iterator for ArrayBlockingQueue.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * To maintain weak consistency with respect to puts and takes, we</span><br><span class="hljs-comment">     * read ahead one slot, so as to not report hasNext true but then</span><br><span class="hljs-comment">     * not have an element to return.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * We switch into &quot;detached&quot; mode (allowing prompt unlinking from</span><br><span class="hljs-comment">     * itrs without help from the GC) when all indices are negative, or</span><br><span class="hljs-comment">     * when hasNext returns false for the first time.  This allows the</span><br><span class="hljs-comment">     * iterator to track concurrent updates completely accurately,</span><br><span class="hljs-comment">     * except for the corner case of the user calling Iterator.remove()</span><br><span class="hljs-comment">     * after hasNext() returned false.  Even in this case, we ensure</span><br><span class="hljs-comment">     * that we don&#x27;t remove the wrong element by keeping track of the</span><br><span class="hljs-comment">     * expected element to remove, in lastItem.  Yes, we may fail to</span><br><span class="hljs-comment">     * remove lastItem from the queue if it moved due to an interleaved</span><br><span class="hljs-comment">     * interior remove while in detached mode.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-comment">/** Index to look for new nextItem; NONE at end */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br><br>        <span class="hljs-comment">/** Element to be returned by next call to next(); null if none */</span><br>        <span class="hljs-keyword">private</span> E nextItem;<br><br>        <span class="hljs-comment">/** Index of nextItem; NONE if none, REMOVED if removed elsewhere */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br><br>        <span class="hljs-comment">/** Last element returned; null if none or not detached. */</span><br>        <span class="hljs-keyword">private</span> E lastItem;<br><br>        <span class="hljs-comment">/** Index of lastItem, NONE if none, REMOVED if removed elsewhere */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> lastRet;<br><br>        <span class="hljs-comment">/** Previous value of takeIndex, or DETACHED when detached */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> prevTakeIndex;<br><br>        <span class="hljs-comment">/** Previous value of iters.cycles */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> prevCycles;<br><br>        <span class="hljs-comment">/** Special index value indicating &quot;not available&quot; or &quot;undefined&quot; */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NONE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Special index value indicating &quot;removed elsewhere&quot;, that is,</span><br><span class="hljs-comment">         * removed by some operation other than a call to this.remove().</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REMOVED</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">/** Special value for prevTakeIndex indicating &quot;detached mode&quot; */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DETACHED</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>        Itr() &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 0;</span><br>            lastRet = NONE;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.lock;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// assert itrs == null;</span><br>                    cursor = NONE;<br>                    nextIndex = NONE;<br>                    prevTakeIndex = DETACHED;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">takeIndex</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.takeIndex;<br>                    prevTakeIndex = takeIndex;<br>                    nextItem = itemAt(nextIndex = takeIndex);<br>                    cursor = incCursor(takeIndex);<br>                    <span class="hljs-keyword">if</span> (itrs == <span class="hljs-literal">null</span>) &#123;<br>                        itrs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itrs</span>(<span class="hljs-built_in">this</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        itrs.register(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// in this order</span><br>                        itrs.doSomeSweeping(<span class="hljs-literal">false</span>);<br>                    &#125;<br>                    prevCycles = itrs.cycles;<br>                    <span class="hljs-comment">// assert takeIndex &gt;= 0;</span><br>                    <span class="hljs-comment">// assert prevTakeIndex == takeIndex;</span><br>                    <span class="hljs-comment">// assert nextIndex &gt;= 0;</span><br>                    <span class="hljs-comment">// assert nextItem != null;</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDetached</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            <span class="hljs-keyword">return</span> prevTakeIndex &lt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">incCursor</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            <span class="hljs-keyword">if</span> (++index == items.length)<br>                index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (index == putIndex)<br>                index = NONE;<br>            <span class="hljs-keyword">return</span> index;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns true if index is invalidated by the given number of</span><br><span class="hljs-comment">         * dequeues, starting from prevTakeIndex.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">invalidated</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> prevTakeIndex,</span><br><span class="hljs-params">                                    <span class="hljs-type">long</span> dequeues, <span class="hljs-type">int</span> length)</span> &#123;<br>            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> index - prevTakeIndex;<br>            <span class="hljs-keyword">if</span> (distance &lt; <span class="hljs-number">0</span>)<br>                distance += length;<br>            <span class="hljs-keyword">return</span> dequeues &gt; distance;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Adjusts indices to incorporate all dequeues since the last</span><br><span class="hljs-comment">         * operation on this iterator.  Call only from iterating thread.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incorporateDequeues</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            <span class="hljs-comment">// assert itrs != null;</span><br>            <span class="hljs-comment">// assert !isDetached();</span><br>            <span class="hljs-comment">// assert count &gt; 0;</span><br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cycles</span> <span class="hljs-operator">=</span> itrs.cycles;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">takeIndex</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.takeIndex;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevCycles</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prevCycles;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevTakeIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prevTakeIndex;<br><br>            <span class="hljs-keyword">if</span> (cycles != prevCycles || takeIndex != prevTakeIndex) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> items.length;<br>                <span class="hljs-comment">// how far takeIndex has advanced since the previous</span><br>                <span class="hljs-comment">// operation of this iterator</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">dequeues</span> <span class="hljs-operator">=</span> (cycles - prevCycles) * len<br>                    + (takeIndex - prevTakeIndex);<br><br>                <span class="hljs-comment">// Check indices for invalidation</span><br>                <span class="hljs-keyword">if</span> (invalidated(lastRet, prevTakeIndex, dequeues, len))<br>                    lastRet = REMOVED;<br>                <span class="hljs-keyword">if</span> (invalidated(nextIndex, prevTakeIndex, dequeues, len))<br>                    nextIndex = REMOVED;<br>                <span class="hljs-keyword">if</span> (invalidated(cursor, prevTakeIndex, dequeues, len))<br>                    cursor = takeIndex;<br><br>                <span class="hljs-keyword">if</span> (cursor &lt; <span class="hljs-number">0</span> &amp;&amp; nextIndex &lt; <span class="hljs-number">0</span> &amp;&amp; lastRet &lt; <span class="hljs-number">0</span>)<br>                    detach();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.prevCycles = cycles;<br>                    <span class="hljs-built_in">this</span>.prevTakeIndex = takeIndex;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Called when itrs should stop tracking this iterator, either</span><br><span class="hljs-comment">         * because there are no more indices to update (cursor &lt; 0 &amp;&amp;</span><br><span class="hljs-comment">         * nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) or as a special exception, when</span><br><span class="hljs-comment">         * lastRet &gt;= 0, because hasNext() is about to return false for the</span><br><span class="hljs-comment">         * first time.  Call only from iterating thread.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// Switch to detached mode</span><br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            <span class="hljs-comment">// assert cursor == NONE;</span><br>            <span class="hljs-comment">// assert nextIndex &lt; 0;</span><br>            <span class="hljs-comment">// assert lastRet &lt; 0 || nextItem == null;</span><br>            <span class="hljs-comment">// assert lastRet &lt; 0 ^ lastItem != null;</span><br>            <span class="hljs-keyword">if</span> (prevTakeIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// assert itrs != null;</span><br>                prevTakeIndex = DETACHED;<br>                <span class="hljs-comment">// try to unlink from itrs (but not too hard)</span><br>                itrs.doSomeSweeping(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * For performance reasons, we would like not to acquire a lock in</span><br><span class="hljs-comment">         * hasNext in the common case.  To allow for this, we only access</span><br><span class="hljs-comment">         * fields (i.e. nextItem) that are not modified by update operations</span><br><span class="hljs-comment">         * triggered by queue modifications.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 0;</span><br>            <span class="hljs-keyword">if</span> (nextItem != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            noNext();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">noNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.lock;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// assert cursor == NONE;</span><br>                <span class="hljs-comment">// assert nextIndex == NONE;</span><br>                <span class="hljs-keyword">if</span> (!isDetached()) &#123;<br>                    <span class="hljs-comment">// assert lastRet &gt;= 0;</span><br>                    incorporateDequeues(); <span class="hljs-comment">// might update lastRet</span><br>                    <span class="hljs-keyword">if</span> (lastRet &gt;= <span class="hljs-number">0</span>) &#123;<br>                        lastItem = itemAt(lastRet);<br>                        <span class="hljs-comment">// assert lastItem != null;</span><br>                        detach();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// assert isDetached();</span><br>                <span class="hljs-comment">// assert lastRet &lt; 0 ^ lastItem != null;</span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 0;</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nextItem;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.lock;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!isDetached())<br>                    incorporateDequeues();<br>                <span class="hljs-comment">// assert nextIndex != NONE;</span><br>                <span class="hljs-comment">// assert lastItem == null;</span><br>                lastRet = nextIndex;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.cursor;<br>                <span class="hljs-keyword">if</span> (cursor &gt;= <span class="hljs-number">0</span>) &#123;<br>                    nextItem = itemAt(nextIndex = cursor);<br>                    <span class="hljs-comment">// assert nextItem != null;</span><br>                    <span class="hljs-built_in">this</span>.cursor = incCursor(cursor);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nextIndex = NONE;<br>                    nextItem = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 0;</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.lock;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!isDetached())<br>                    incorporateDequeues(); <span class="hljs-comment">// might update lastRet or detach</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lastRet;<br>                <span class="hljs-built_in">this</span>.lastRet = NONE;<br>                <span class="hljs-keyword">if</span> (lastRet &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (!isDetached())<br>                        removeAt(lastRet);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">lastItem</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lastItem;<br>                        <span class="hljs-comment">// assert lastItem != null;</span><br>                        <span class="hljs-built_in">this</span>.lastItem = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">if</span> (itemAt(lastRet) == lastItem)<br>                            removeAt(lastRet);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastRet == NONE)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>                <span class="hljs-comment">// else lastRet == REMOVED and the last returned element was</span><br>                <span class="hljs-comment">// previously asynchronously removed via an operation other</span><br>                <span class="hljs-comment">// than this.remove(), so nothing to do.</span><br><br>                <span class="hljs-keyword">if</span> (cursor &lt; <span class="hljs-number">0</span> &amp;&amp; nextIndex &lt; <span class="hljs-number">0</span>)<br>                    detach();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>                <span class="hljs-comment">// assert lastRet == NONE;</span><br>                <span class="hljs-comment">// assert lastItem == null;</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Called to notify the iterator that the queue is empty, or that it</span><br><span class="hljs-comment">         * has fallen hopelessly behind, so that it should abandon any</span><br><span class="hljs-comment">         * further iteration, except possibly to return one more element</span><br><span class="hljs-comment">         * from next(), as promised by returning true from hasNext().</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            cursor = NONE;<br>            <span class="hljs-keyword">if</span> (nextIndex &gt;= <span class="hljs-number">0</span>)<br>                nextIndex = REMOVED;<br>            <span class="hljs-keyword">if</span> (lastRet &gt;= <span class="hljs-number">0</span>) &#123;<br>                lastRet = REMOVED;<br>                lastItem = <span class="hljs-literal">null</span>;<br>            &#125;<br>            prevTakeIndex = DETACHED;<br>            <span class="hljs-comment">// Don&#x27;t set nextItem to null because we must continue to be</span><br>            <span class="hljs-comment">// able to return it on next().</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// Caller will unlink from itrs when convenient.</span><br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> prevTakeIndex, <span class="hljs-type">int</span> length)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> index - prevTakeIndex;<br>            <span class="hljs-keyword">if</span> (distance &lt; <span class="hljs-number">0</span>)<br>                distance += length;<br>            <span class="hljs-keyword">return</span> distance;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Called whenever an interior remove (not at takeIndex) occurred.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if this iterator should be unlinked from itrs</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">removedAt</span><span class="hljs-params">(<span class="hljs-type">int</span> removedIndex)</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            <span class="hljs-keyword">if</span> (isDetached())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cycles</span> <span class="hljs-operator">=</span> itrs.cycles;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">takeIndex</span> <span class="hljs-operator">=</span> ArrayBlockingQueue.<span class="hljs-built_in">this</span>.takeIndex;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevCycles</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prevCycles;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevTakeIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prevTakeIndex;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> items.length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cycleDiff</span> <span class="hljs-operator">=</span> cycles - prevCycles;<br>            <span class="hljs-keyword">if</span> (removedIndex &lt; takeIndex)<br>                cycleDiff++;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">removedDistance</span> <span class="hljs-operator">=</span><br>                (cycleDiff * len) + (removedIndex - prevTakeIndex);<br>            <span class="hljs-comment">// assert removedDistance &gt;= 0;</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.cursor;<br>            <span class="hljs-keyword">if</span> (cursor &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> distance(cursor, prevTakeIndex, len);<br>                <span class="hljs-keyword">if</span> (x == removedDistance) &#123;<br>                    <span class="hljs-keyword">if</span> (cursor == putIndex)<br>                        <span class="hljs-built_in">this</span>.cursor = cursor = NONE;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; removedDistance) &#123;<br>                    <span class="hljs-comment">// assert cursor != prevTakeIndex;</span><br>                    <span class="hljs-built_in">this</span>.cursor = cursor = dec(cursor);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lastRet;<br>            <span class="hljs-keyword">if</span> (lastRet &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> distance(lastRet, prevTakeIndex, len);<br>                <span class="hljs-keyword">if</span> (x == removedDistance)<br>                    <span class="hljs-built_in">this</span>.lastRet = lastRet = REMOVED;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; removedDistance)<br>                    <span class="hljs-built_in">this</span>.lastRet = lastRet = dec(lastRet);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.nextIndex;<br>            <span class="hljs-keyword">if</span> (nextIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> distance(nextIndex, prevTakeIndex, len);<br>                <span class="hljs-keyword">if</span> (x == removedDistance)<br>                    <span class="hljs-built_in">this</span>.nextIndex = nextIndex = REMOVED;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; removedDistance)<br>                    <span class="hljs-built_in">this</span>.nextIndex = nextIndex = dec(nextIndex);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor &lt; <span class="hljs-number">0</span> &amp;&amp; nextIndex &lt; <span class="hljs-number">0</span> &amp;&amp; lastRet &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.prevTakeIndex = DETACHED;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Called whenever takeIndex wraps around to zero.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if this iterator should be unlinked from itrs</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">takeIndexWrapped</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>            <span class="hljs-keyword">if</span> (isDetached())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (itrs.cycles - prevCycles &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// All the elements that existed at the time of the last</span><br>                <span class="hljs-comment">// operation are gone, so abandon further iteration.</span><br>                shutdown();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br><span class="hljs-comment">//         /** Uncomment for debugging. */</span><br><span class="hljs-comment">//         public String toString() &#123;</span><br><span class="hljs-comment">//             return (&quot;cursor=&quot; + cursor + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;nextIndex=&quot; + nextIndex + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;lastRet=&quot; + lastRet + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;nextItem=&quot; + nextItem + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;lastItem=&quot; + lastItem + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;prevCycles=&quot; + prevCycles + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;prevTakeIndex=&quot; + prevTakeIndex + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;size()=&quot; + size() + &quot; &quot; +</span><br><span class="hljs-comment">//                     &quot;remainingCapacity()=&quot; + remainingCapacity());</span><br><span class="hljs-comment">//         &#125;</span><br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ArrayBlockingQueue是一个数据结构为数组的阻塞队列，由ReentrantLock来实现线程安全，内部操作</p>
<p>由Condition的await和signal来实现等待唤醒的功能。有两种创建方式，可指定是否为公平队列和非公平队列；</p>
<ul>
<li>poll方法移除头部元素并返回，可延迟；</li>
<li>take等待到有元素为止；</li>
<li>peek只是返回头部元素，不移除；</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA数据结构之Map集合</title>
    <url>/article/497b1455/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 继承于AbstractMap，实现于Map接口；由数组加链表实现，默认大小16，加载因子0.75</p>
<p>众所周知，HashMap是线程不安全的，HashTable才是线程安全的，那么究竟是什么导致线程不安全的呢？</p>
<p>put操作，在多线程模式下，触发扩容机制，导致数据被覆盖；</p>
<p>但是在单线程模式下还是可以使用的，其结构采用数组+链表的形式；通过hashcode 值得到索引，再追加到链表中，当链表的长度大于8时，采用红黑树算法；</p>
<p>为了使其线程安全，在 java.util.Collections  集合中有个Collections.synchronizedMap包装器；该包装器可以使其达到线程安全的效果；</p>
<p>示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;());<br>        <span class="hljs-keyword">final</span> Map&lt;String, String&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>+ finalI *<span class="hljs-number">250</span>; j &lt;<span class="hljs-number">250</span>+finalI *<span class="hljs-number">250</span>; j++) &#123;<br>                        map.put(String.valueOf(j), String.valueOf(j));<br>                        map2.put(String.valueOf(j), String.valueOf(j));<br>                    &#125;<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.size(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (!String.valueOf(i).equals(map.get(String.valueOf(i)))) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;map false&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!String.valueOf(i).equals(map2.get(String.valueOf(i)))) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;map2 false&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">map2 <span class="hljs-literal">false</span><br>...<br>map2 <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>补充：hash冲突： 开发寻址法：线性探测法、二次探测法、双重哈希；链表法</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>而hashtable之所以线程安全，因为它的put和get操作均添加有synchronized关键字，进行同步操作，获取锁，使其他线程阻塞等待；</p>
<p>因为当一个线程访问hashtable的同步方法时，其他线程再次尝试访问的时候，会进入阻塞或者轮询状态，比如当线程1使用put进行元素添加的时候，线程2不但不能使用put来添加元素，而且不能使用get获取元素。</p>
<p>虽然达到了线程安全的效果，但是极大的降低了效率，不推荐使用；</p>
<p>既然HashMap是线程不安全的，而HashTable的效率又不是很高，那么有没有除了他俩之外的其他数据结构呢？</p>
<p>答案当然有，如：ConcurrentHashMap等等；</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>通过属性值可知，和HashMap一样，默认容量也是16，大于8转为树，并且还是线程安全的；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">private static final int DEFAULT_CAPACITY = 16;<br>private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;<br>private static final float LOAD_FACTOR = 0.75f;<br>static final int TREEIFY_THRESHOLD = 8;<br></code></pre></td></tr></table></figure>

<p>ConcurrentHashMap 采用了一种叫做分段锁的机制，分段进行加锁，同时进行读写，大大地提高了效率；比围绕非线程安全Map的Collections.synchronizedMap包装器性能更高。</p>
<p>且在jdk1.8中对ConcurrentHashMap 进行了优化，采用compareAndSwapInt+synchronized 方式进而大大提高了效率。</p>
<p>除此之外，它还提供了一些原子操作的方法：</p>
<p><strong>putIfAbsent</strong></p>
<p>putIfAbsent方法主要是在向ConcurrentHashMap中添加键—值对的时候，它会先判断该键值对是否已经存在。</p>
<ul>
<li>如果不存在（新的entry），那么会向map中添加该键值对，并返回null；</li>
<li>如果已经存在，那么不会覆盖已有的值，直接返回已经存在的值；</li>
</ul>
<p><strong>computeIfAbsent</strong></p>
<ul>
<li>如果 key 对应的 value 不存在，则使用获取 remappingFunction 重新计算后的值，并保存为该 key 的 value，否则返回 value。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li>LinkedHashMap属于HashMap的子类，与HashMap的区别在于LinkedHashMap保存了记录插入的顺序。</li>
<li>LinkedHashMap 是一个双向的链表，包含有链表头、尾的指针，因这个特性，所以LinkedHashMap 是有序的，而HashMap是无序的。</li>
<li>LinkedHashMap的构造函数中有个 accessOrder 变量，true 表示链表按访问顺序，false 表示按插入顺序；</li>
<li>如下所示，通过对该变量的控制，可以利用LinkedHashMap实现LruCache的核心思想;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                     <span class="hljs-type">float</span> loadFactor,</span><br><span class="hljs-params">                     <span class="hljs-type">boolean</span> accessOrder)</span> &#123;<br>    <span class="hljs-built_in">super</span>(initialCapacity, loadFactor);<br>    <span class="hljs-built_in">this</span>.accessOrder = accessOrder;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li><p>TreeMap实现了SortedMap接口，TreeMap有能力对插入的记录根据key排序，默认按照升序排序，也可以自定义比较强，在使用TreeMap的时候，key应当实现Comparable。</p>
</li>
<li><p>TreeMap基于红黑树实现，非线程安全 ；</p>
</li>
<li><p>与HashMap比较：两者均是线程不安全的；通常情况下HashMap通常比TreeMap快些，若是使用排序选择TreeMap，其他情况则建议多使用HashMap；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Zygote详解</title>
    <url>/article/8b3b35/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p>Zygote进程通过克隆的方式创建子进程，使用fork方法，会从父进程进行资源的继承；并且在启动的时候会创建 Java ART虚拟机，加载java进程所需的所有系统资源。</p>
<h2 id="App-main-main"><a href="#App-main-main" class="headerlink" title="App_main -&gt; main()"></a>App_main -&gt; main()</h2><p>App_main.cpp	cmds\App_process</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!LOG_NDEBUG) &#123;<br>      String8 argv_String;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i) &#123;<br>        argv_String.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        argv_String.<span class="hljs-built_in">append</span>(argv[i]);<br>        argv_String.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\&quot; &quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;app_process main with argv: %s&quot;</span>, argv_String.<span class="hljs-built_in">string</span>());<br>    &#125;<br>    <span class="hljs-comment">// argv[0] = &quot;/system/bin/app_process&quot;</span><br>    <span class="hljs-function">AppRuntime <span class="hljs-title">runtime</span><span class="hljs-params">(argv[<span class="hljs-number">0</span>], computeArgBlockSize(argc, argv))</span></span>;<br>    <span class="hljs-comment">// Process command line arguments；</span><br>    <span class="hljs-comment">// ignore argv[0]</span><br>    argc--;<br>    argv++;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* spaced_commands[] = &#123; <span class="hljs-string">&quot;-cp&quot;</span>, <span class="hljs-string">&quot;-classpath&quot;</span> &#125;;<br>    <span class="hljs-comment">// Allow &quot;spaced commands&quot; to be succeeded by exactly 1 argument (regardless of -s).</span><br>    <span class="hljs-type">bool</span> known_command = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i++) &#123;<br>        <span class="hljs-keyword">if</span> (known_command == <span class="hljs-literal">true</span>) &#123;<br>          runtime.<span class="hljs-built_in">addOption</span>(<span class="hljs-built_in">strdup</span>(argv[i]));<br>          <span class="hljs-comment">// The static analyzer gets upset that we don&#x27;t ever free the above</span><br>          <span class="hljs-comment">// string. Since the allocation is from main, leaking it doesn&#x27;t seem</span><br>          <span class="hljs-comment">// problematic. NOLINTNEXTLINE</span><br>          <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;app_process main add known option &#x27;%s&#x27;&quot;</span>, argv[i]);<br>          known_command = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>             j &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">sizeof</span>(spaced_commands) / <span class="hljs-built_in">sizeof</span>(spaced_commands[<span class="hljs-number">0</span>]));<br>             ++j) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], spaced_commands[j]) == <span class="hljs-number">0</span>) &#123;<br>            known_command = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;app_process main found known command &#x27;%s&#x27;&quot;</span>, argv[i]);<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (argv[i][<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (argv[i][<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; argv[i][<span class="hljs-number">2</span>] == <span class="hljs-number">0</span>) &#123;<br>            ++i; <span class="hljs-comment">// Skip --.</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        runtime.<span class="hljs-built_in">addOption</span>(<span class="hljs-built_in">strdup</span>(argv[i]));<br>        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;app_process main add option &#x27;%s&#x27;&quot;</span>, argv[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// zygote判断</span><br>    <span class="hljs-type">bool</span> zygote = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> startSystemServer = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> application = <span class="hljs-literal">false</span>;<br>    String8 niceName;<br>    String8 className;<br><br>    ++i;  <span class="hljs-comment">// Skip unused &quot;parent dir&quot; argument.</span><br>    <span class="hljs-keyword">while</span> (i &lt; argc) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg = argv[i++];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--zygote&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            zygote = <span class="hljs-literal">true</span>;<br>            niceName = ZYGOTE_NICE_NAME;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--start-system-server&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            startSystemServer = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--application&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            application = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(arg, <span class="hljs-string">&quot;--nice-name=&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>) &#123;<br>            niceName.<span class="hljs-built_in">setTo</span>(arg + <span class="hljs-number">12</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(arg, <span class="hljs-string">&quot;--&quot;</span>, <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>) &#123;<br>            className.<span class="hljs-built_in">setTo</span>(arg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            --i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    Vector&lt;String8&gt; args;<br>    <span class="hljs-keyword">if</span> (!className.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-comment">// 不在zygote模式, 我们需要传递给RuntimeInit的唯一参数是应用程序参数。</span><br>        <span class="hljs-comment">// 剩余的args传递给启动类main()。 在使用进程名称覆盖它们之前，对其进行复制。</span><br>        args.<span class="hljs-built_in">add</span>(application ? <span class="hljs-built_in">String8</span>(<span class="hljs-string">&quot;application&quot;</span>) : <span class="hljs-built_in">String8</span>(<span class="hljs-string">&quot;tool&quot;</span>));<br>        runtime.<span class="hljs-built_in">setClassNameAndArgs</span>(className, argc - i, argv + i);<br><br>        <span class="hljs-keyword">if</span> (!LOG_NDEBUG) &#123;<br>          String8 restOfArgs;<br>          <span class="hljs-type">char</span>* <span class="hljs-type">const</span>* argv_new = argv + i;<br>          <span class="hljs-type">int</span> argc_new = argc - i;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; argc_new; ++k) &#123;<br>            restOfArgs.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\&quot;&quot;</span>);<br>            restOfArgs.<span class="hljs-built_in">append</span>(argv_new[k]);<br>            restOfArgs.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\&quot; &quot;</span>);<br>          &#125;<br>          <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Class name = %s, args = %s&quot;</span>, className.<span class="hljs-built_in">string</span>(), restOfArgs.<span class="hljs-built_in">string</span>());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 在zygote模式</span><br>        <span class="hljs-comment">// 创建 /data/dalvik-cache/ 目录</span><br>        <span class="hljs-built_in">maybeCreateDalvikCache</span>();<br><br>        <span class="hljs-keyword">if</span> (startSystemServer) &#123;<br>            args.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">String8</span>(<span class="hljs-string">&quot;start-system-server&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-type">char</span> prop[PROP_VALUE_MAX];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">property_get</span>(ABI_LIST_PROPERTY, prop, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,<br>                ABI_LIST_PROPERTY);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>        &#125;<br><br>        <span class="hljs-function">String8 <span class="hljs-title">abiFlag</span><span class="hljs-params">(<span class="hljs-string">&quot;--abi-list=&quot;</span>)</span></span>;<br>        abiFlag.<span class="hljs-built_in">append</span>(prop);<br>        <span class="hljs-comment">// 获取支持的 abi 列表</span><br>        args.<span class="hljs-built_in">add</span>(abiFlag);<br><br>        <span class="hljs-comment">// 在 zygote 模式下，将所有剩余参数传递给 zygote 的 main() 方法。</span><br>        <span class="hljs-keyword">for</span> (; i &lt; argc; ++i) &#123;<br>            args.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">String8</span>(argv[i]));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!niceName.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-comment">// 设置进程名字</span><br>        runtime.<span class="hljs-built_in">setArgv0</span>(niceName.<span class="hljs-built_in">string</span>(), <span class="hljs-literal">true</span> <span class="hljs-comment">/* setProcName */</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (zygote) &#123;<br>        runtime.<span class="hljs-built_in">start</span>(<span class="hljs-string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className) &#123;<br>        runtime.<span class="hljs-built_in">start</span>(<span class="hljs-string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);<br>        <span class="hljs-built_in">app_usage</span>();<br>        <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>App_main主要工作：</p>
<ol>
<li>创建了 ART对象，传入虚拟机所需的选项；</li>
<li>解析 <code>zygote</code> 启动参数；</li>
<li>调用 <code>runtime.start</code> 函数，根据启动 zygote 还是命令行（<code>className</code>），进入 <code>ZygoteInit</code> 或者 <code>RuntimeInit</code> 参数分支。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (zygote) &#123;<br>    runtime.start(<span class="hljs-string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className) &#123;<br>    runtime.start(<span class="hljs-string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);<br></code></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<blockquote>
<ul>
<li><code>app_process</code> 可使用命令行调用，启动一个 Java 类，并调用 <code>main</code> 方法；</li>
<li>argc：参数个数，argv[ ]：参数指针数组; </li>
<li><code>className</code>为空才在zygote模式下</li>
</ul>
</blockquote>
<h2 id="ZygoteInit开始"><a href="#ZygoteInit开始" class="headerlink" title="ZygoteInit开始"></a>ZygoteInit开始</h2><p>开机一般会打印这行日志</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">D AndroidRuntime: &gt;&gt;&gt;&gt;&gt;&gt; START com.android.internal.os.ZygoteInit uid <span class="hljs-number">0</span> &lt;&lt;&lt;&lt;&lt;&lt;<br></code></pre></td></tr></table></figure>

<p>如果遇到不能开机的情况，这行Log没有打开，极有可能是底层的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AndroidRuntime::start</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* className, <span class="hljs-type">const</span> Vector&lt;String8&gt;&amp; options, <span class="hljs-type">bool</span> zygote)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;</span>,<br>            className != <span class="hljs-literal">NULL</span> ? className : <span class="hljs-string">&quot;(unknown)&quot;</span>, <span class="hljs-built_in">getuid</span>());<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> String8 <span class="hljs-title">startSystemServer</span><span class="hljs-params">(<span class="hljs-string">&quot;start-system-server&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//这是否是主要的zygote，意味着zygote将要fork system server。</span><br>    <span class="hljs-type">bool</span> primary_zygote = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * &#x27;startSystemServer == true&#x27; means runtime is obsolete and not run from</span><br><span class="hljs-comment">     * init.rc anymore, so we print out the boot start event here.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; options.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (options[i] == startSystemServer) &#123;<br>            primary_zygote = <span class="hljs-literal">true</span>;<br>           <span class="hljs-comment">/* track our progress through the boot sequence */</span><br>           <span class="hljs-type">const</span> <span class="hljs-type">int</span> LOG_BOOT_PROGRESS_START = <span class="hljs-number">3000</span>;<br>           <span class="hljs-built_in">LOG_EVENT_LONG</span>(LOG_BOOT_PROGRESS_START,  <span class="hljs-built_in">ns2ms</span>(<span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* rootDir = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;ANDROID_ROOT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (rootDir == <span class="hljs-literal">NULL</span>) &#123;<br>        rootDir = <span class="hljs-string">&quot;/system&quot;</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasDir</span>(<span class="hljs-string">&quot;/system&quot;</span>)) &#123;<br>            <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;No root directory specified, and /system does not exist.&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;ANDROID_ROOT&quot;</span>, rootDir, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* artRootDir = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;ANDROID_ART_ROOT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (artRootDir == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;No ART directory specified with ANDROID_ART_ROOT environment variable.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* i18nRootDir = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;ANDROID_I18N_ROOT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (i18nRootDir == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;No runtime directory specified with ANDROID_I18N_ROOT environment variable.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tzdataRootDir = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;ANDROID_TZDATA_ROOT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (tzdataRootDir == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;No tz data directory specified with ANDROID_TZDATA_ROOT environment variable.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</span><br>    <span class="hljs-comment">//ALOGD(&quot;Found LD_ASSUME_KERNEL=&#x27;%s&#x27;\n&quot;, kernelHack);</span><br><br>    <span class="hljs-comment">/* start the virtual machine */</span><br>    JniInvocation jni_invocation;<br>    jni_invocation.<span class="hljs-built_in">Init</span>(<span class="hljs-literal">NULL</span>);<br>    JNIEnv* env;<br>    <span class="hljs-comment">//调用startVm开启虚拟机</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">onVmCreated</span>(env);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用startReg注册JNI方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">startReg</span>(env) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Unable to register all android natives\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * We want to call main() with a String array with arguments in it.</span><br><span class="hljs-comment">     * At present we have two arguments, the class name and an option string.</span><br><span class="hljs-comment">     * Create an array to hold them.</span><br><span class="hljs-comment">     */</span><br>    jclass stringClass;<br>    jobjectArray strArray;<br>    jstring classNameStr;<br><br>    stringClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/String&quot;</span>);<br>    <span class="hljs-built_in">assert</span>(stringClass != <span class="hljs-literal">NULL</span>);<br>    strArray = env-&gt;<span class="hljs-built_in">NewObjectArray</span>(options.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, stringClass, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">assert</span>(strArray != <span class="hljs-literal">NULL</span>);<br>    classNameStr = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(className);<br>    <span class="hljs-built_in">assert</span>(classNameStr != <span class="hljs-literal">NULL</span>);<br>    env-&gt;<span class="hljs-built_in">SetObjectArrayElement</span>(strArray, <span class="hljs-number">0</span>, classNameStr);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; options.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        jstring optionsStr = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(options.<span class="hljs-built_in">itemAt</span>(i).<span class="hljs-built_in">string</span>());<br>        <span class="hljs-built_in">assert</span>(optionsStr != <span class="hljs-literal">NULL</span>);<br>        env-&gt;<span class="hljs-built_in">SetObjectArrayElement</span>(strArray, i + <span class="hljs-number">1</span>, optionsStr);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 启动VM。 该线程成为VM的主线程，并将在虚拟机退出之前不返回。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">char</span>* slashClassName = <span class="hljs-built_in">toSlashClassName</span>(className != <span class="hljs-literal">NULL</span> ? className : <span class="hljs-string">&quot;&quot;</span>);<br>    jclass startClass = env-&gt;<span class="hljs-built_in">FindClass</span>(slashClassName);<br>    <span class="hljs-keyword">if</span> (startClass == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);<br>        <span class="hljs-comment">/* keep going */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        jmethodID startMeth = env-&gt;<span class="hljs-built_in">GetStaticMethodID</span>(startClass, <span class="hljs-string">&quot;main&quot;</span>,<br>            <span class="hljs-string">&quot;([Ljava/lang/String;)V&quot;</span>);<br>        <span class="hljs-keyword">if</span> (startMeth == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);<br>            <span class="hljs-comment">/* keep going */</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            env-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>            <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">ExceptionCheck</span>())<br>                <span class="hljs-built_in">threadExitUncaughtException</span>(env);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(slashClassName);<br><br>    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;Shutting down VM\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;<span class="hljs-built_in">DetachCurrentThread</span>() != JNI_OK)<br>        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Warning: unable to detach main thread\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;<span class="hljs-built_in">DestroyJavaVM</span>() != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>当启动一个Activity的时候，发现Activity所在进程没有被创建，就会调用这个API进程进行创建。Process.start()方法是阻塞操作，等待直到进程创建完成并返回相应的新进程pid，才完成该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Process.ProcessStartResult <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> String processClass,</span><br><span class="hljs-params">                                                  <span class="hljs-keyword">final</span> String niceName,</span><br><span class="hljs-params">                                                  <span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> gid, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">int</span>[] gids,</span><br><span class="hljs-params">                                                  <span class="hljs-type">int</span> runtimeFlags, <span class="hljs-type">int</span> mountExternal,</span><br><span class="hljs-params">                                                  <span class="hljs-type">int</span> targetSdkVersion,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String seInfo,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@NonNull</span> String abi,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String instructionSet,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String appDataDir,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String invokeWith,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String packageName,</span><br><span class="hljs-params">                                                  <span class="hljs-type">int</span> zygotePolicyFlags,</span><br><span class="hljs-params">                                                  <span class="hljs-type">boolean</span> isTopApp,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> <span class="hljs-type">long</span>[] disabledCompatChanges,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> Map&lt;String, Pair&lt;String, Long&gt;&gt;</span><br><span class="hljs-params">                                                          pkgDataInfoMap,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> Map&lt;String, Pair&lt;String, Long&gt;&gt;</span><br><span class="hljs-params">                                                          whitelistedDataInfoMap,</span><br><span class="hljs-params">                                                  <span class="hljs-type">boolean</span> bindMountAppsData,</span><br><span class="hljs-params">                                                  <span class="hljs-type">boolean</span> bindMountAppStorageDirs,</span><br><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String[] zygoteArgs)</span> &#123;<br>        <span class="hljs-comment">// TODO (chriswailes): Is there a better place to check this value?</span><br>        <span class="hljs-keyword">if</span> (fetchUsapPoolEnabledPropWithMinInterval()) &#123;<br>            informZygotesOfUsapPoolStatus();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,<br>                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,<br>                    abi, instructionSet, appDataDir, invokeWith, <span class="hljs-comment">/*startChildZygote=*/</span> <span class="hljs-literal">false</span>,<br>                    packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges,<br>                    pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,<br>                    bindMountAppStorageDirs, zygoteArgs);<br>        &#125; <span class="hljs-keyword">catch</span> (ZygoteStartFailedEx ex) &#123;<br>            Log.e(LOG_TAG,<br>                    <span class="hljs-string">&quot;Starting VM process through Zygote failed&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                    <span class="hljs-string">&quot;Starting VM process through Zygote failed&quot;</span>, ex);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="startViaZygote"><a href="#startViaZygote" class="headerlink" title="startViaZygote"></a>startViaZygote</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Starts a new process via the zygote mechanism.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> processClass Class name whose static main() to run</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> niceName &#x27;nice&#x27; process name to appear in ps</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> uid a POSIX uid that the new process should setuid() to</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> gid a POSIX gid that the new process shuold setgid() to</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> gids null-ok; a list of supplementary group IDs that the</span><br><span class="hljs-comment">     * new process should setgroup() to.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> runtimeFlags Additional flags for the runtime.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetSdkVersion The target SDK version for the app.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> seInfo null-ok SELinux information for the new process.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> abi the ABI the process should use.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> instructionSet null-ok the instruction set to use.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> appDataDir null-ok the data directory of the app.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startChildZygote Start a sub-zygote. This creates a new zygote process</span><br><span class="hljs-comment">     * that has its state cloned from this zygote process.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> packageName null-ok the name of the package this process belongs to.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zygotePolicyFlags Flags used to determine how to launch the application.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isTopApp Whether the process starts for high priority application.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> disabledCompatChanges a list of disabled compat changes for the process being started.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pkgDataInfoMap Map from related package names to private data directory volume UUID</span><br><span class="hljs-comment">     *                       and inode number.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> whitelistedDataInfoMap Map from allowlisted package names to private data directory</span><br><span class="hljs-comment">     *                       volume UUID and inode number.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bindMountAppsData whether zygote needs to mount CE and DE data.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bindMountAppStorageDirs whether zygote needs to mount Android/obb and Android/data.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> extraArgs Additional arguments to supply to the zygote process.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> An object that describes the result of the attempt to start the process.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ZygoteStartFailedEx if process start failed for any reason</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Process.ProcessStartResult <span class="hljs-title function_">startViaZygote</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> String processClass,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> String niceName,</span><br><span class="hljs-params">                                                      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> uid, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> gid,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] gids,</span><br><span class="hljs-params">                                                      <span class="hljs-type">int</span> runtimeFlags, <span class="hljs-type">int</span> mountExternal,</span><br><span class="hljs-params">                                                      <span class="hljs-type">int</span> targetSdkVersion,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> String seInfo,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@NonNull</span> String abi,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> String instructionSet,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> String appDataDir,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> String invokeWith,</span><br><span class="hljs-params">                                                      <span class="hljs-type">boolean</span> startChildZygote,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> String packageName,</span><br><span class="hljs-params">                                                      <span class="hljs-type">int</span> zygotePolicyFlags,</span><br><span class="hljs-params">                                                      <span class="hljs-type">boolean</span> isTopApp,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> <span class="hljs-type">long</span>[] disabledCompatChanges,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> Map&lt;String, Pair&lt;String, Long&gt;&gt;</span><br><span class="hljs-params">                                                              pkgDataInfoMap,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> Map&lt;String, Pair&lt;String, Long&gt;&gt;</span><br><span class="hljs-params">                                                              whitelistedDataInfoMap,</span><br><span class="hljs-params">                                                      <span class="hljs-type">boolean</span> bindMountAppsData,</span><br><span class="hljs-params">                                                      <span class="hljs-type">boolean</span> bindMountAppStorageDirs,</span><br><span class="hljs-params">                                                      <span class="hljs-meta">@Nullable</span> String[] extraArgs)</span><br>                                                      <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;<br>        ArrayList&lt;String&gt; argsForZygote = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// --runtime-args, --setuid=, --setgid=,</span><br>        <span class="hljs-comment">// and --setgroups= must go first</span><br>        argsForZygote.add(<span class="hljs-string">&quot;--runtime-args&quot;</span>);<br>        argsForZygote.add(<span class="hljs-string">&quot;--setuid=&quot;</span> + uid);<br>        argsForZygote.add(<span class="hljs-string">&quot;--setgid=&quot;</span> + gid);<br>        argsForZygote.add(<span class="hljs-string">&quot;--runtime-flags=&quot;</span> + runtimeFlags);<br>        <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-default&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-read&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-write&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_FULL) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-full&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-installer&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_LEGACY) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-legacy&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-pass-through&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--mount-external-android-writable&quot;</span>);<br>        &#125;<br><br>        argsForZygote.add(<span class="hljs-string">&quot;--target-sdk-version=&quot;</span> + targetSdkVersion);<br><br>        <span class="hljs-comment">// --setgroups is a comma-separated list</span><br>        <span class="hljs-keyword">if</span> (gids != <span class="hljs-literal">null</span> &amp;&amp; gids.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            sb.append(<span class="hljs-string">&quot;--setgroups=&quot;</span>);<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> gids.length;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                    sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                &#125;<br>                sb.append(gids[i]);<br>            &#125;<br><br>            argsForZygote.add(sb.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (niceName != <span class="hljs-literal">null</span>) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--nice-name=&quot;</span> + niceName);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (seInfo != <span class="hljs-literal">null</span>) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--seinfo=&quot;</span> + seInfo);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (instructionSet != <span class="hljs-literal">null</span>) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--instruction-set=&quot;</span> + instructionSet);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (appDataDir != <span class="hljs-literal">null</span>) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--app-data-dir=&quot;</span> + appDataDir);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (invokeWith != <span class="hljs-literal">null</span>) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--invoke-with&quot;</span>);<br>            argsForZygote.add(invokeWith);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (startChildZygote) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--start-child-zygote&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-literal">null</span>) &#123;<br>            argsForZygote.add(<span class="hljs-string">&quot;--package-name=&quot;</span> + packageName);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isTopApp) &#123;<br>            argsForZygote.add(Zygote.START_AS_TOP_APP_ARG);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pkgDataInfoMap != <span class="hljs-literal">null</span> &amp;&amp; pkgDataInfoMap.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            sb.append(Zygote.PKG_DATA_INFO_MAP);<br>            sb.append(<span class="hljs-string">&quot;=&quot;</span>);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : pkgDataInfoMap.entrySet()) &#123;<br>                <span class="hljs-keyword">if</span> (started) &#123;<br>                    sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                &#125;<br>                started = <span class="hljs-literal">true</span>;<br>                sb.append(entry.getKey());<br>                sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                sb.append(entry.getValue().first);<br>                sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                sb.append(entry.getValue().second);<br>            &#125;<br>            argsForZygote.add(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (whitelistedDataInfoMap != <span class="hljs-literal">null</span> &amp;&amp; whitelistedDataInfoMap.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            sb.append(Zygote.WHITELISTED_DATA_INFO_MAP);<br>            sb.append(<span class="hljs-string">&quot;=&quot;</span>);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : whitelistedDataInfoMap.entrySet()) &#123;<br>                <span class="hljs-keyword">if</span> (started) &#123;<br>                    sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                &#125;<br>                started = <span class="hljs-literal">true</span>;<br>                sb.append(entry.getKey());<br>                sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                sb.append(entry.getValue().first);<br>                sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                sb.append(entry.getValue().second);<br>            &#125;<br>            argsForZygote.add(sb.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bindMountAppStorageDirs) &#123;<br>            argsForZygote.add(Zygote.BIND_MOUNT_APP_STORAGE_DIRS);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bindMountAppsData) &#123;<br>            argsForZygote.add(Zygote.BIND_MOUNT_APP_DATA_DIRS);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (disabledCompatChanges != <span class="hljs-literal">null</span> &amp;&amp; disabledCompatChanges.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            sb.append(<span class="hljs-string">&quot;--disabled-compat-changes=&quot;</span>);<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> disabledCompatChanges.length;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                    sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>                &#125;<br>                sb.append(disabledCompatChanges[i]);<br>            &#125;<br><br>            argsForZygote.add(sb.toString());<br>        &#125;<br><br>        argsForZygote.add(processClass);<br><br>        <span class="hljs-keyword">if</span> (extraArgs != <span class="hljs-literal">null</span>) &#123;<br>            Collections.addAll(argsForZygote, extraArgs);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span>(mLock) &#123;<br>            <span class="hljs-comment">// The USAP pool can not be used if the application will not use the systems graphics</span><br>            <span class="hljs-comment">// driver.  If that driver is requested use the Zygote application start path.</span><br>            <span class="hljs-keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),<br>                                              zygotePolicyFlags,<br>                                              argsForZygote);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="zygoteSendArgsAndGetResult"><a href="#zygoteSendArgsAndGetResult" class="headerlink" title="zygoteSendArgsAndGetResult"></a>zygoteSendArgsAndGetResult</h3><p>将参数列表发送到Zygote进程，这将<strong>启动一个新的子进程</strong>，并返回孩子的pid。</p>
<p>@如果流程由于任何原因启动失败，则抛出ZygoteStartFailedEx</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sends an argument list to the zygote process, which starts a new child</span><br><span class="hljs-comment">     * and returns the child&#x27;s pid. Please note: the present implementation</span><br><span class="hljs-comment">     * replaces newlines in the argument list with spaces.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ZygoteStartFailedEx if process start failed for any reason</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GuardedBy(&quot;mLock&quot;)</span><br>    <span class="hljs-keyword">private</span> Process.ProcessStartResult <span class="hljs-title function_">zygoteSendArgsAndGetResult</span><span class="hljs-params">(</span><br><span class="hljs-params">            ZygoteState zygoteState, <span class="hljs-type">int</span> zygotePolicyFlags, <span class="hljs-meta">@NonNull</span> ArrayList&lt;String&gt; args)</span><br>            <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;<br>        <span class="hljs-comment">// Throw early if any of the arguments are malformed. This means we can</span><br>        <span class="hljs-comment">// avoid writing a partial response to the zygote.</span><br>        <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>            <span class="hljs-comment">// Making two indexOf calls here is faster than running a manually fused loop due</span><br>            <span class="hljs-comment">// to the fact that indexOf is a optimized intrinsic.</span><br>            <span class="hljs-keyword">if</span> (arg.indexOf(<span class="hljs-string">&#x27;\n&#x27;</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;Embedded newlines not allowed&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg.indexOf(<span class="hljs-string">&#x27;\r&#x27;</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;Embedded carriage returns not allowed&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * See com.android.internal.os.ZygoteArguments.parseArgs()</span><br><span class="hljs-comment">         * Presently the wire format to the zygote process is:</span><br><span class="hljs-comment">         * a) a count of arguments (argc, in essence)</span><br><span class="hljs-comment">         * b) a number of newline-separated argument strings equal to count</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * After the zygote process reads these it will write the pid of</span><br><span class="hljs-comment">         * the child or -1 on failure, followed by boolean to</span><br><span class="hljs-comment">         * indicate whether a wrapper process was used.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msgStr</span> <span class="hljs-operator">=</span> args.size() + <span class="hljs-string">&quot;\n&quot;</span> + String.join(<span class="hljs-string">&quot;\n&quot;</span>, args) + <span class="hljs-string">&quot;\n&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>                <span class="hljs-comment">// If there was an IOException using the USAP pool we will log the error and</span><br>                <span class="hljs-comment">// attempt to start the process through the Zygote.</span><br>                Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with USAP pool - &quot;</span><br>                        + ex.getMessage());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="attemptZygoteSendArgsAndGetResult"><a href="#attemptZygoteSendArgsAndGetResult" class="headerlink" title="attemptZygoteSendArgsAndGetResult"></a>attemptZygoteSendArgsAndGetResult</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> Process.ProcessStartResult <span class="hljs-title function_">attemptZygoteSendArgsAndGetResult</span><span class="hljs-params">(</span><br><span class="hljs-params">            ZygoteState zygoteState, String msgStr)</span> <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">zygoteWriter</span> <span class="hljs-operator">=</span> zygoteState.mZygoteOutputWriter;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">zygoteInputStream</span> <span class="hljs-operator">=</span> zygoteState.mZygoteInputStream;<br><br>            zygoteWriter.write(msgStr);<br>            zygoteWriter.flush();<br><br>            <span class="hljs-comment">// Always read the entire result from the input stream to avoid leaving</span><br>            <span class="hljs-comment">// bytes in the stream for future process starts to accidentally stumble</span><br>            <span class="hljs-comment">// upon.</span><br>            Process.<span class="hljs-type">ProcessStartResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Process</span>.ProcessStartResult();<br>            result.pid = zygoteInputStream.readInt();<br>            result.usingWrapper = zygoteInputStream.readBoolean();<br><br>            <span class="hljs-keyword">if</span> (result.pid &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>            zygoteState.close();<br>            Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with Zygote - &quot;</span><br>                    + ex.toString());<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(ex);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="zygote-进程-main"><a href="#zygote-进程-main" class="headerlink" title="zygote 进程 main"></a>zygote 进程 main</h2><p>zygote 进程采用socket通信机制，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">/ **<br>   *这是Zygote流程的入口点。 它创建Zygote服务器，加载资源，<br>   *并处理与准备分支到应用程序的过程有关的其他任务。<br>   *<br>   *此过程以-<span class="hljs-number">20</span>的最佳值（最高优先级）开始。 所有流动的路径<br>   *需要将新的进程设置为默认值或终止优先级<br>   *在执行任何非系统代码之前。 本机端发生在SpecializeCommon中，<br>   *在ZygoteInit.handleSystemServerProcess中更改Java语言优先级时，<br>   * ZygoteConnection.handleChildProc和Zygote.usapMain。<br>   *<br>   * <span class="hljs-meta">@param</span> argv用于指定Zygote的配置的命令行参数。<br>   * /<br> <span class="hljs-meta">@UnsupportedAppUsage</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String argv[])</span> &#123;<br>     <span class="hljs-type">ZygoteServer</span> <span class="hljs-variable">zygoteServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>     <span class="hljs-comment">// 标记zygote开始。 这样可以确保线程创建将引发错误。</span><br>     ZygoteHooks.startZygoteNoThreadCreation();<br><br>     <span class="hljs-comment">// Zygote 进入自己的进程组。</span><br>     <span class="hljs-keyword">try</span> &#123;<br>         Os.setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>     &#125; <span class="hljs-keyword">catch</span> (ErrnoException ex) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failed to setpgid(0,0)&quot;</span>, ex);<br>     &#125;<br><br>     Runnable caller;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// 立即存储以供以后进行StatsLogging。</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isRuntimeRestarted</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>.equals(<br>                 SystemProperties.get(<span class="hljs-string">&quot;sys.boot_completed&quot;</span>));<br><br>         <span class="hljs-type">String</span> <span class="hljs-variable">bootTimeTag</span> <span class="hljs-operator">=</span> Process.is64Bit() ? <span class="hljs-string">&quot;Zygote64Timing&quot;</span> : <span class="hljs-string">&quot;Zygote32Timing&quot;</span>;<br>         <span class="hljs-type">TimingsTraceLog</span> <span class="hljs-variable">bootTimingsTraceLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimingsTraceLog</span>(bootTimeTag,<br>                 Trace.TRACE_TAG_DALVIK);<br>         bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;ZygoteInit&quot;</span>);<br>         RuntimeInit.preForkInit();<br><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">startSystemServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">zygoteSocketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zygote&quot;</span>;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">abiList</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">enableLazyPreload</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>         <span class="hljs-comment">//解析app_main.cpp传来的参数</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; argv.length; i++) &#123;<br>             <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;<br>                 startSystemServer = <span class="hljs-literal">true</span>;<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;<br>                 enableLazyPreload = <span class="hljs-literal">true</span>;<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;<br>                 abiList = argv[i].substring(ABI_LIST_ARG.length());<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;<br>                 zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Unknown command line argument: &quot;</span> + argv[i]);<br>             &#125;<br>         &#125;<br><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isPrimaryZygote</span> <span class="hljs-operator">=</span> zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);<br>         <span class="hljs-keyword">if</span> (!isRuntimeRestarted) &#123;<br>             <span class="hljs-keyword">if</span> (isPrimaryZygote) &#123;<br>                 FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,<br>                         BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__ZYGOTE_INIT_START,<br>                         startTime);<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zygoteSocketName.equals(Zygote.SECONDARY_SOCKET_NAME)) &#123;<br>                 FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,<br>                         BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SECONDARY_ZYGOTE_INIT_START,<br>                         startTime);<br>             &#125;<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (abiList == <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No ABI list supplied.&quot;</span>);<br>         &#125;<br><br>         <span class="hljs-comment">// 在某些配置中，我们避免过早预加载资源和类。</span><br>         <span class="hljs-comment">// 在这种情况下，我们会在第一个fork之前预装东西。</span><br>         <span class="hljs-keyword">if</span> (!enableLazyPreload) &#123;<br>             bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;ZygotePreload&quot;</span>);<br>             EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,<br>                     SystemClock.uptimeMillis());<br>             preload(bootTimingsTraceLog);<br>             EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,<br>                     SystemClock.uptimeMillis());<br>             bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// ZygotePreload</span><br>         &#125;<br><br>         <span class="hljs-comment">// 启动后进行初始gc清理</span><br>         bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;PostZygoteInitGC&quot;</span>);<br>         gcAndFinalize();<br>         bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// PostZygoteInitGC</span><br><br>         bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// ZygoteInit</span><br><br>         Zygote.initNativeState(isPrimaryZygote);<br><br>         ZygoteHooks.stopZygoteNoThreadCreation();<br><br>         <span class="hljs-comment">//创建ZygoteServer</span><br>         zygoteServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteServer</span>(isPrimaryZygote);<br><br>         <span class="hljs-keyword">if</span> (startSystemServer) &#123;<br>             <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> forkSystemServer(abiList, zygoteSocketName, zygoteServer);<br><br>             <span class="hljs-comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span><br>             <span class="hljs-comment">// child (system_server) process.</span><br>             <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>                 r.run();<br>                 <span class="hljs-keyword">return</span>;<br>             &#125;<br>         &#125;<br><br>         Log.i(TAG, <span class="hljs-string">&quot;Accepting command socket connections&quot;</span>);<br><br>         <span class="hljs-comment">// 启动一个死循环监听来自Client端的消息</span><br>         caller = zygoteServer.runSelectLoop(abiList);<br>     &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>         Log.e(TAG, <span class="hljs-string">&quot;System zygote died with exception&quot;</span>, ex);<br>         <span class="hljs-keyword">throw</span> ex;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-keyword">if</span> (zygoteServer != <span class="hljs-literal">null</span>) &#123;<br>             zygoteServer.closeServerSocket();<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-comment">// 我们在子进程中，已经退出选择循环。 继续执行命令 </span><br>     <span class="hljs-keyword">if</span> (caller != <span class="hljs-literal">null</span>) &#123;<br>         caller.run();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="attemptUsapSendArgsAndGetResult方法"><a href="#attemptUsapSendArgsAndGetResult方法" class="headerlink" title="attemptUsapSendArgsAndGetResult方法"></a>attemptUsapSendArgsAndGetResult方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">attemptUsapSendArgsAndGetResult</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            ZygoteState zygoteState, String msgStr)</span></span><br><span class="hljs-function">            throws ZygoteStartFailedEx, IOException </span>&#123;<br>        <span class="hljs-built_in">try</span> (LocalSocket usapSessionSocket = zygoteState.<span class="hljs-built_in">getUsapSessionSocket</span>()) &#123;<br>            <span class="hljs-keyword">final</span> BufferedWriter usapWriter =<br>                    <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedWriter</span>(<br>                            <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutputStreamWriter</span>(usapSessionSocket.<span class="hljs-built_in">getOutputStream</span>()),<br>                            Zygote.SOCKET_BUFFER_SIZE);<br>            <span class="hljs-keyword">final</span> DataInputStream usapReader =<br>                    <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataInputStream</span>(usapSessionSocket.<span class="hljs-built_in">getInputStream</span>());<br><br>            usapWriter.<span class="hljs-built_in">write</span>(msgStr);<br>            usapWriter.<span class="hljs-built_in">flush</span>();<br>            <span class="hljs-comment">//创建Process.ProcessStartResult用于存放fork进程的返回结果</span><br>            Process.ProcessStartResult result = <span class="hljs-keyword">new</span> Process.<span class="hljs-built_in">ProcessStartResult</span>();<br>            result.pid = usapReader.<span class="hljs-built_in">readInt</span>();<br>            <span class="hljs-comment">// USAPs can&#x27;t be used to spawn processes that need wrappers.</span><br>            result.usingWrapper = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span> (result.pid &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;USAP specialization failed&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>





<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/article/8b3b35/image-20210203235817212.png" alt="image-20210203235817212"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Zygote</tag>
      </tags>
  </entry>
  <entry>
    <title>abbrlink踩坑</title>
    <url>/article/856a5aa8/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>博客搭建有一段时间了，但是链接地址却和文件名紧紧绑定在一起，及其不方便扩展，也给写作带来些许不便。</p>
<p>于是乎，今天便想着来搞搞；为了生成永久链接，这里使用abbrlink这个插件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//局部安装</span><br>npm install hexo-abbrlink --save<br></code></pre></td></tr></table></figure>

<p>嗯哼~ 安装失败….再来</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">cnpm install hexo-abbrlink --save<br></code></pre></td></tr></table></figure>

<p>ok了，这里配置了镜像，还是cnpm好用；</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>继续，开始配置外部的 _config.yml </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">article/:abbrlink/</span>  <span class="hljs-comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span><br><span class="hljs-attr">abbrlink:</span><br>  <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span>   <span class="hljs-comment">#算法： crc16(default) and crc32</span><br>  <span class="hljs-attr">rep:</span> <span class="hljs-string">hex</span>     <span class="hljs-comment">#进制： dec(default) and hex</span><br>  <span class="hljs-attr">drafts:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#(true)Process draft,(false)Do not process draft. false(default) </span><br>  <span class="hljs-comment"># Generate categories from directory-tree</span><br>  <span class="hljs-comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br>  <span class="hljs-attr">auto_category:</span><br>     <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#true(default)</span><br>     <span class="hljs-attr">depth:</span>        <span class="hljs-comment">#3(default)</span><br>     <span class="hljs-attr">over_write:</span> <span class="hljs-literal">false</span> <br>  <span class="hljs-attr">auto_title:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable auto title, it can auto fill the title by path</span><br>  <span class="hljs-attr">auto_date:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable auto date, it can auto fill the date by time today</span><br>  <span class="hljs-attr">force:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span><br></code></pre></td></tr></table></figure>

<p>大家应该都看得懂了~</p>
<p>不过这里有个注意事项，auto_category 默认是true，这里我设置成false；下面是auto_category的源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> opt_AutoCategoryEnable = config.<span class="hljs-property">auto_category</span> &amp;&amp; config.<span class="hljs-property">auto_category</span>.<span class="hljs-property">enable</span>;<br><span class="hljs-keyword">var</span> overwrite = config.<span class="hljs-property">auto_category</span> &amp;&amp; config.<span class="hljs-property">auto_category</span>.<span class="hljs-property">over_write</span>;<br><span class="hljs-keyword">if</span> (opt_AutoCategoryEnable &amp;&amp; overwrite) &#123;<br>	<span class="hljs-keyword">var</span> categories = data.<span class="hljs-property">source</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>	<span class="hljs-keyword">var</span> opt_AutoCategoryDepth = config.<span class="hljs-property">auto_category</span>.<span class="hljs-property">depth</span> || <span class="hljs-number">3</span>;<br>	<span class="hljs-keyword">var</span> depth = opt_AutoCategoryDepth || categories.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (categories.<span class="hljs-property">length</span> - <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || depth == <span class="hljs-number">0</span>) &#123;<br>		tmpPost.<span class="hljs-property">categories</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">default_category</span>;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">var</span> newCategories = categories.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(depth, categories.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>));<br>		<span class="hljs-comment">//prevents duplicate file changes</span><br>		<span class="hljs-keyword">if</span> (<br>			!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(tmpPost.<span class="hljs-property">categories</span>) ||<br>			!tmpPost.<span class="hljs-property">categories</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;_&#x27;</span>) == newCategories.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;_&#x27;</span>)<br>		) &#123;<br>			tmpPost.<span class="hljs-property">categories</span> = newCategories;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来查看一下hexo-abbrlink的版本</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">npm view hexo-abbrlink versions --json<br></code></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">[<br>  <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;1.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;1.0.2&quot;</span>,<br>  <span class="hljs-string">&quot;1.0.3&quot;</span>,<br>  <span class="hljs-string">&quot;2.0.1&quot;</span>,<br>  <span class="hljs-string">&quot;2.0.2&quot;</span>,<br>  <span class="hljs-string">&quot;2.0.4&quot;</span>,<br>  <span class="hljs-string">&quot;2.0.5&quot;</span>,<br>  <span class="hljs-string">&quot;2.1.5&quot;</span>,<br>  <span class="hljs-string">&quot;2.1.6&quot;</span>,<br>  <span class="hljs-string">&quot;2.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;2.2.1&quot;</span><br>]<br></code></pre></td></tr></table></figure>

<p>默认安装的是最新版是2.2.1；</p>
<p>abbrlink 的原理是在每篇文章的属性里加上一个16位&#x2F;32位的十六进制的数，来作为文章唯一的id。具体内部实现依靠hexo-fs插件来进行写入生成；</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>在配置好以上内容之后，就可以开始执行生成索引了，这是最后一步了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo generate<br></code></pre></td></tr></table></figure>

<p>可执行了以上命令之后，情况又不妙了~</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">FATAL Something<span class="hljs-string">&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="hljs-string">Error: EEXIST: file already exists, mkdir &#x27;</span>F:\software2\MyGithubPage\hexo\source\_posts\Android<span class="hljs-string">&#x27;</span><br><span class="hljs-string">    at Object.mkdirSync (fs.js:729:3)</span><br><span class="hljs-string">    at Object.writeFileSync (F:\software2\MyGithubPage\hexo\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js:63:6)</span><br><span class="hljs-string">    at Hexo.logic (F:\software2\MyGithubPage\hexo\node_modules\_hexo-abbrlink@2.2.1@hexo-abbrlink\lib\logic.js:98:20)</span><br><span class="hljs-string">    at Hexo.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="hljs-string">    at Hexo.&lt;anonymous&gt; (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="hljs-string">    at Promise.each.filter (F:\software2\MyGithubPage\hexo\node_modules\hexo\lib\extend\filter.js:62:52)</span><br><span class="hljs-string">    at tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="hljs-string">    at Object.gotValue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:166:18)</span><br><span class="hljs-string">    at Object.gotAccum (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:155:25)</span><br><span class="hljs-string">    at Object.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="hljs-string">    at Promise._settlePromiseFromHandler (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:547:31)</span><br><span class="hljs-string">    at Promise._settlePromise (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:604:18)</span><br><span class="hljs-string">    at Promise._settlePromise0 (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:649:10)</span><br><span class="hljs-string">    at Promise._settlePromises (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:729:18)</span><br><span class="hljs-string">    at _drainQueueStep (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:93:12)</span><br><span class="hljs-string">    at _drainQueue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:86:9)</span><br><span class="hljs-string">    at Async._drainQueues (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:102:5)</span><br><span class="hljs-string">    at Immediate.Async.drainQueues [as _onImmediate] (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:15:14)</span><br><span class="hljs-string">    at runCallback (timers.js:693:18)</span><br><span class="hljs-string">    at tryOnImmediate (timers.js:664:5)</span><br><span class="hljs-string">    at processImmediate (timers.js:646:5)</span><br></code></pre></td></tr></table></figure>

<p>报了一堆堆栈日志，通过观察，我们可以看到程序是在执行了 logic.js 之后，接着执行 fs.js 报错的；文件已存在，程序还在强行创建!!!!</p>
<p>为了一探究竟，我们进入到logic.js 中看看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFileSync</span>(data.<span class="hljs-property">full_source</span>, postStr, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>程序是执行了这段代码导致的，如果abbrlink不存在的话，该插件会遍历文件夹中的文件进行写入，然后创建新的文件夹；继续追，查看下package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;hexo-front-matter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hexo-fs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.1.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure>

<p>依赖的最新的fs是3.1。进入hexo-js中，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">writeFileSync</span>(<span class="hljs-params">path, data, options</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!path) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;path is required!&#x27;</span>);<br><br>  fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-title function_">dirname</span>(path), &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br>  fs.<span class="hljs-title function_">writeFileSync</span>(path, data, options);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>好家伙，直接就创建了，都不检查下的吗？？</p>
<h2 id="手动修改hexo-fs"><a href="#手动修改hexo-fs" class="headerlink" title="手动修改hexo-fs"></a>手动修改hexo-fs</h2><p>路径：<code>\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js</code>  文件</p>
<p>在文件中添加以下函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkParentSync</span>(<span class="hljs-params">path</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!path) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;path is required!&#x27;</span>);<br><br>  <span class="hljs-keyword">var</span> parent = <span class="hljs-title function_">dirname</span>(path);<br>  <span class="hljs-keyword">var</span> exist = fs.<span class="hljs-title function_">existsSync</span>(parent);<br><br>  <span class="hljs-keyword">if</span> (exist) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">mkdirsSync</span>(parent);<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> !== <span class="hljs-string">&#x27;EEXIST&#x27;</span>) <span class="hljs-keyword">throw</span> err;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将fs.mkdirSync 注释掉，增加 checkParentSync(path);  的调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//fs.mkdirSync(dirname(path), &#123; recursive: true &#125;);</span><br><span class="hljs-title function_">checkParentSync</span>(path);<br></code></pre></td></tr></table></figure>



<p>最后，大功告成~:happy:</p>
]]></content>
      <categories>
        <category>踩坑日记</category>
      </categories>
      <tags>
        <tag>abbrlink</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/article/7cab1e06/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 二叉树;<br><br><span class="hljs-keyword">import</span> utils.Node;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> class 二叉搜索树 &#123;<br>    <span class="hljs-comment">//    是否有效的二叉搜索树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.data &lt;= minVal || node.data &gt;= maxVal) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isValidBST(node.left, minVal, node.data)<br>                &amp;&amp; isValidBST(node.right, node.data, maxVal);<br>    &#125;<br><br>    <span class="hljs-comment">//    打印二叉树每层节点;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTreeBFS</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>            LinkedList&lt;Integer&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                linkedList.add(node.data);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(linkedList);<br>        &#125;<br>        System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[] &#123;res&#125;));<br>    &#125;<br><br>    <span class="hljs-comment">//    之字形打印二叉树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTreeBFS_zhi</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>            LinkedList&lt;Integer&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    linkedList.addLast(node.data);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    linkedList.addFirst(node.data);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(linkedList);<br>        &#125;<br>        System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[] &#123;res&#125;));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; list, Node root, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (height &gt;= list.size()) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        &#125;<br>        List&lt;Integer&gt; temp = list.get(height);<br>        temp.add(root.data);<br>        dfs(list, root.left, height + <span class="hljs-number">1</span>);<br>        dfs(list, root.right, height + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//    打印二叉树每层节点;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTreeDFS</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        dfs(list, root, <span class="hljs-number">0</span>);<br>        System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[] &#123;list&#125;));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-comment">//    任意方式创建二叉搜索树</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">insertSearchTree</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &lt; root.data) &#123;<br>            root.left = insertSearchTree(root.left, val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root.data) &#123;<br>            root.right = insertSearchTree(root.right, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">//    搜索二叉树遍历</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchTree</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (val == temp.data) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; temp.data) &#123;<br>                temp = temp.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp = temp.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树非递归遍历</title>
    <url>/article/1062d183/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历_非递归"></a>前序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 前序遍历_非递归 &#123;<br>    <span class="hljs-comment">//    非递归</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pre</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.add(root);<br>        <span class="hljs-keyword">while</span> (!list.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stack.add(root);<br>                list.add(root.data);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                root = stack.pop().right;<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[] &#123;list&#125;));<br>    &#125;<br>    <span class="hljs-comment">// 更简洁的方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pre2</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.add(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            list.add(node.data);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.add(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.add(node.left);<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[] &#123;list&#125;));<br>    &#125;<br></code></pre></td></tr></table></figure>





<h2 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历_非递归"></a>中序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mid</span><span class="hljs-params">(Node root)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            stack.add(root);<br>            root = root.left;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>        list.add(node.data);<br>        root=node.right;<br>    &#125;<br>    System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[] &#123;list&#125;));<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历_非递归"></a>后序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 后序遍历_非递归 &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">last</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            root = stack.pop();<br>            list.add(<span class="hljs-number">0</span>, root.data);<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) stack.push(root.left);<br>            <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) stack.push(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础操作</title>
    <url>/article/bb06284f/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="二叉树基础操作"><a href="#二叉树基础操作" class="headerlink" title="二叉树基础操作"></a>二叉树基础操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 二叉树;<br><br><span class="hljs-keyword">import</span> utils.Node;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> class 二叉树基础操作 &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">422</span>&#125;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] a2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<span class="hljs-number">32</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">55</span>, <span class="hljs-number">64</span>&#125;;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsSearch</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root, res, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; re : res) &#123;<br>            System.out.println(Arrays.toString(re.toArray()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node node, List&lt;List&lt;Integer&gt;&gt; res, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (height == res.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        res.get(height).add(node.data);<br>        dfs(node.left, res, height + <span class="hljs-number">1</span>);<br>        dfs(node.right, res, height + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfsSearch</span><span class="hljs-params">(Node tree)</span>&#123;<br>        List&lt;List&lt;Integer&gt;&gt; res= bfs(tree);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; re : res) &#123;<br>            System.out.println(Arrays.toString(re.toArray()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">bfs</span><span class="hljs-params">(Node root)</span>&#123;<br>        List&lt;List&lt;Integer&gt;&gt;res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;Node&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            List&lt;Integer&gt;list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> size=queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                Node node= queue.poll();<br>                <span class="hljs-keyword">assert</span> node != <span class="hljs-literal">null</span>;<br>                list.add(node.data);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(node.right);<br>                &#125;<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">createTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;<br>            insert(root, a[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (data &lt;= node.data) &#123;<br>            node.left= insert(node.left, data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.right= insert(node.right, data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(node.data);<br>        printTree(node.left);<br>        printTree(node.right);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invert</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>( node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node temp=node.left;<br>        node.left=node.right;<br>        node.right=temp;<br>        invert(node.left);<br>        invert(node.right);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchMax</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        &#125;<br>        <span class="hljs-type">int</span> left=searchMax(node.left);<br>        <span class="hljs-type">int</span> right= searchMax(node.right);<br>        <span class="hljs-keyword">return</span> Math.max(node.data,Math.max(left,right));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDeep</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left=maxDeep(node.left);<br>        <span class="hljs-type">int</span> right=maxDeep(node.right);<br>        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalance</span><span class="hljs-params">(Node node)</span>&#123;<br>         <span class="hljs-keyword">return</span> balance(node)!=-<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">balance</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left=balance(node.left);<br>        <span class="hljs-type">int</span> right=balance(node.right);<br>        <span class="hljs-keyword">if</span>(left==-<span class="hljs-number">1</span>||right==-<span class="hljs-number">1</span>||Math.abs(left-right)&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> createTree(a2);<br>        printTree(tree);<br>        dfsSearch(tree);<br>        bfsSearch(tree);<br>        invert(tree);<br>        bfsSearch(tree);<br>        System.out.println(searchMax(tree));<br>        System.out.println(maxDeep(tree));<br>        System.out.println(isBalance(tree));<br>        <span class="hljs-comment">//        System.out.println(Arrays.toString(qsort(arr, 0, arr.length - 1)));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者模式</title>
    <url>/article/e6c2b842/</url>
    <content><![CDATA[<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>通过使用CountDownLatch 来模拟并发场景，用synchronized来进行多线程间的同步，保障线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main1</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">final</span> LinkedBlockingQueue&lt;String&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    countDownLatch.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">while</span> (link.size() == full) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    link.add(Thread.currentThread().getName() + <span class="hljs-string">&quot; product: &quot;</span> + count);<br>                    count++;<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    countDownLatch.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">while</span> (link.size() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; consumer: &quot;</span> + link.poll());<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadNum; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">pThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(product);<br>            pThread.start();<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">cThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(consumer);<br>            cThread.start();<br>        &#125;<br>        countDownLatch.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="/article/e6c2b842/image-20210306193021365.png" alt="image-20210306193021365"></p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>采用重入锁（ReentrantLock）机制来实现，使用了两个Condition，分别控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>        <span class="hljs-keyword">final</span> LinkedBlockingQueue&lt;String&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    countDownLatch.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (link.size() == full) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            notFull.await();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    link.add(Thread.currentThread().getName() + <span class="hljs-string">&quot; product: &quot;</span> + count);<br>                    count++;<br>                    notEmpty.signal();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    countDownLatch.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (link.size() == <span class="hljs-number">0</span>) &#123;<br>                        notEmpty.await();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; consumer: &quot;</span> + link.poll());<br>                    notFull.signal();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadNum; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">pThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(product);<br>            pThread.start();<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">cThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(consumer);<br>            cThread.start();<br>        &#125;<br>        countDownLatch.countDown();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>输出</p>
<p><img src="/article/e6c2b842/image-20210306193529183.png" alt="image-20210306193529183"></p>
<p>当然除了以上两种方式之外，还可以用Semaphore 共享锁机制来实现以及阻塞队列的take方法，感兴趣的可以去实现一下。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>生产者与消费者</tag>
      </tags>
  </entry>
  <entry>
    <title>算法稳定性介绍</title>
    <url>/article/a0d5c7de/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="不稳定排序算法"><a href="#不稳定排序算法" class="headerlink" title="不稳定排序算法"></a>不稳定排序算法</h3><ol>
<li>选择排序 — O(n²)</li>
<li>希尔排序 — O(nlogn)</li>
<li>堆排序 — O(nlogn)</li>
<li>快速排序 — O(nlogn) 期望时间,O(n²) 最坏情况;</li>
</ol>
<br/>

<h3 id="稳定排序算法"><a href="#稳定排序算法" class="headerlink" title="稳定排序算法"></a>稳定排序算法</h3><ol>
<li>冒泡排序  — O(n²)</li>
<li>插入排序 — O(n²)</li>
<li>桶排序 — O(n); 需要 O(k)额外空间</li>
<li>计数排序  — O(n+k); 需要O(n+k) 额外空间</li>
<li>合并排序  — O(nlogn); 需要O(n) 额外空间</li>
<li>二叉排序树排序   —O(n log n) 期望时间; O(n²)最坏时间; 需要O(n) 额外空间</li>
<li>基数排序  —O(n·k); 需要O(n) 额外空间</li>
</ol>
<h2 id="快排code"><a href="#快排code" class="headerlink" title="快排code"></a>快排code</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] qSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> arr[s], i = s, j = e;<br>    <span class="hljs-keyword">while</span> (i&lt;j) &#123;<br>        <span class="hljs-keyword">while</span> ((i&lt;j)&amp;&amp;(arr[j]&gt;p)) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ((i&lt;j)&amp;&amp;(arr[i]&lt;p)) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((arr[i]==arr[j])&amp;&amp;(i&lt;j)) &#123;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s&lt;i-<span class="hljs-number">1</span>) arr=qSort(arr,s,i-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span>&lt;e) arr=qSort(arr,j+<span class="hljs-number">1</span>,e);<br>    <span class="hljs-keyword">return</span> (arr);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>&#125;;<br>    arr=qSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i:arr) &#123;<br>        System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>几个经典的动态规划问题</title>
    <url>/article/b2b6f046/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="硬币找零"><a href="#硬币找零" class="headerlink" title="硬币找零"></a>硬币找零</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        Arrays.fill(a,Integer.MAX_VALUE);<br>        a[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : v) &#123;<br>                <span class="hljs-keyword">if</span> (i &lt; value) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                a[i] = Math.min(a[i], a[i - value] + <span class="hljs-number">1</span>);<br>            &#125;<br>            System.out.println(i+ <span class="hljs-string">&quot; : &quot;</span>+a[i]);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Arrays.fill(dp, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[i]) &#123;<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        res = Math.max(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, anchor = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; a[i - <span class="hljs-number">1</span>] &gt;= a[i]) &#123;<br>            anchor = i;<br>        &#125;<br>        ans = Math.max(ans, i - anchor + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">char</span>[] b)</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length + <span class="hljs-number">1</span>][b.length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= a.length; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= b.length; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= a.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= b.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    System.out.println(dp[a.length][b.length]);<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/article/71c610d3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表创建"><a href="#单链表创建" class="headerlink" title="单链表创建"></a>单链表创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Node <span class="hljs-title function_">SingleNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a.length &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;<br>        cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a[i]);<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="单链表逆序输出"><a href="#单链表逆序输出" class="headerlink" title="单链表逆序输出"></a>单链表逆序输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Node <span class="hljs-title function_">f</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node node=f(head.next);<br>    System.out.print(head.data + <span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p>链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Node <span class="hljs-title function_">f2</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node node=f2(head.next);<br>    head.next.next=head;<br>    head.next=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br>head=f2(head);<br></code></pre></td></tr></table></figure>



<h3 id="逆序输出并未反转"><a href="#逆序输出并未反转" class="headerlink" title="逆序输出并未反转"></a>逆序输出并未反转</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Node <span class="hljs-title function_">f</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    Node node=f(head.next);<br>    System.out.print(head.data + <span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br>f(head);<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaPoet讲解</title>
    <url>/article/fa8ccf2d/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="JavaPoet"><a href="#JavaPoet" class="headerlink" title="JavaPoet"></a>JavaPoet</h2><p>JavaPoet是Square推出的开源Java代码生成框架，提供Java Api生成.java源文件。通过这个框架可以很方便的使用它根据注解、数据库模式、协议格式等来对应生成代码。用这种自动化生产代码的方式可以来替换冗杂重复的工作，提高工作效率。</p>
<p>代码生成技术相当于元编程，可用于编译期根据注解等元数据动态生成Java类。在框架Dagger、ButterKnife等等中就是利用JavaPoet注解的方式实现生成所需的类。</p>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ul>
<li>JavaFile：用于构造输出包含一个顶级类的Java文件，是对.java文件的抽象；</li>
<li>TypeSpec：TypeSpec是类&#x2F;接口&#x2F;枚举的抽象；</li>
<li>MethodSpec：MethodSpec是方法&#x2F;构造函数的抽象；</li>
<li>FieldSpec：FieldSpec是成员变量&#x2F;字段的抽象；</li>
<li>ParameterSpec：ParameterSpec用于创建参数；</li>
<li>AnnotationSpec：AnnotationSpec用于创建注解；</li>
<li>TypeName：类型；</li>
<li>ClassName：用来包装一个类；</li>
</ul>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul>
<li>$L     参数，方法中的参数；</li>
<li>$S     字符串，和String.format中%s一样；</li>
<li>$N     方法或变量的名称，我们自己生成的方法名或者变量名等等；</li>
<li>$T     类型名，指的是TypeName，该模板主要将Class抽象出来，用传入的TypeName指向的Class来代替；</li>
</ul>
<p>设置方法抛出异常,可以使用addException方法,传入指定的异常的ClassName,即可为该方法设置其抛出该异常.</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">compileOnly <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc4&#x27;</span><br>annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc4&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.12.1&#x27;</span><br></code></pre></td></tr></table></figure>

<p>一般情况下，还需要配合注解解释器来使用才行，一般我们常用的或注解解释器为 AutoService 和 gradle-incap-helper。</p>
<h4 id="自定义处理器"><a href="#自定义处理器" class="headerlink" title="自定义处理器"></a>自定义处理器</h4><p>注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以自定义注解，并注册相应的注解处理器（自定义的注解处理器需继承自AbstractProcessor）。</p>
<p>注意：注解处理器是运行在独立的虚拟机JVM中，javac启动一个完整Java虚拟机来运行注解处理器。</p>
<h5 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h5><ul>
<li>init(ProcessingEnvironment env): 初始化方法，会被注解处理器调用，可以从ProcessingEnviroment对象中获取到如Elements, Types,Messager和Filer等工具类；</li>
<li>process(Set&lt; ? extends TypeElement&gt; annotations, RoundEnvironment env): 真正的处理方法，也是核心的方法。在这里写如何处理注解的代码，以及生成的java文件需要存放的位置。参数RoundEnviroment可以查询出包含特定注解的被注解元素。</li>
<li>getSupportedAnnotationTypes(): 指定注解处理器是注册给哪个注解的。返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</li>
<li>getSupportedSourceVersion(): 用来指定你使用的Java版本。通常返回SourceVersion.latestSupported()。</li>
</ul>
<p>技巧：后面两个方法还有另一种写法（通过注解给定）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(&#123;Constants.BINDERVIEW_ANNOTATION_TYPES&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br></code></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-meta">@SupportedAnnotationTypes(Constant.ANY_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><span class="hljs-keyword">private</span> Filer filer; <br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>    filer = processingEnvironment.getFiler();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>    <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;main&quot;</span>)<br>            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)<br>            .returns(<span class="hljs-keyword">void</span>.class)<br>            .addParameter(String[].class, <span class="hljs-string">&quot;args&quot;</span>)<br>            .addStatement(<span class="hljs-string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="hljs-string">&quot;Hello, JavaPoet!&quot;</span>)<br>            .build();<br><br>    <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)<br>            .addMethod(main)<br>            .build();<br><br>    <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.example.helloworld&quot;</span>, helloWorld).build();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        javaFile.writeTo(filer);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> SourceVersion.RELEASE_7;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedAnnotationTypes();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="kapt和transform的差别"><a href="#kapt和transform的差别" class="headerlink" title="kapt和transform的差别"></a>kapt和transform的差别</h4><p>AbstractProcessor只能处理注解，然后根据注解通过javapoet生成一个新的java类。而transfrom则是通过gradle插件的transfrom方法，对.class文件做的修改。</p>
<p>AbstractProcessor是一个抽象类，它的父类是Processer。Processor会在编译阶段初始化，然后对当前模块内的代码进行一次扫描，然后获取到对应的注解，之后调用process方法，然后我们根据这些注解类来做一些后续操作。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>source(源代码) -&gt; processor（处理器） -&gt; generate （文件生成）-&gt; javacompiler -&gt; .class文件 -&gt; .dex(只针对安卓)。</p>
<p><em>官方链接：https://github.com/square/javapoet</em></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>JavaPoet</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发编程-ThreadLocal</title>
    <url>/article/b0029a08/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    threadLocal.set(<span class="hljs-number">2020</span>);<br>    System.out.println(<span class="hljs-string">&quot;parent-thread-s:&quot;</span> + threadLocal.get());<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;child-thread-s:&quot;</span> + threadLocal.get());<br>            threadLocal.set(<span class="hljs-number">2021</span>);<br>            System.out.println(<span class="hljs-string">&quot;child-thread-e:&quot;</span> + threadLocal.get());<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    System.out.println(<span class="hljs-string">&quot;parent-thread-e:&quot;</span> + threadLocal.get());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">parent-thread-s:<span class="hljs-number">2020</span><br>parent-thread-e:<span class="hljs-number">2020</span><br>child-thread-s:<span class="hljs-literal">null</span><br>child-thread-e:<span class="hljs-number">2021</span><br><br>Process finished <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>有利必有弊，虽然解决了上面说到的问题，但是每个线程都创建了变量副本，这时就要考虑它对资源的消耗，使用ThreadLocal时占用的内存资源肯定是会比没有使用的时占用的多。</p>
<p>在之前的文章有提到synchronized，同样是解决线程安全的，那么他俩到底有啥区别呢？</p>
<p> synchronized，采用的是阻塞的方式，让线程等待，保证有序进行访问；不占用其他资源，可以说是采用了时间换取空间的策略；而ThreadLocal和线程同步机制相比较，恰好相反，它采用的是以空间换取时间的策略。</p>
<p>下面来看下ThreadLocal的源码</p>
<h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中可以看到，一个线程中的多个ThreadLocal是通过该线程的ThreadLocalMap来管理的；也就是说，每个线程都维护有一个ThreadLocalMap。当在线程中使用来自其他线程的ThreadLocal时，在set的时候，是在根据线程名查找自己线程中是否有ThreadLocalMap，若没有则创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="ThreadLocalMap构造函数"><a href="#ThreadLocalMap构造函数" class="headerlink" title="ThreadLocalMap构造函数"></a>ThreadLocalMap构造函数</h3><p>ThreadLocalMap是ThreadLocal的一个静态内部类，一个简单的Map结构，阈值为16*2&#x2F;3,底层为数组，数组元素为Entry，Entry采用的是弱引用的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Entry持有ThreadLocal的弱引用，而table属于ThreadLocalMap，因而，ThreadLocalMap的key采用对ThreadLocal的弱引用。弱引用的生命周期短语软引用，远短于强引用，因此，还需注意垃圾回收的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The table, resized as necessary.</span><br><span class="hljs-comment"> * table.length MUST always be a power of two.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry[] table;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法先是获取到当前线程的ThreadLocalMap，再根据ThreadLocal这个key来获取值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据hashcode值来进行获取数组中对应的Entry对象元素；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>                <span class="hljs-keyword">return</span> e;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>如果没有获取到，那么用线性碰撞的方式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该位置置空，再哈希；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br>                <span class="hljs-comment">// null because multiple entries could have been stale.</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>移除的是当前线程中ThreadLocalMap对应的ThreadLocal  key值，解除弱引用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>        m.remove(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();<br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响；</li>
<li>一个ThreadLocal对应着多个ThreadLocalMap，每个ThreadLocalMap对应着一个线程；</li>
<li>如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>对象深度拷贝</title>
    <url>/article/dcc2a71f/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>深度拷贝对象的方式有很多，有基于构造函数的，也有借助第三方库的，这里介绍两种常见的方式</p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>基于Cloneable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNa</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> na;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNa</span><span class="hljs-params">(String na)</span> &#123;<br>        <span class="hljs-built_in">this</span>.na = na;<br>    &#125;<br><br>    String na;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">K</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            k = (K) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br>    String name;<br>    <span class="hljs-type">K</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">K</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">F</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> F <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">F</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f = (F) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">F</span>();<br>        f.k = f.k.clone();<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>采用字节流的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> F <span class="hljs-title function_">copy</span><span class="hljs-params">(F f)</span> &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        ObjectOutputStream oos;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bao);<br>            oos.writeObject(f);<br>            oos.close();<br>            <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bao.toByteArray());<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>            obj = ois.readObject();<br>            ois.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (F) obj;<br>    &#125;<br></code></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>对象拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具类的使用</title>
    <url>/article/22df6896/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常见的并发工具类有这几个：CountDownLatch，CyclicBarrier，Semaphore。除此之外，还有一个不常用的线程同步器类Exchanger。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个同步计数器，当计数器等于0时，开始触发。</p>
<p>应用场景：</p>
<ul>
<li>让多个线程同时阻塞在某一位置， 等待信号到来，再同时继续执行，模拟并发场景；</li>
<li>让单个线程等待，合并多个线程结果；</li>
</ul>
<p>例子1：</p>
<p><img src="/article/22df6896/image-20210212152635201.png" alt="image-20210212152635201"></p>
<p>输出</p>
<p><img src="/article/22df6896/image-20210212152709098.png" alt="image-20210212152709098"></p>
<p>例子2:</p>
<p><img src="/article/22df6896/image-20210212153137792.png" alt="image-20210212153137792"></p>
<p>输出：</p>
<p><img src="/article/22df6896/image-20210212153211891.png" alt="image-20210212153211891"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>从countDown的源码中我们可以看到，CountDownLatch内部使用了共享模式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在构造函数中创建了Sync实例;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>    <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Sync继承于AbstractQueuedSynchronizer，在构造方法中将计数器 通过setState方法设置下去了，最终给到了state变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;<br><br>    Sync(<span class="hljs-type">int</span> count) &#123;<br>        setState(count);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>CountDownLatch有个注意事项，当计数器减到0后，便不可以再次使用，需要再次new一个CountDownLatch实例对象。若要强制使用，则需要修改源码，将state值进行重置。此外，有另一个类也实现了CountDownLatch类似的功能，并且是可以重用，那就是CyclicBarrier。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。</p>
<p>例子：</p>
<p><img src="/article/22df6896/image-20210212160846010.png" alt="image-20210212160846010"></p>
<p>输出：</p>
<p><img src="/article/22df6896/image-20210212160910543.png" alt="image-20210212160910543"></p>
<p>通过例子，可以看出，CyclicBarrier的效果是和CountDownLatch一致的。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>           TimeoutException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br><br>        <span class="hljs-keyword">if</span> (g.broken)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            breakBarrier();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                    command.run();<br>                ranAction = <span class="hljs-literal">true</span>;<br>                nextGeneration();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ranAction)<br>                    breakBarrier();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!timed)<br>                    trip.await();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                    nanos = trip.awaitNanos(nanos);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> ie;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// We&#x27;re about to finish waiting even if we had not</span><br>                    <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span><br>                    <span class="hljs-comment">// &quot;belong&quot; to subsequent execution.</span><br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-keyword">if</span> (g != generation)<br>                <span class="hljs-keyword">return</span> index;<br><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行wait操作时，会将count值进行自减一次，当减到0时，进行触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.parties = parties;<br>    <span class="hljs-built_in">this</span>.count = parties;<br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察其构造函数，可以发现，barrierAction是一个runnable对象，最终在触发的时候被调用了run方法，并没有交给子线程去做，说明还是在主线程中做的事情。</p>
<p>通过观察，我们发现在触发后执行了nextGeneration()方法，一探究竟，发现count值被复原了，这就是为什么CyclicBarrier可以重用的原因了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// signal completion of last generation</span><br>    trip.signalAll();<br>    <span class="hljs-comment">// set up next generation</span><br>    count = parties;<br>    generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了CyclicBarrier之外，还有一个和CyclicBarrier类似，且计数可变，那就是Phaser，后面介绍。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 信号量，用于控制在一段时间内，可并发访问执行的线程数量。控制访问特定资源的线程数目，底层依赖AQS的State。Semaphore 在计数器不为 0 的时候对线程就放行，当为0时，所有请求将被阻塞。</p>
<p>Semaphore 有两种模式，<strong>公平模式</strong> 和 <strong>非公平模式</strong> ，默认是非公平模式。</p>
<ul>
<li>公平模式就是调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li>非公平模式是抢占式的；</li>
</ul>
<p>Semaphore的应用场景</p>
<p>可以用来做对公共资源的流量限制，如数据库连接。</p>
<p>释放公共资源许可的时候，有两种方法，一个是release，直接释放；另一个是reducePermits，释放并减少总的许可数量。</p>
<p>例子：</p>
<p><img src="/article/22df6896/image-20210212163929797.png" alt="image-20210212163929797"></p>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>默认采用非公平锁；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2694183684443567898L</span>;<br><br>    NonfairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态内部类Sync继承AbstractQueuedSynchronizer；setState和getState对许可数进行设置和访问；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1192457210091910933L</span>;<br><br>    Sync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br>        setState(<span class="hljs-keyword">permits</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPermits</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState();<br>    &#125;<br> ...<br></code></pre></td></tr></table></figure>

<h3 id="reducePermits方法"><a href="#reducePermits方法" class="headerlink" title="reducePermits方法"></a>reducePermits方法</h3><p>reducePermits可以动态控制总的许可证数量；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reducePermits</span><span class="hljs-params">(<span class="hljs-type">int</span> reductions)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current - reductions;<br>        <span class="hljs-keyword">if</span> (next &gt; current) <span class="hljs-comment">// underflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Permit count underflow&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p>
<p>想要两个线程之间进行数据交换，必然存在一个交换的时间点，在代码中用exchange来标记交互数据的位置。当两个线程均执行到exchange点时，便开启线程间数据的交换。“交换”二字也客观说明了执行该动作的是至少是两个线程，成对出现。若一个线程到达交换的时间点，而另一个线程并未到达，则该线程进行等待另一个线程。</p>
<p>其应用场景主要有：遗传算法、多线程数据校对等。</p>
<p>例子：</p>
<p><img src="/article/22df6896/image-20210212041536863.png" alt="image-20210212041536863"></p>
<p>输出：</p>
<p><img src="/article/22df6896/image-20210212041847191.png" alt="image-20210212041847191"></p>
<p>注意事项，在多个线程中（大于两个）使用同一个exchange，导致的结果随机选择到达交换时间点的线程进行信息交换，主要影响因素是CPU的线程调度；</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Exchanger</span><span class="hljs-params">()</span> &#123;<br>    participant = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Participant</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Participant</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Node&gt; &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a>exchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">exchange</span><span class="hljs-params">(V x, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException &#123;<br>    Object v;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> (x == <span class="hljs-literal">null</span>) ? NULL_ITEM : x;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ns</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-keyword">if</span> ((arena != <span class="hljs-literal">null</span> ||<br>         (v = slotExchange(item, <span class="hljs-literal">true</span>, ns)) == <span class="hljs-literal">null</span>) &amp;&amp;<br>        ((Thread.interrupted() ||<br>          (v = arenaExchange(item, <span class="hljs-literal">true</span>, ns)) == <span class="hljs-literal">null</span>)))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">if</span> (v == TIMED_OUT)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>    <span class="hljs-keyword">return</span> (v == NULL_ITEM) ? <span class="hljs-literal">null</span> : (V)v;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="slotExchange方法"><a href="#slotExchange方法" class="headerlink" title="slotExchange方法"></a>slotExchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">slotExchange</span><span class="hljs-params">(Object item, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> ns)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> participant.get();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-keyword">if</span> (t.isInterrupted()) <span class="hljs-comment">// preserve interrupt status so caller can recheck</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">for</span> (Node q;;) &#123;<br>        <span class="hljs-keyword">if</span> ((q = slot) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//进行自旋</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapObject(<span class="hljs-built_in">this</span>, SLOT, q, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> q.item;<br>                q.match = item;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> q.parked;<br>                <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>                    U.unpark(w);<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>            <span class="hljs-comment">// create arena on contention, but continue until slot null</span><br>            <span class="hljs-keyword">if</span> (NCPU &gt; <span class="hljs-number">1</span> &amp;&amp; bound == <span class="hljs-number">0</span> &amp;&amp;<br>                U.compareAndSwapInt(<span class="hljs-built_in">this</span>, BOUND, <span class="hljs-number">0</span>, SEQ))<br>                arena = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[(FULL + <span class="hljs-number">2</span>) &lt;&lt; ASHIFT];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arena != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// caller must reroute to arenaExchange</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            p.item = item;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapObject(<span class="hljs-built_in">this</span>, SLOT, <span class="hljs-literal">null</span>, p))<br>                <span class="hljs-keyword">break</span>;<br>            p.item = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// await release</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> p.hash;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + ns : <span class="hljs-number">0L</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> (NCPU &gt; <span class="hljs-number">1</span>) ? SPINS : <span class="hljs-number">1</span>;<br>    Object v;<br>    <span class="hljs-keyword">while</span> ((v = p.match) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>) &#123;<br>            h ^= h &lt;&lt; <span class="hljs-number">1</span>; h ^= h &gt;&gt;&gt; <span class="hljs-number">3</span>; h ^= h &lt;&lt; <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span>)<br>                h = SPINS | (<span class="hljs-type">int</span>)t.getId();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>                Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slot != p)<br>            spins = SPINS;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="hljs-literal">null</span> &amp;&amp;<br>                 (!timed || (ns = end - System.nanoTime()) &gt; <span class="hljs-number">0L</span>)) &#123;<br>            U.putObject(t, BLOCKER, <span class="hljs-built_in">this</span>);<br>            p.parked = t;<br>            <span class="hljs-keyword">if</span> (slot == p)<br>                U.park(<span class="hljs-literal">false</span>, ns);<br>            p.parked = <span class="hljs-literal">null</span>;<br>            U.putObject(t, BLOCKER, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapObject(<span class="hljs-built_in">this</span>, SLOT, p, <span class="hljs-literal">null</span>)) &#123;<br>            v = timed &amp;&amp; ns &lt;= <span class="hljs-number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    U.putOrderedObject(p, MATCH, <span class="hljs-literal">null</span>);<br>    p.item = <span class="hljs-literal">null</span>;<br>    p.hash = h;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一个线程到达交换时间点后，进行自选操作，等待另一个线程进行值交换；如果等待时间超时了，那么抛出超时的中断异常。</p>
<p>总之，每个工具类都有自己的优势和劣势，在实际开发场景中，还应根据它们的优缺点进行合适的选择。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
        <tag>Semaphore</tag>
        <tag>Exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>线程模型&amp;线程池</title>
    <url>/article/a6b81681/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h2><ul>
<li>内核级线程模型</li>
<li>用户级线程模型</li>
<li>混合型线程模型</li>
</ul>
<h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>用户线程与内核线程是1对1关系。</p>
<p>优点：该模型在一个线程执行阻塞系统调用时，能够允许另一个线程继续执行，允许多个线程并行运行在多处理器系统上。</p>
<p>缺点：创建一个用户线程就要创建一个相应的内核线程。为了提升性能，大多数实现限制了系统支持的线程数量。</p>
<p>应用：Linux、Windows 操作系统都实现了一对一模型。</p>
<h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户线程与内核线程是多对1关系。映射多个用户级线程到一个内核线程。</p>
<p>优点：线程管理是由用户空间的线程库来完成的，因此效率更高。</p>
<p>缺点：如果一个线程执行阻塞系统调用，那么整个进程将会阻塞。再者，因为任一时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上。</p>
<p>应用：现在几乎没有系统继续使用这个模型，因为它无法利用多个处理核。</p>
<h3 id="混合型线程模型"><a href="#混合型线程模型" class="headerlink" title="混合型线程模型"></a>混合型线程模型</h3><p>用户线程与内核线程是多对多关系。</p>
<p>优点：开发人员可以创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。而且，当一个线程执行阻塞系统调用时，内核可以调度另一个线程来执行；</p>
<p>缺点：这种动态关联机制的实现很复杂，也需要用户自己去实现；</p>
<p>应用：Go语言中的并发就是使用的这种实现方式。</p>
<h2 id="线程生命状态"><a href="#线程生命状态" class="headerlink" title="线程生命状态"></a>线程生命状态</h2><ul>
<li><strong>NEW</strong> ，新建</li>
<li><strong>RUNNABLE</strong> ，运行</li>
<li><strong>BLOCKED</strong> ，阻塞</li>
<li><strong>WAITING</strong> ，等待</li>
<li><strong>TIMED_WAITING</strong> ，超时等待</li>
<li><strong>TERMINATED</strong>，终结</li>
</ul>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>使用ExecutorService线程池</li>
</ul>
<blockquote>
<p>注意：其中前两种方式线程执行完后都没有返回值，<strong>后两种是带返回值</strong>的。</p>
</blockquote>
<p>例子</p>
<p><img src="/image-20210221163248651.png" alt="image-20210221163248651"></p>
<p><img src="/image-20210221163431129.png" alt="image-20210221163431129"></p>
<p>输出：</p>
<p><img src="/image-20210221163506027.png" alt="image-20210221163506027"></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>默认线程池：ThreadPoolExecutor </li>
<li>定时线程池：ScheduledThreadPoolExecutor</li>
</ul>
<h3 id="五种线程池创建类型"><a href="#五种线程池创建类型" class="headerlink" title="五种线程池创建类型"></a>五种线程池创建类型</h3><ul>
<li><p>newFixedThreadPool（<strong>固定大小线程池</strong>）</p>
</li>
<li><p>newSingleThreadExecutor(<strong>单个后台线程</strong>）</p>
</li>
<li><p>newCachedThreadPool（<strong>无界线程池，可以进行自动线程回收</strong>）</p>
</li>
<li><p>newScheduledThreadPool (<strong>可调度</strong>)</p>
</li>
</ul>
<p>​      创建一个定长线程池，支持<strong>定时及周期性任务执行</strong>。和 其他线程池最大的区别是使用的阻塞队列是 <strong>DelayedWorkQueue</strong>，而且多了两个定时执行的方法scheduleAtFixedRate和scheduleWithFixedDelay</p>
<ul>
<li>newWorkStealingPool（<strong>并行操作</strong>）</li>
</ul>
<p>​     JDK1.8新增newWorkStealingPool，适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类<strong>ForkJoinPool</strong>的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很<strong>耗时</strong>的任务中。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池原理</title>
    <url>/article/335c74d5/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>优点：</p>
<ul>
<li>能够实现复用</li>
<li>线程统一管理</li>
</ul>
<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>提交任务》核心线程是否已满》阻塞队里是否已满》线程池是否已满》拒绝策略</strong></p>
<p>拒绝策略</p>
<p><code>AbortPolicy</code>： 直接拒绝所提交的任务，并抛出<code>RejectedExecutionException</code>异常。</p>
<p><code>CallerRunsPolicy</code>：只用调用者所在的线程来执行任务。</p>
<p><code>DiscardPolicy</code>：不处理直接丢弃掉任务。</p>
<p><code>DiscardOldestPolicy</code>：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。</p>
<h3 id="延时任务与定时任务"><a href="#延时任务与定时任务" class="headerlink" title="延时任务与定时任务"></a>延时任务与定时任务</h3><p>线程池可以处理延时任务，设置延迟时间执行任务</p>
<p>通过execute执行<strong>无返回值</strong>，而submit提交则有<strong>Future的返回值</strong>，其中get方法可以设置timeout时间，若deadline到达，还没有get到结果，则抛出异常。通过这个方法可以处理定时任务。但是值得注意的是，<strong>该方法会直接阻塞get所在线程！！</strong>若是在主线程中直接引起ui卡住，长时间超过5s则ANR。若想不卡主线程，而设置定时任务可以<strong>采用timer方式</strong>，除了这种方式外还可以采用<strong>开启守护线程</strong>方式来解决。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当需要频繁创建线程来执行任务的时候</p>
<p>需要延迟执行任务</p>
<p>多线程&amp;多任务场景以及单线程场景</p>
<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>例如协程。协程（kotlin）的执行环境也是线程池的应用之一。当在主线程中使用协程提交任务，<strong>这些任务会被调度到线程池的各个线程中</strong>，虽然不在同一个线程，但是能够保证一定的执行顺序。通过自定义协程调度器可以设置其执行的指定线程池。总的来说，依靠的还是线程池。</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadExecutorDispatcher</span><br>    : AbstractCoroutineContextElement(ContinuationInterceptor),<br>        ContinuationInterceptor &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> executorService = Executors.newSingleThreadExecutor &#123;<br>        Thread(it, <span class="hljs-string">&quot;SingleThreadExecutor&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">return</span> MyContinuation(continuation)<br>    &#125;<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContinuation</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> origin: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = origin.context<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            executorService.submit &#123;<br>                origin.resumeWith(result)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;<br>        executorService.shutdown()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> dispatcher = SingleThreadExecutorDispatcher()<br>    log(<span class="hljs-string">&quot;AA&quot;</span>)<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch(dispatcher) &#123;<br>        delay(<span class="hljs-number">100</span>)<br>        log(<span class="hljs-string">&quot;BB&quot;</span>)<br>    &#125;<br>    job.join()<br>    dispatcher.close()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">main</span>] AA<br>[<span class="hljs-meta">SingleThreadExecutor</span>] BB<br><br>Process finished <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle命令</title>
    <url>/article/dda7bba2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="gradlew-命令详解"><a href="#gradlew-命令详解" class="headerlink" title="gradlew 命令详解"></a>gradlew 命令详解</h2><p>gradlew tasks –all：查看所有任务，包括缓存任务等；</p>
<p>gradlew clean：清除工程目录下的build文件夹；</p>
<p>gradlew build： 检查依赖并编译打包，debug、release环境的包都会打出来；</p>
<p>gradlew assemble：编译指定的包：如Debug包（gradlew assembleDebug）、Release包（gradlew assembleRelease）、渠道包（gradlew assembleOemRelease&#x2F;assembleOemDebug）、定制的版本等等；</p>
<p>gradlew install：编译并安装指定的包。如Debug包（gradlew installDebug）、Release包（gradlew installOemRelease&#x2F;installOemDebug）、定制的版本等等；</p>
<p>gradlew uninstall：卸载已安装的指定模式的包：如Debug包（gradlew uninstallDebug）、Release包（gradlew uninstallRelease）、渠道包（gradlew uninstallOemRelease&#x2F;uninstallOemDebug）、定制的版本等等；</p>
<p>gradlew :模块名称:dependencies   ，如gradlew :app:dependencies，作用：查看包依赖关系；</p>
<p>gradlew build -i&#x2F;–info -d&#x2F;–debug -s&#x2F;–stacktrace：编译并打印debug模式和info等级的日志及所用异常的堆栈信息(–stacktrace)；</p>
<p>gradlew clean build –refresh-dependencies：组合指令，清除构建并重新构建，同时强制刷新依赖(gradlew –refresh-dependencies)；</p>
<p>gradlew –offline：离线模式，即让Gradle只使用本地cache里的依赖，如果cache中没有也不会更新依赖，而是提示编译失败；</p>
<p>gradlew –refresh-dependencies：强制刷新依赖，即检查依赖是否有更新比如动态版本、SHA1进行本地cache和远程仓库散列码的对比等，有更新则下载更新进行构建；使用这种方式可以避免手动删除cache；–info：打印堆栈信息；</p>
<p>gradlew –daemon：守护进程，使用Gradle的守护进程构建，能够提高构建效率，如果守护进程没启动或现有的都处于忙碌状态，就启动一个守护进程；</p>
<p>守护进程和守护线程的区别：</p>
<ul>
<li>守护进程 :只会守护到主进程的代码结束</li>
<li>守护线程 :会守护所有其他非守护线程的结束</li>
</ul>
<p>gradlew –no-daemon：如果你已经配置为使用守护进程构建，可以使用该选项本次不用守护进程构建；</p>
<p>gradlew –continuous：连续构建，即任务队列中即使某个任务失败，不会终止执行，而是会继续执行下一个任务；<br>gradlew –parallel –parallel-threads&#x3D;N：并行编译；</p>
<p>gradlew –configure-on-demand：按需编译；</p>
<h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>implementation：gradle会将依赖项添加到编译类路径，并将依赖项打包到编译输出。且其他模块只有在运行时才能使用该依赖项。</p>
<p>api：gradle会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项。</p>
<p>compileOnly：gradle只会将依赖项添加到编译类路径，不会将其添加到编译输出。</p>
<p>runtimeOnly：gradle只会将依赖项添加到编译输出，以便在运行时使用。即，不会将其添加到编译类路径。</p>
<p>annotationProcessor：要添加对作为注解处理器的库的依赖关系，必须使用 annotationProcessor 配置将其添加到注解处理器类路径。 </p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中协程的特点</title>
    <url>/article/2905e442/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Android中协程的特点"><a href="#Android中协程的特点" class="headerlink" title="Android中协程的特点"></a>Android中协程的特点</h2><ul>
<li><strong>轻量</strong>：您可以在单个线程上运行多个协程，因为协程支持<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html">挂起</a>，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。</li>
<li><strong>内存泄漏更少</strong>：使用<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency">结构化并发</a>机制在一个作用域内执行多项操作。</li>
<li><strong>内置取消支持</strong>：<a href="https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html">取消</a>操作会自动在运行中的整个协程层次结构内传播。</li>
<li><strong>Jetpack 集成</strong>：许多 Jetpack 库都包含提供全面协程支持的<a href="https://developer.android.com/kotlin/ktx?hl=zh-cn">扩展</a>。某些库还提供自己的<a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn">协程作用域</a>，可供您用于结构化并发。</li>
</ul>
<p>非受限的调度器是一种高级机制，可以在某些极端情况下提供帮助而不需要调度协程以便稍后执行或产生不希望的副作用， 因为某些操作必须立即在协程中执行。 非受限调度器不应该在通常的代码中使用。</p>
<p>协程可以在一个线程上挂起并在其它线程上恢复。</p>
<h3 id="在不同线程间跳转"><a href="#在不同线程间跳转" class="headerlink" title="在不同线程间跳转"></a>在不同线程间跳转</h3><p>使用 <code>-Dkotlinx.coroutines.debug</code> JVM 参数运行下面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log</span><span class="hljs-params">(msg: <span class="hljs-type">String</span>)</span></span> = println(<span class="hljs-string">&quot;[<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="hljs-variable">$msg</span>&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    newSingleThreadContext(<span class="hljs-string">&quot;Ctx1&quot;</span>).use &#123; ctx1 -&gt;<br>        newSingleThreadContext(<span class="hljs-string">&quot;Ctx2&quot;</span>).use &#123; ctx2 -&gt;<br>            runBlocking(ctx1) &#123;<br>                log(<span class="hljs-string">&quot;Started in ctx1&quot;</span>)<br>                withContext(ctx2) &#123;<br>                    log(<span class="hljs-string">&quot;Working in ctx2&quot;</span>)<br>                &#125;<br>                log(<span class="hljs-string">&quot;Back to ctx1&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[Ctx1 @coroutine#1] Started in ctx1<br>[Ctx2 @coroutine#1] Working in ctx2<br>[Ctx1 @coroutine#1] Back to ctx1<br>Exception in thread &quot;main&quot; java.security.AccessControlException: Access control exception due to security reasons in web playground: <br> access denied (&quot;java.lang.RuntimePermission&quot; &quot;modifyThread&quot;)<br> at java.lang.SecurityManager.checkPermission (SecurityManager.java:549) <br></code></pre></td></tr></table></figure>

<p>使用 runBlocking 来显式指定了一个上下文，并且另一个使用 withContext 函数来改变协程的上下文，而仍然驻留在相同的协程中</p>
<p>当我们不再需要某个在 newSingleThreadContext 中创建的线程的时候， 它使用了 Kotlin 标准库中的 use 函数来释放该线程。</p>
<p>注意，CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive &#x3D;&#x3D; true 的一种方便的快捷方式。</p>
<p>当一个父协程被取消的时候，所有它的子协程也会被递归的取消。然而，当使用 GlobalScope 来启动一个协程时，则新协程的作业没有父作业。 因此它与这个启动的作用域无关且独立运作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">log(<span class="hljs-string">&quot;Started main coroutine&quot;</span>)<br><span class="hljs-comment">// 运行两个后台值计算</span><br><span class="hljs-keyword">val</span> v1 = async(CoroutineName(<span class="hljs-string">&quot;v1coroutine&quot;</span>)) &#123;<br>    delay(<span class="hljs-number">500</span>)<br>    log(<span class="hljs-string">&quot;Computing v1&quot;</span>)<br>    <span class="hljs-number">252</span><br>&#125;<br><span class="hljs-keyword">val</span> v2 = async(CoroutineName(<span class="hljs-string">&quot;v2coroutine&quot;</span>)) &#123;<br>    delay(<span class="hljs-number">1000</span>)<br>    log(<span class="hljs-string">&quot;Computing v2&quot;</span>)<br>    <span class="hljs-number">6</span><br>&#125;<br>log(<span class="hljs-string">&quot;The answer for v1 / v2 = <span class="hljs-subst">$&#123;v1.await() / v2.await()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>



<p>协程上下文中定义多个元素</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">launch(Dispatchers.Default + CoroutineName(<span class="hljs-string">&quot;test&quot;</span>)) &#123;<br>    println(<span class="hljs-string">&quot;I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">I&#x27;m working in thread DefaultDispatcher-worker-1 @test#2<br></code></pre></td></tr></table></figure>



<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mainScope = CoroutineScope(Dispatchers.Default) <span class="hljs-comment">// use Default for test purposes</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span> &#123;<br>        mainScope.cancel()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span><br>        repeat(<span class="hljs-number">10</span>) &#123; i -&gt;<br>            mainScope.launch &#123;<br>                delay((i + <span class="hljs-number">1</span>) * <span class="hljs-number">200L</span>) <span class="hljs-comment">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span><br>                println(<span class="hljs-string">&quot;Coroutine <span class="hljs-variable">$i</span> is done&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-comment">// Activity 类结束</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> activity = Activity()<br>    activity.doSomething() <span class="hljs-comment">// 运行测试函数</span><br>    println(<span class="hljs-string">&quot;Launched coroutines&quot;</span>)<br>    delay(<span class="hljs-number">500L</span>) <span class="hljs-comment">// 延迟半秒钟</span><br>    println(<span class="hljs-string">&quot;Destroying activity!&quot;</span>)<br>    activity.destroy() <span class="hljs-comment">// 取消所有的协程</span><br>    delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 为了在视觉上确认它们没有工作    </span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Launched coroutines<br>Coroutine 0 is done<br>Coroutine 1 is done<br>Destroying activity!<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>协程详解</title>
    <url>/article/c47eb885/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><code>kotlinx.coroutines</code> 是由 JetBrains 开发的功能丰富的协程库。它涵盖了的很多启用高级协程的原语，包括 <code>launch</code>、 <code>async</code> 等等。</p>
<p>本质上，协程是轻量级的线程。 它们在某些 <strong>CoroutineScope</strong>上下文中与 <strong>launch</strong> <em>协程构建器</em> 一起启动。</p>
<p>当我们在 <strong>GlobalScope</strong> 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。</p>
<p> <strong>delay</strong>是一个特殊的 <em><strong>挂起函数</strong></em> ，它不会造成线程阻塞，但是会 <em><strong>挂起</strong></em> 协程，并且只能在协程中使用。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul>
<li><em>非阻塞的</em> <code>delay(……)</code> </li>
<li><em>阻塞的</em> <code>Thread.sleep(……)</code></li>
<li><em>阻塞的</em>runBlocking{..delay(….)..}</li>
</ul>
<p>注意： runBlocking会阻塞主线程，直到内部执行完成</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; <span class="hljs-comment">// 开始执行主协程</span><br>    GlobalScope.launch &#123; <span class="hljs-comment">// 在后台启动一个新的协程并继续，这与局部启动（launch &#123;&#125;）不同</span><br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;World!&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello,&quot;</span>) <span class="hljs-comment">// 主协程在这里会立即执行</span><br>    delay(<span class="hljs-number">2000L</span>)      <span class="hljs-comment">// 延迟 2 秒来保证 JVM 存活,或者使用 job.join() </span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>挂起函数单元测试</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testMySuspendingFunction</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>        <span class="hljs-comment">// 这里我们可以使用任何喜欢的断言风格来使用挂起函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h3><ul>
<li>runBlocking 方法会阻塞当前线程来等待；</li>
<li>coroutineScope 只是挂起，会释放底层线程用于其他用途。</li>
</ul>
<p>runBlocking 是常规函数，而 coroutineScope 是挂起函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// this: CoroutineScope</span><br>    launch &#123; <br>        delay(<span class="hljs-number">200L</span>)<br>        println(<span class="hljs-string">&quot;Task from runBlocking&quot;</span>)<br>    &#125;<br>    <br>    coroutineScope &#123; <span class="hljs-comment">// 创建一个协程作用域</span><br>        launch &#123;<br>            delay(<span class="hljs-number">500L</span>) <br>            println(<span class="hljs-string">&quot;Task from nested launch&quot;</span>)<br>        &#125;<br>    <br>        delay(<span class="hljs-number">100L</span>)<br>        println(<span class="hljs-string">&quot;Task from coroutine scope&quot;</span>) <span class="hljs-comment">// 这一行会在内嵌 launch 之前输出</span><br>    &#125;<br>    <br>    println(<span class="hljs-string">&quot;Coroutine scope is over&quot;</span>) <span class="hljs-comment">// 这一行在内嵌 launch 执行完毕后才输出</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">Task <span class="hljs-keyword">from</span> coroutine scope<br>Task <span class="hljs-keyword">from</span> runBlocking<br>Task <span class="hljs-keyword">from</span> nested launch<br>Coroutine scope <span class="hljs-keyword">is</span> over<br></code></pre></td></tr></table></figure>



<h3 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    launch &#123; doWorld() &#125;<br>    println(<span class="hljs-string">&quot;Hello,&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 这是你的第一个挂起函数</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWorld</span><span class="hljs-params">()</span></span> &#123;<br>    delay(<span class="hljs-number">1000L</span>)<br>    println(<span class="hljs-string">&quot;World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Hello,<br>World!<br></code></pre></td></tr></table></figure>

<p>注意：在 GlobalScope 中启动的活动协程并不会使进程保活。它们就像守护线程。</p>
<h2 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> job = launch &#123;<br>        repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>            println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>            delay(<span class="hljs-number">500L</span>)<br>        &#125;<br>    &#125;<br>    delay(<span class="hljs-number">1300L</span>) <span class="hljs-comment">// 延迟一段时间</span><br>    println(<span class="hljs-string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)<br>    job.cancel() <span class="hljs-comment">// 取消该作业</span><br>    job.join() <span class="hljs-comment">// 等待作业执行结束；可以用cancelAndJoin 取代上面两行</span><br>    println(<span class="hljs-string">&quot;main: Now I can quit.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">job: I&#x27;m sleeping 0 ...<br>job: I&#x27;m sleeping 1 ...<br>job: I&#x27;m sleeping 2 ...<br>main: I&#x27;m tired of waiting!<br>main: Now I can quit.<br></code></pre></td></tr></table></figure>

<p>如果协程正在执行计算任务，并且没有检查取消的话，那么它是不能被取消的</p>
<p>有两种方法来使执行计算的代码可以被取消。第一种方法是定期调用挂起函数来检查取消。对于这种目的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a> 是一个好的选择。 另一种方法是显式的检查取消状态。</p>
<p>isActive 是一个可以被使用在 CoroutineScope 中的扩展属性。</p>
<h3 id="运行不能取消的代码块"><a href="#运行不能取消的代码块" class="headerlink" title="运行不能取消的代码块"></a>运行不能取消的代码块</h3><p>所有良好的关闭操作（关闭一个文件、取消一个作业、或是关闭任何一种通信通道）通常都是非阻塞的，并且不会调用任何挂起函数。</p>
<p>当你需要挂起一个被取消的协程，你可以将相应的代码包装在 withContext(NonCancellable) {……} 中，并使用 withContext 函数以及 NonCancellable 上下文</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = launch &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>            println(<span class="hljs-string">&quot;job: I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>            delay(<span class="hljs-number">500L</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        withContext(NonCancellable) &#123;<br>            println(<span class="hljs-string">&quot;job: I&#x27;m running finally&quot;</span>)<br>            delay(<span class="hljs-number">1000L</span>)<br>            println(<span class="hljs-string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>delay(<span class="hljs-number">1300L</span>) <span class="hljs-comment">// 延迟一段时间</span><br>println(<span class="hljs-string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)<br>job.cancelAndJoin() <span class="hljs-comment">// 取消该作业并等待它结束</span><br>println(<span class="hljs-string">&quot;main: Now I can quit.&quot;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">job: I&#x27;m sleeping 0 ...<br>job: I&#x27;m sleeping 1 ...<br>job: I&#x27;m sleeping 2 ...<br>main: I&#x27;m tired of waiting!<br>job: I&#x27;m running finally<br>job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable<br>main: Now I can quit.<br></code></pre></td></tr></table></figure>



<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>例子1</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> result = withTimeoutOrNull(<span class="hljs-number">1300L</span>) &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>    <span class="hljs-string">&quot;Done&quot;</span> <span class="hljs-comment">// 在它运行得到结果之前取消它</span><br>&#125;<br>println(<span class="hljs-string">&quot;Result is <span class="hljs-variable">$result</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">I&#x27;m sleeping 0 ...<br>I&#x27;m sleeping 1 ...<br>Result is null<br></code></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*<br><br><span class="hljs-keyword">var</span> acquired = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-keyword">init</span> &#123; acquired++ &#125; <span class="hljs-comment">// Acquire the resource</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123; acquired-- &#125; <span class="hljs-comment">// Release the resource</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runBlocking &#123;<br>        repeat(<span class="hljs-number">100_000</span>) &#123; <span class="hljs-comment">// Launch 100K coroutines</span><br>            launch &#123; <br>                <span class="hljs-keyword">var</span> resource: Resource? = <span class="hljs-literal">null</span> <span class="hljs-comment">// Not acquired yet</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    withTimeout(<span class="hljs-number">60</span>) &#123; <span class="hljs-comment">// Timeout of 60 ms</span><br>                        delay(<span class="hljs-number">50</span>) <span class="hljs-comment">// Delay for 50 ms</span><br>                        resource = Resource() <span class="hljs-comment">// Store a resource to the variable if acquired      </span><br>                    &#125;<br>                    <span class="hljs-comment">// We can do something else with the resource here</span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    resource?.close() <span class="hljs-comment">// Release the resource if it was acquired</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Outside of runBlocking all coroutines have completed</span><br>    println(acquired) <span class="hljs-comment">// Print the number of resources still acquired</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：该例子是安全的，因为都在同一个线程中。</p>
<h3 id="async-并发"><a href="#async-并发" class="headerlink" title="async 并发"></a>async 并发</h3><p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>
<p>请注意，使用协程进行并发总是显式的。</p>
<p>async 可以通过将 start 参数设置为 CoroutineStart.LAZY 而变为惰性的。 在这个模式下，只有结果通过 await 获取的时候协程才会启动，或者在 Job 的 start 函数调用的时候。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        <span class="hljs-keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;<br>        <span class="hljs-keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;<br>        <span class="hljs-comment">// 执行一些计算</span><br>        one.start() <span class="hljs-comment">// 启动第一个</span><br>        two.start() <span class="hljs-comment">// 启动第二个</span><br>        println(<span class="hljs-string">&quot;The answer is <span class="hljs-subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Completed in <span class="hljs-variable">$time</span> ms&quot;</span>)    <br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomethingUsefulOne</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 假设我们在这里做了些有用的事</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">13</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomethingUsefulTwo</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 假设我们在这里也做了些有用的事</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">29</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="协程上下文与调度器"><a href="#协程上下文与调度器" class="headerlink" title="协程上下文与调度器"></a>协程上下文与调度器</h2><p>所有的协程构建器诸如 launch 和 async 接收一个可选的 CoroutineContext 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。</p>
<p>newSingleThreadContext 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。</p>
<p><code>launch(Dispatchers.Default) &#123; …… &#125;</code> 与 <code>GlobalScope.launch &#123; …… &#125;</code> 使用相同的调度器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">launch &#123; <span class="hljs-comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span><br>    println(<span class="hljs-string">&quot;main runBlocking      : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>&#125;<br>launch(Dispatchers.Unconfined) &#123; <span class="hljs-comment">// 不受限的——将工作在主线程中</span><br>    println(<span class="hljs-string">&quot;Unconfined            : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>&#125;<br>launch(Dispatchers.Default) &#123; <span class="hljs-comment">// 将会获取默认调度器</span><br>    println(<span class="hljs-string">&quot;Default               : I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>&#125;<br>launch(newSingleThreadContext(<span class="hljs-string">&quot;MyOwnThread&quot;</span>)) &#123; <span class="hljs-comment">// 将使它获得一个新的线程</span><br>    println(<span class="hljs-string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Unconfined            : I&#x27;m working in thread main @coroutine#3<br>Default               : I&#x27;m working in thread DefaultDispatcher-worker-1 @coroutine#4<br>main runBlocking      : I&#x27;m working in thread main @coroutine#2<br>newSingleThreadContext: I&#x27;m working in thread MyOwnThread @coroutine#5<br></code></pre></td></tr></table></figure>



<h3 id="非受限调度器-vs-受限调度器"><a href="#非受限调度器-vs-受限调度器" class="headerlink" title="非受限调度器 vs 受限调度器"></a>非受限调度器 vs 受限调度器</h3><p>Dispatchers.Unconfined 协程调度器在调用它的线程启动了一个协程，但它仅仅只是运行到第一个挂起点。挂起后，它恢复线程中的协程，而这完全由被调用的挂起函数来决定。非受限的调度器非常适用于执行不消耗 CPU 时间的任务，以及不更新局限于特定线程的任何共享数据（如UI）的协程。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>异步流使用详解</title>
    <url>/article/762aaa36/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: List&lt;<span class="hljs-built_in">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br> <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    simple().forEach &#123; value -&gt; println(value) &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: Sequence&lt;<span class="hljs-built_in">Int</span>&gt; = sequence &#123; <span class="hljs-comment">// 序列构建器</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>) <span class="hljs-comment">// 假装我们正在计算</span><br>        yield(i) <span class="hljs-comment">// 产生下一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    simple().forEach &#123; value -&gt; println(value) &#125; <br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: List&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 假装我们在这里做了一些异步的事情</span><br>    <span class="hljs-keyword">return</span> listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    simple().forEach &#123; value -&gt; println(value) &#125; <br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow &#123; <span class="hljs-comment">// 流构建器</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">100</span>) <span class="hljs-comment">// 假装我们在这里做了一些有用的事情</span><br>        emit(i) <span class="hljs-comment">// 发送下一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-comment">// 启动并发的协程以验证主线程并未阻塞</span><br>    launch &#123;<br>        <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            println(<span class="hljs-string">&quot;I&#x27;m not blocked <span class="hljs-variable">$k</span>&quot;</span>)<br>            delay(<span class="hljs-number">100</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 收集这个流</span><br>    simple().collect &#123; value -&gt; println(value) &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意使用Flow类型构建器函数：</p>
<ul>
<li>名为 flow的 Flow类型构建器函数。</li>
<li><code>flow &#123; ... &#125;</code> 构建块中的代码可以挂起。</li>
<li>函数 <code>simple</code> 不再标有 <code>suspend</code> 修饰符。</li>
<li>流使用 emit函数 <em>发射</em> 值。</li>
<li>流使用 collect 函数 <em>收集</em> 值。</li>
</ul>
<p>我们可以在 <code>simple</code> 的 <code>flow &#123; ... &#125;</code> 函数体内使用 <code>Thread.sleep</code> 代替 delay 以观察主线程在本案例中被阻塞了。</p>
<p>flow 构建器中的代码直到流被收集的时候才运行</p>
<h3 id="流的超时取消"><a href="#流的超时取消" class="headerlink" title="流的超时取消"></a>流的超时取消</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow &#123; <br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">100</span>)          <br>        println(<span class="hljs-string">&quot;Emitting <span class="hljs-variable">$i</span>&quot;</span>)<br>        emit(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    withTimeoutOrNull(<span class="hljs-number">250</span>) &#123; <span class="hljs-comment">// 在 250 毫秒后超时</span><br>        simple().collect &#123; value -&gt; println(value) &#125; <br>    &#125;<br>    println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h3><p><code>flow &#123; ... &#125;</code> 构建器是最基础的一个	</p>
<p>flowOf 构建器定义了一个发射固定值集的流。<br>使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 将一个整数区间转化为流</span><br>(<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().collect &#123; value -&gt; println(value) &#125;<br></code></pre></td></tr></table></figure>



<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="过渡流操作符"><a href="#过渡流操作符" class="headerlink" title="过渡流操作符"></a>过渡流操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performRequest</span><span class="hljs-params">(request: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>    delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 模仿长时间运行的异步工作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;response <span class="hljs-variable">$request</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 一个请求流</span><br>        .map &#123; request -&gt; performRequest(request) &#125;<br>        .collect &#123; response -&gt; println(response) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">response 1<br>response 2<br>response 3	<br></code></pre></td></tr></table></figure>



<h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">(<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 一个请求流</span><br>    .transform &#123; request -&gt;<br>        emit(<span class="hljs-string">&quot;Making request <span class="hljs-variable">$request</span>&quot;</span>) <br>        emit(performRequest(request)) <br>    &#125;<br>    .collect &#123; response -&gt; println(response) &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Making request 1<br>response 1<br>Making request 2<br>response 2<br>Making request 3<br>response 3<br></code></pre></td></tr></table></figure>



<h3 id="限长操作符"><a href="#限长操作符" class="headerlink" title="限长操作符"></a>限长操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">numbers</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow &#123;<br>    <span class="hljs-keyword">try</span> &#123;                          <br>        emit(<span class="hljs-number">1</span>)<br>        emit(<span class="hljs-number">2</span>) <br>        println(<span class="hljs-string">&quot;This line will not execute&quot;</span>)<br>        emit(<span class="hljs-number">3</span>)    <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        println(<span class="hljs-string">&quot;Finally in numbers&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    numbers() <br>        .take(<span class="hljs-number">2</span>) <span class="hljs-comment">// 只获取前两个</span><br>        .collect &#123; value -&gt; println(value) &#125;<br>&#125;          <br></code></pre></td></tr></table></figure>



<h3 id="末端流操作符"><a href="#末端流操作符" class="headerlink" title="末端流操作符"></a>末端流操作符</h3><p>末端操作符：</p>
<ul>
<li>转化为各种集合，例如 toList 与 toSet。</li>
<li>获取第一个（first）值与确保流发射单个（single）值的操作符。</li>
<li>使用 reduce 与 fold 将流规约到单个值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum = (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).asFlow()<br>    .map &#123; it * it &#125; <span class="hljs-comment">// 数字 1 至 5 的平方                        </span><br>    .reduce &#123; a, b -&gt; a + b &#125; <span class="hljs-comment">// 求和（末端操作符）</span><br>println(sum)<br></code></pre></td></tr></table></figure>

<p>输出： 55</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>过滤偶数并将其映射到字符串</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">(<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).asFlow()<br>    .filter &#123;<br>        println(<span class="hljs-string">&quot;Filter <span class="hljs-variable">$it</span>&quot;</span>)<br>        it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>              <br>    &#125;              <br>    .map &#123; <br>        println(<span class="hljs-string">&quot;Map <span class="hljs-variable">$it</span>&quot;</span>)<br>        <span class="hljs-string">&quot;string <span class="hljs-variable">$it</span>&quot;</span><br>    &#125;.collect &#123; <br>        println(<span class="hljs-string">&quot;Collect <span class="hljs-variable">$it</span>&quot;</span>)<br>    &#125;    <br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Filter 1<br>Filter 2<br>Map 2<br>Collect string 2<br>Filter 3<br>Filter 4<br>Map 4<br>Collect string 4<br>Filter 5<br></code></pre></td></tr></table></figure>



<p>通常，withContext 用于在 Kotlin 协程中改变代码的上下文，但是 flow {…} 构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit）。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>异步流</tag>
      </tags>
  </entry>
  <entry>
    <title>异步流的方法详解</title>
    <url>/article/76ae8ac8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a>flowOn 操作符</h2><p>该函数用于更改流发射的上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>) <span class="hljs-comment">// 假装我们以消耗 CPU 的方式进行计算</span><br>        log(<span class="hljs-string">&quot;Emitting <span class="hljs-variable">$i</span>&quot;</span>)<br>        emit(i) <span class="hljs-comment">// 发射下一个值</span><br>    &#125;<br>&#125;.flowOn(Dispatchers.Default) <span class="hljs-comment">// 在流构建器中改变消耗 CPU 代码上下文的正确方式</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    simple().collect &#123; value -&gt;<br>        log(<span class="hljs-string">&quot;Collected <span class="hljs-variable">$value</span>&quot;</span>) <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1<br>[main @coroutine#1] Collected 1<br>[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2<br>[main @coroutine#1] Collected 2<br>[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3<br>[main @coroutine#1] Collected 3<br></code></pre></td></tr></table></figure>

<p> flowOn 操作符已改变流的默认顺序性。 现在收集发生在一个协程中（“coroutine#1”）而发射发生在运行于另一个线程中与收集协程并发运行的另一个协程（“coroutine#2”）中。当上游流必须改变其上下文中的 CoroutineDispatcher 的时候，flowOn 操作符创建了另一个协程。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        delay(<span class="hljs-number">100</span>) <span class="hljs-comment">// 假装我们异步等待了 100 毫秒</span><br>        emit(i) <span class="hljs-comment">// 发射下一个值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; <br>    <span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>        simple()<br>            .buffer() <span class="hljs-comment">// 缓冲发射项，无需等待</span><br>            .collect &#123; value -&gt; <br>                delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// 假装我们花费 300 毫秒来处理它</span><br>                println(value) <br>            &#125; <br>    &#125;   <br>    println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1<br>2<br>3<br>Collected in 1054 ms<br></code></pre></td></tr></table></figure>

<p>注意，当必须更改 CoroutineDispatcher 时，flowOn 操作符使用了相同的缓冲机制， 但是我们在这里显式地请求缓冲而不改变执行上下文。</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>当流代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的那个。</p>
<p>当收集器处理它们太慢的时候， conflate 操作符可以用于跳过中间值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>    simple()<br>        .conflate() <span class="hljs-comment">// 合并发射项，不对每个值进行处理</span><br>        .collect &#123; value -&gt; <br>            delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// 假装我们花费 300 毫秒来处理它</span><br>            println(value) <br>        &#125; <br>&#125;   <br>println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1<br>3<br>Collected in 749 ms<br></code></pre></td></tr></table></figure>



<h2 id="处理最新值"><a href="#处理最新值" class="headerlink" title="处理最新值"></a>处理最新值</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> time = measureTimeMillis &#123;<br>    simple()<br>        .collectLatest &#123; value -&gt; <span class="hljs-comment">// 取消并重新发射最后一个值</span><br>            println(<span class="hljs-string">&quot;Collecting <span class="hljs-variable">$value</span>&quot;</span>) <br>            delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// 假装我们花费 300 毫秒来处理它</span><br>            println(<span class="hljs-string">&quot;Done <span class="hljs-variable">$value</span>&quot;</span>) <br>        &#125; <br>&#125;   <br>println(<span class="hljs-string">&quot;Collected in <span class="hljs-variable">$time</span> ms&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>由于 collectLatest 的函数体需要花费 300 毫秒，但是新值每 100 秒发射一次，我们看到该代码块对每个值运行，但是只收集最后一个值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Collecting 1<br>Collecting 2<br>Collecting 3<br>Done 3<br>Collected in 691 ms<br></code></pre></td></tr></table></figure>



<h2 id="Zip方法"><a href="#Zip方法" class="headerlink" title="Zip方法"></a>Zip方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow() <span class="hljs-comment">// 数字 1..3</span><br><span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>) <span class="hljs-comment">// 字符串</span><br>nums.zip(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 组合单个字符串</span><br>    .collect &#123; println(it) &#125; <span class="hljs-comment">// 收集并打印</span><br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1 -&gt; one<br>2 -&gt; two<br>3 -&gt; three<br></code></pre></td></tr></table></figure>



<h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>当流表示一个变量或操作的最新值时，可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">300</span>) &#125; <span class="hljs-comment">// 发射数字 1..3，间隔 300 毫秒</span><br><span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>).onEach &#123; delay(<span class="hljs-number">400</span>) &#125; <span class="hljs-comment">// 每 400 毫秒发射一次字符串</span><br><span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始的时间</span><br>nums.zip(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 使用“zip”组合单个字符串</span><br>    .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) <br>    &#125; <br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1 -&gt; one at 425 ms from start<br>2 -&gt; two at 825 ms from start<br>3 -&gt; three at 1227 ms from start<br></code></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">300</span>) &#125; <span class="hljs-comment">// 发射数字 1..3，间隔 300 毫秒</span><br><span class="hljs-keyword">val</span> strs = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>).onEach &#123; delay(<span class="hljs-number">400</span>) &#125; <span class="hljs-comment">// 每 400 毫秒发射一次字符串</span><br><span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始的时间</span><br>nums.combine(strs) &#123; a, b -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>&quot;</span> &#125; <span class="hljs-comment">// 使用“combine”组合单个字符串</span><br>    .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) <br>    &#125; <br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1 -&gt; one at 443 ms from start<br>2 -&gt; one at 644 ms from start<br>2 -&gt; two at 845 ms from start<br>3 -&gt; two at 944 ms from start<br>3 -&gt; three at 1245 ms from start<br></code></pre></td></tr></table></figure>



<h2 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h2><p>连接模式由 flatMapConcat 与 flattenConcat 操作符实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestFlow</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;<br>    emit(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>: First&quot;</span>) <br>    delay(<span class="hljs-number">500</span>) <span class="hljs-comment">// 等待 500 毫秒</span><br>    emit(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>: Second&quot;</span>)    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; <br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始时间</span><br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">100</span>) &#125; <span class="hljs-comment">// 每 100 毫秒发射一个数字 </span><br>        .flatMapConcat &#123; requestFlow(it) &#125;                                                                           <br>        .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) <br>        &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1: First at 127 ms from start<br>1: Second at 628 ms from start<br>2: First at 729 ms from start<br>2: Second at 1229 ms from start<br>3: First at 1329 ms from start<br>3: Second at 1830 ms from start<br></code></pre></td></tr></table></figure>



<h2 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h2><p>另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 flatMapMerge 与 flattenMerge 操作符实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestFlow</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;<br>    emit(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>: First&quot;</span>) <br>    delay(<span class="hljs-number">500</span>) <span class="hljs-comment">// 等待 500 毫秒</span><br>    emit(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>: Second&quot;</span>)    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; <br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始时间</span><br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">100</span>) &#125; <span class="hljs-comment">// 每 100 毫秒发射一个数字 </span><br>        .flatMapMerge &#123; requestFlow(it) &#125;                                                                           <br>        .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) <br>        &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1: First at 136 ms from start<br>2: First at 231 ms from start<br>3: First at 333 ms from start<br>1: Second at 639 ms from start<br>2: Second at 732 ms from start<br>3: Second at 833 ms from start<br></code></pre></td></tr></table></figure>



<h2 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestFlow</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;<br>    emit(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>: First&quot;</span>) <br>    delay(<span class="hljs-number">500</span>) <span class="hljs-comment">// 等待 500 毫秒</span><br>    emit(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>: Second&quot;</span>)    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; <br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis() <span class="hljs-comment">// 记录开始时间</span><br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow().onEach &#123; delay(<span class="hljs-number">100</span>) &#125; <span class="hljs-comment">// 每 100 毫秒发射一个数字 </span><br>        .flatMapLatest &#123; requestFlow(it) &#125;                                                                           <br>        .collect &#123; value -&gt; <span class="hljs-comment">// 收集并打印</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span> at <span class="hljs-subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) <br>        &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1</span>: First at <span class="hljs-number">142</span> ms <span class="hljs-keyword">from</span> start<br><span class="hljs-number">2</span>: First at <span class="hljs-number">322</span> ms <span class="hljs-keyword">from</span> start<br><span class="hljs-number">3</span>: First at <span class="hljs-number">425</span> ms <span class="hljs-keyword">from</span> start<br><span class="hljs-number">3</span>: Second at <span class="hljs-number">931</span> ms <span class="hljs-keyword">from</span> start<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>碎片</title>
    <url>/article/88d274c3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h2><p>错误日志：</p>
<p>Could not inflate Behavior subclass FloatingActionButton</p>
<p>解决方案：FloatingActionButton的layout_behavior使用完整路径，不要使用相对路径；</p>
<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>setPriority在Thread.start()之前</p>
<h2 id="merge失败"><a href="#merge失败" class="headerlink" title="merge失败"></a>merge失败</h2><p>如下所示，重复写了，导致merge资源失败，并没有报出具体错误位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br></code></pre></td></tr></table></figure>



<h2 id="所有命令失效"><a href="#所有命令失效" class="headerlink" title="所有命令失效"></a>所有命令失效</h2><p>export PATH&#x3D;”&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;X11&#x2F;bin”</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>bat命令</tag>
      </tags>
  </entry>
  <entry>
    <title>DecorView介绍</title>
    <url>/article/603b68b6/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>DecorView</strong>: 该类继承自<strong>FrameLayout</strong>，实现了<strong>RootViewSurfaceTaker</strong>, <strong>WindowCallbacks</strong>接口。它是所有应用窗口的根View,PhoneWindow设置DecorView为应用窗口的根视图。</p>
<p><strong>PhoneWindow</strong>: 该类在setContentView时，帮我们创建了一个<strong>DecorView</strong>（父类为FrameLayout）窗口顶层视图</p>
<p><strong>ViewRootImpl</strong>: 是连接WindowManager与DecorView的纽带，View的整个绘制流程的三大步（measure、layout、draw）以及我们一些addView()的操作，都是通过ViewRootImpl完成的。</p>
<p><strong>WindowManager</strong>: 应用程序界面和窗口管理器</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Activity的的<strong>setContentView</strong>方法调用，首先进入installDecor方法，进行decorView的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContentView</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutResID)</span> &#123;<br>    <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br>    <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span><br>    <span class="hljs-comment">// before this happens.</span><br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//这里开始创建decorview</span><br>        installDecor();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        mContentParent.removeAllViews();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Scene</span> <span class="hljs-variable">newScene</span> <span class="hljs-operator">=</span> Scene.getSceneForLayout(mContentParent, layoutResID,<br>                getContext());<br>        transitionTo(newScene);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mLayoutInflater.inflate(layoutResID, mContentParent);<br>    &#125;<br>    mContentParent.requestApplyInsets();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> getCallback();<br>    <span class="hljs-keyword">if</span> (cb != <span class="hljs-literal">null</span> &amp;&amp; !isDestroyed()) &#123;<br>        cb.onContentChanged();<br>    &#125;<br>    mContentParentExplicitlySet = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>generateDecor</strong>方法为decorview的主要创建方法,参数为featureId，默认值为-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installDecor</span><span class="hljs-params">()</span> &#123;<br>    mForceDecorInstall = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//decorview的主要创建方法</span><br>        mDecor = generateDecor(-<span class="hljs-number">1</span>);<br>        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);<br>        mDecor.setIsRootNamespace(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="hljs-number">0</span>) &#123;<br>            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mDecor.setWindow(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-literal">null</span>) &#123;<br>        mContentParent = generateLayout(mDecor);<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>generateDecor</strong>方法主要是对decorview的上下文进行创建，当拿到context、featureId、phonewindow以及windowmanage的布局参数后，便开始真正的new DecorView 对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title function_">generateDecor</span><span class="hljs-params">(<span class="hljs-type">int</span> featureId)</span> &#123;<br>    <span class="hljs-comment">// System process doesn&#x27;t have application context and in that case we need to directly use</span><br>    <span class="hljs-comment">// the context we have. Otherwise we want the application context, so we don&#x27;t cling to the</span><br>    <span class="hljs-comment">// activity.</span><br>    Context context;<br>    <span class="hljs-keyword">if</span> (mUseDecorContext) &#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> getContext().getApplicationContext();<br>        <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-literal">null</span>) &#123;<br>            context = getContext();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorContext</span>(applicationContext, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> (mTheme != -<span class="hljs-number">1</span>) &#123;<br>                context.setTheme(mTheme);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        context = getContext();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorView</span>(context, featureId, <span class="hljs-built_in">this</span>, getAttributes());<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>DecorView</strong>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    DecorView(Context context, <span class="hljs-type">int</span> featureId, PhoneWindow window,<br>            WindowManager.LayoutParams params) &#123;<br><span class="hljs-comment">//...</span><br>        updateAvailableWidth();<br><br>        setWindow(window);<br><br>        updateLogTag(params);<br><br><span class="hljs-comment">//...</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>setWindow</strong>方法设置DecorView的mWindow变量，若当前上下文是DecorContext，也更新decorContext的mPhoneWindow值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWindow</span><span class="hljs-params">(PhoneWindow phoneWindow)</span> &#123;<br>        mWindow = phoneWindow;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getContext();<br>        <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> DecorContext) &#123;<br>            <span class="hljs-type">DecorContext</span> <span class="hljs-variable">decorContext</span> <span class="hljs-operator">=</span> (DecorContext) context;<br>            decorContext.setPhoneWindow(mWindow);<br>        &#125;<br><span class="hljs-comment">//...</span><br>    &#125;<br></code></pre></td></tr></table></figure>



<p>在<strong>DecorContext.java</strong>中,设置mPhoneWindow的值，同时从phoneWindow中获取上下文，取得context的弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setPhoneWindow</span><span class="hljs-params">(PhoneWindow phoneWindow)</span> &#123;<br>    mPhoneWindow = phoneWindow;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> phoneWindow.getContext();<br>    mContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(context);<br>    mResources = context.getResources();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/article/603b68b6/image-20210319102418129.png" alt="image-20210319102418129"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="View-提供的获取坐标方法"><a href="#View-提供的获取坐标方法" class="headerlink" title="View 提供的获取坐标方法"></a>View 提供的获取坐标方法</h3><p><strong>getTop</strong>： View 自身的顶边到父View顶边的距离</p>
<p><strong>getLeft</strong>： View 自身的左边到父View左边的距离</p>
<p><strong>getRight</strong>： View 自身的右边到父View左边的距离</p>
<p><strong>getBottom</strong>： View 自身的底边到父View上边的距离</p>
<h3 id="MotionEvent-提供的获取坐标方法"><a href="#MotionEvent-提供的获取坐标方法" class="headerlink" title="MotionEvent 提供的获取坐标方法"></a>MotionEvent 提供的获取坐标方法</h3><p><strong>getX</strong> : 触摸点到当前控件左边缘的距离</p>
<p><strong>getY</strong> : 触摸点当前控件顶边缘的距离</p>
<p><strong>getRawX</strong> : 触摸点屏幕左边缘的距离</p>
<p><strong>getRawY</strong> : 触摸点到屏幕顶边缘的距离</p>
<h3 id="MeasureSpec的三种类型"><a href="#MeasureSpec的三种类型" class="headerlink" title="MeasureSpec的三种类型"></a>MeasureSpec的三种类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span><br><span class="hljs-meta">@IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MeasureSpecMode &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><strong>UNSPECIFIED</strong>:父级没有对子级施加任何约束。</p>
<p><strong>EXACTLY</strong>:父级已确定子级的确切大小</p>
<p><strong>AT_MOST</strong>:子级可以根据需要的大小而定，最大可以达到指定的大小。</p>
<h3 id="onFinishInflate-调用时机"><a href="#onFinishInflate-调用时机" class="headerlink" title="onFinishInflate 调用时机"></a>onFinishInflate 调用时机</h3><p>setContentView &gt; onFinishInflate &gt; view绘制流程（performMeasure、performLayout、performDraw）</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>DecorView</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle执行流程</title>
    <url>/article/8e10e406/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="gradle执行流程"><a href="#gradle执行流程" class="headerlink" title="gradle执行流程"></a>gradle执行流程</h2><p>Gradle.buildStarted()</p>
<p>初始化阶段</p>
<ul>
<li>setting.gradle</li>
<li>Gradle.settingsEvaluated()</li>
<li>Gradle.projectsLoaded()</li>
</ul>
<p>配置阶段</p>
<ul>
<li>Gradle.beforeProject()&amp;Project.beforeEvaluate()</li>
<li>build.gradle(确定任务子集和配置task)</li>
<li>Gradle.afterProject()&amp;Project.afterEvaluate()</li>
<li>Gradle.projectsEvaluated()&amp;Gradle.taskGraph.whenReady()</li>
</ul>
<p>执行阶段</p>
<ul>
<li>Gradle.taskGraph.beaforeTask()</li>
<li>执行Task中的Actions</li>
<li>Gradle.taskGraph.afterTask()</li>
</ul>
<p>Gradle.buildFinish()</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy 学习</title>
    <url>/article/435ae83e/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h2><p>使用‘.@’直接访问变量，跳过默认的getter&#x2F;setter方法调用。</p>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>1..5  包含范围</p>
<p>5..1  降序排列</p>
<p>1..&lt;5  独占范围 (开区间)</p>
<p>‘a’..’z’  范围也可以由字符组成</p>
<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>使用 def 关键字定义一个方法，方法不需要指定返回值类型，参数类型，方法体内的最后一行会自动作为返回值，而不需要return关键字</p>
<p>定义方法时，如果参数没有返回值类型，可以省略 def，使用 void 即可</p>
<p>实际上不管有没有返回值，Groovy 中返回的都是 Object 类型</p>
<p>类的构造方法，避免添加 def 关键字</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>Groovy中没有基本数据类型，全是引用类型，即使定义了基础类型，也会被转换成对应的包装类</strong></p>
<ul>
<li><p>在 Groovy 中，&#x3D;&#x3D; 就相当于 Java 的 equals</p>
</li>
<li><p>比较两个对象是否是同一个，使用 .is()</p>
</li>
<li><p>**表示次方运算符</p>
</li>
</ul>
<h2 id="强大的Switch"><a href="#强大的Switch" class="headerlink" title="强大的Switch"></a>强大的Switch</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">def result = &#x27;xxxx&#x27;<br>switch (result)&#123;<br>    case [1,2,&#x27;yyy&#x27;]:<br>        break<br>    default:<br>        break<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包可以通过 .call 方法来调用</p>
<p>每个闭包中都含有 <strong>this、owner 和 delegate</strong> 这三个内置对象</p>
<ul>
<li>this 永远指向定义该闭包最近的类对象，就近原则</li>
<li>owner 、delegate 指向定义该闭包的类对象或者闭包对象</li>
<li>三者区别：this 和 owner 默认是只读的，delegate 可写的。</li>
</ul>
<h2 id="trait关键字"><a href="#trait关键字" class="headerlink" title="trait关键字"></a>trait关键字</h2><p>trait这个是Groovy中新加的类型，但是其实他就是一种介于抽象类和接口之间的类型；trait中可以定义抽象方法(即不实现)，也可以定义正常方法；使用的时候，和接口一样，也是要implement的,非抽象类实现是需要实现其抽象方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">MyTrait</span>&#123;<br>      <span class="hljs-keyword">abstract</span> <span class="hljs-type">void</span> test();<br>      <span class="hljs-type">void</span> play()&#123;<br>         prinlt(<span class="hljs-string">&quot;play&quot;</span>);<br>      &#125;<br>    &#125;  <br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> implement MyTrait&#123;<br>       <span class="hljs-meta">@Override</span> <br>       <span class="hljs-type">void</span> test()&#123;<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>字节码插桩</title>
    <url>/article/cad98d1c/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="ASM简介"><a href="#ASM简介" class="headerlink" title="ASM简介"></a>ASM简介</h2><p>ASM提供了两种API来生成和转换已编译类:</p>
<ul>
<li>核心API，以基于事件形式来表示类；</li>
<li>树API，以基于对象形式来表示类;</li>
</ul>
<p>应用场景：ButterKnife，Dagger、无痕埋点，性能监控等</p>
<h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p>基于事件的API把类看作是一系列事件来表示，每一个类的事件表示一个类的元素。类似解析XML的SAX。</p>
<p>基于对象的API将类表示成一棵对象树，每个对象表示类的一部分。类似解析XML的DOM</p>
<ul>
<li>事件API内存占用少于对象API，因为事件API不需要在内存中创建和存储对象树</li>
<li>事件API实现难度比对象API大，因为事件API在任意时刻类中只有一个元素可使用，但是对象API能获得整个类。</li>
</ul>
<h2 id="字节代码指令"><a href="#字节代码指令" class="headerlink" title="字节代码指令"></a>字节代码指令</h2><p>字节代码指令由一个标识该指令的操作码和固定数目的参数组成:</p>
<ul>
<li>操作码是一个无符号字节值——即字节代码名，由助记符号标识</li>
<li>参数是静态值，确定了精确的指令行为，在操作码之后给出</li>
</ul>
<p><strong>ILOAD</strong>, <strong>LLOAD</strong>, <strong>FLOAD</strong>, <strong>DLOAD</strong> 和 <strong>ALOAD</strong> 指令读取一个局部变量，并将它的值压到操作数栈中。</p>
<p>它们的参数是必须读取的局部变量的索引 <em>i</em>。</p>
<p><strong>ILOAD</strong> 用于加载一个 <strong>boolean</strong>、<strong>byte</strong>、 <strong>char</strong>、<strong>short</strong> 或 <strong>int</strong> 局部变量。</p>
<p><strong>LLOAD</strong>、<strong>FLOAD</strong> 和 <strong>DLOAD</strong> 分别用于加载 <strong>long</strong>、<strong>float</strong> 或 <strong>double</strong> 值。(<strong>LLOAD</strong> 和 <strong>DLOAD</strong> 实际加载两个槽 <em>i</em> 和 <em>i</em>+1)。</p>
<p>最后，<strong>ALOAD</strong> 用于加载任意非基元值，即对 象和数组引用。</p>
<p>与之对应，<strong>ISTORE</strong>、<strong>LSTORE</strong>、<strong>FSTORE</strong>、<strong>DSTORE</strong> 和 <strong>ASTORE</strong> 指令从操作数栈 中弹出一个值，并将它存储在由其索引 i 指定的局部变量中。</p>
<p><strong>POP</strong>弹出栈顶部的值</p>
<p><strong>DUP</strong>压入顶部栈值的一个副本</p>
<p><strong>SWAP</strong>弹出两个值，并按逆序压入它们</p>
<p><strong>ACONST</strong>_<strong>NULL</strong>压入<strong>null</strong> </p>
<p><strong>ICONST</strong><em><strong>0</strong>压入 <strong>int</strong> 值 0</em></p>
<p><strong>FCONST</strong>_<strong>0</strong> 压入 <strong>0f</strong></p>
<p><strong>DCONST_0</strong> 压入 <strong>0d</strong></p>
<p><strong>BIPUSH</strong> <em>b</em> 压入字节值 <em>b</em></p>
<p><strong>SIPUSH</strong> <em>s</em> 压入 <strong>short</strong> 值 <em>s</em></p>
<p><strong>LDC</strong> <em>cst</em> 压入任意 <strong>int</strong>、<strong>float</strong>、<strong>long</strong>、<strong>double</strong>、<strong>String</strong> 或 **class **常量 <strong>cst</strong> </p>
<p><strong>xADD</strong>、<strong>xSUB</strong>、<strong>xMUL</strong>、<strong>xDIV</strong> 和 <strong>xREM</strong> 对应于**+<strong>、</strong>-<strong>、</strong><em><strong>、</strong>&#x2F;<strong>和</strong>%<strong>运算，其中 <strong>x</strong> 为 <strong>I</strong>、 <strong>L</strong>、</strong>F</em>* 或 <strong>D</strong> 之一</p>
<p>类似地，还有其他对应于**&lt;&lt;<strong>、**&gt;&gt;<strong>、</strong>&gt;&gt;&gt;<strong>、</strong>|<strong>、</strong>&amp;<strong>和</strong>^</strong>运算的指令，用于处理<strong>int</strong>和<strong>long</strong>值。</p>
<p><strong>I2F</strong>, <strong>F2D</strong>, <strong>L2D</strong> 等将数值由一种数值类型转换为另一种 类型。</p>
<p><strong>CHECKCAST</strong> <em>t</em> 将一个引用值转换为类型 <em>t</em>。</p>
<p><strong>NEW</strong> <em>type</em>指令将 一个 <em>type</em> 类型的新对象压入栈中</p>
<p><strong>GETFIELD</strong> <em>owner name desc</em> 弹出一个对象引用，并压入其 <em>name</em> 字段中的值。</p>
<p><strong>PUTFIELD</strong> <em>owner name desc</em> 弹出一个值和一个对象引用，并将这个值存储在它的 <em>name</em> 字段中</p>
<p><strong>INVOKEVIRTUAL</strong> <em>owner name desc</em> 调用在 类 <em>owner</em> 中定义的 <em>name</em> 方法，其方法描述符为 <em>desc</em></p>
<p><strong>INVOKESTATIC</strong> 用于静态方法</p>
<p><strong>INVOKESPECIAL</strong> 用于私有方法和构造器</p>
<p><strong>INVOKEINTERFACE</strong> 用于接口中定义的方法</p>
<p><strong>INVOKEDYNAMIC</strong>  用于新动态方法调用机制（对于 Java 7 中的类）</p>
<p><strong>x</strong> <strong>ALOAD</strong>指令弹出一个索引和一个数组，并压入此索引处数组元素的值。</p>
<p><strong>x</strong> <strong>ASTORE</strong> 指令弹出一个值、一个索引和一个数组，并将这个值存储在该数组的这一索引处</p>
<p><strong>x</strong> 可以是 <strong>I</strong>、<strong>L</strong>、<strong>F</strong>、<strong>D</strong> 或 <strong>A</strong>，还可以是 <strong>B</strong>、<strong>C</strong> 或 <strong>S</strong>。</p>
<p><strong>IFEQ</strong> <em>label</em> 从栈中弹出一个 <strong>int</strong> 值，如果这个值为 0，则跳转到由这个 <em>label</em> 指定的指令处</p>
<p><strong>IFNE</strong> 或 <strong>IFGE</strong></p>
<p><strong>TABLESWITCH</strong> 和<strong>LOOKUPSWITCH</strong> 对应于 <strong>switch</strong> Java 指令。</p>
<p><strong>x</strong> <strong>RETURN</strong>和<strong>RETURN</strong>指令用于终止一个方法的执行，并将其结果返回给调用者</p>
<p><strong>RETURN</strong> 用于返回 <strong>void</strong> 的方法，**x ** <strong>RETURN</strong> 用于其他方法。</p>
<h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pkg;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bean</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> f;<br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getF</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.f;<br>      &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setF</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span> &#123;<br>       <span class="hljs-built_in">this</span>.f = f;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>getter</strong> 方法的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ALOAD 0<br>GETFIELD pkg/Bean f I<br>IRETURN<br></code></pre></td></tr></table></figure>



<p><strong>setter</strong> 方法的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ALOAD 0<br>ILOAD 1<br>PUTFIELD pkg/Bean f I<br>RETURN<br></code></pre></td></tr></table></figure>



<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndSetF</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span> &#123;<br>      <span class="hljs-keyword">if</span> (f &gt;= <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">this</span>.f = f;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">ILOAD <span class="hljs-number">1</span><br>IFLT label<br>ALOAD <span class="hljs-number">0</span><br>ILOAD <span class="hljs-number">1</span><br>PUTFIELD pkg/Bean f I GOTO end<br><span class="hljs-attr">label:</span><br>      NEW java<span class="hljs-regexp">/lang/</span>IllegalArgumentException<br>      DUP<br>      INVOKESPECIAL java<span class="hljs-regexp">/lang/</span>IllegalArgumentException &lt;init&gt; ()V<br>      ATHROW<br><span class="hljs-attr">end:</span><br>RETURN<br></code></pre></td></tr></table></figure>



<h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> d)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>       Thread.sleep(d);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>       e.printStackTrace();<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">TRYCATCHBLOCK <span class="hljs-keyword">try</span> <span class="hljs-keyword">catch</span> <span class="hljs-keyword">catch</span> java<span class="hljs-regexp">/lang/</span>InterruptedException <span class="hljs-attr">try:</span><br>      LLOAD <span class="hljs-number">0</span><br>      INVOKESTATIC java<span class="hljs-regexp">/lang/</span>Thread sleep (J)V<br>      RETURN<br><span class="hljs-attr">catch:</span><br>      INVOKEVIRTUAL java<span class="hljs-regexp">/lang/</span>InterruptedException printStackTrace ()V<br>      RETURN<br></code></pre></td></tr></table></figure>



<h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><p>visitFieldInsn ： 访问某个成员变量的指令，支持GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.</p>
<p>visitFrame ：访问当前局部变量表和操作数栈中元素的状态，参数就是局部变量表和操作数栈的内容</p>
<p>visitIincInsn ： 访问自增指令</p>
<p>visitVarInsn ：访问局部变量指令，就是取局部变量变的值放入操作数栈</p>
<p>visitMethodInsn ：访问方法指令，就是调用某个方法，支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.</p>
<p>visitInsn ： 访问无操作数的指令，例如nop，duo等等</p>
<p>visitTypeInsn：访问type指令，即将一个类的全限定名作为参数然后new一个对象压入操作数栈中</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>自定义插件（官网）： https://docs.gradle.org/current/userguide/custom_plugins.html</p>
<p>asm文档（官网）：https://www.javadoc.io/doc/org.ow2.asm/asm/4.0/org/objectweb/asm/MethodVisitor.html</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ASM插桩</tag>
      </tags>
  </entry>
  <entry>
    <title>代码混淆配置</title>
    <url>/article/8d839750/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>主要功能：优化代码，防止反编译</p>
<p>打开方式： minifyEnabled</p>
<p>proguard-android.txt是Android提供的默认混淆配置文件</p>
<p><strong>混淆命令</strong></p>
<ul>
<li>keep：保留类和类中的成员，防止被混淆或移除</li>
<li>keepnames：保留类和类中的成员，防止被混淆，成员没有被引用会被移除</li>
<li>keepclassmembers：只保留类中的成员，防止被混淆或移除</li>
<li>keepclassmembernames：只保留类中的成员，防止被混淆，成员没有引用会被移除</li>
<li>keepclasseswithmembers：保留类和类中的成员，防止被混淆或移除，保留指明的成员</li>
<li>keepclasseswithmembernames：保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除</li>
</ul>
<p><strong>混淆通配符</strong></p>
<ul>
<li><code>&lt;field&gt;</code>：匹配类中的所有字段</li>
<li><code>&lt;method&gt;</code>：匹配类中所有的方法</li>
<li><code>&lt;init&gt;</code>：匹配类中所有的构造函数</li>
<li><code>*</code>： 匹配任意长度字符，不包含包名分隔符(.)</li>
<li><code>**</code>： 匹配任意长度字符，包含包名分隔符(.)</li>
<li><code>***</code>： 匹配任意参数类型</li>
</ul>
<p>keep的规则的格式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">[keep命令] [类] &#123;<br>        [成员]<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">android&#123;<br>    buildTypes &#123;<br>        release &#123;<br>            buildConfigField <span class="hljs-string">&quot;boolean&quot;</span>, <span class="hljs-string">&quot;LOG_DEBUG&quot;</span>, <span class="hljs-string">&quot;false&quot;</span> <span class="hljs-comment">//不显示log</span><br>            minifyEnabled <span class="hljs-literal">true</span><br>            shrinkResources <span class="hljs-literal">true</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>            signingConfig signingConfigs.config<br>            &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="aar插件配置方式"><a href="#aar插件配置方式" class="headerlink" title="aar插件配置方式"></a>aar插件配置方式</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ···<br>    defaultConfig &#123;<br>        ···<br>        consumerProguardFile <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>    &#125;<br>    ···<br>&#125;<br></code></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>arr打包</title>
    <url>/article/4e400033/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="jar与aar区别"><a href="#jar与aar区别" class="headerlink" title="jar与aar区别"></a>jar与aar区别</h2><ul>
<li>*.jar：只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。</li>
<li>*.aar：包含所有资源 ，class 以及 res 资源文件全部包含</li>
</ul>
<h2 id="打包AAR"><a href="#打包AAR" class="headerlink" title="打包AAR"></a>打包AAR</h2><p>对于成型的项目(有依赖)，我们可以直接在项目中New一个Moudle 然后把项目复制到Moudle中，或者重新复制出来一个当前项目，然后在复制的项目中直接把此项目修改成AAR。</p>
<p>把apply plugin: ‘com.android.application’修改成apply plugin: ‘com.android.library’</p>
<p>去掉defaultConfig下的applicationId</p>
<p>修改application</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">   <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">“false”</span></span><br><span class="hljs-tag">   <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">“true”</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>注释掉启动的Activity启动的action</p>
<p>AAR中是没有Application的,我们可以单独写一个Options类，提供给调用者，让他传递过来application，这样我们就可以在这个类中做一些初始化操作了。</p>
<p>直接build–&gt;Make Moudle app 就可以生成aar了！</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>1.</strong> 主项目需要依赖AAR中所依赖的远程库，否则会出现ClassNotFound异常</p>
<p><strong>2.</strong> 资源命名最好统统加上你的项目名字前缀，比如图片资源、string、color、dimens、layout等等，反正res目录下所有文件最好都使用统一的加前缀命名，防止跟宿主app下的资源重复，因为aar引用跟源码引用起到的效果一样一样的，所有很容易出现资源重复引用的问题，所以加上前缀非常有必要。</p>
<p><strong>3.</strong> 如果在aar的MyAppliction里面使用了类的管理器，那么在打包成aar的时候需要将代码抽出来做个独立的类管理器，记住一点，打包成aar之后所有和application有关的东西都要检查替换，避免出现空指针异常。<br><strong>4.</strong> AAR模块用butterknife需要把资源R改为R2(批量替换)</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>arr打包</tag>
      </tags>
  </entry>
  <entry>
    <title>插件kotlin化</title>
    <url>/article/32d3c5f7/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>新版本的官方Gradle插件，都已经全部使用Kotlin来编写。用法比较简洁，如下所示</p>
<p>文件改变：</p>
<p>buld.gradle.kts</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">plugins &#123;<br>    `java-gradle-plugin`<br>    id(<span class="hljs-string">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version <span class="hljs-string">&quot;1.3.72&quot;</span><br>&#125;<br><br>repositories &#123;<br>    mavenCentral()<br>    google()<br>    jcenter()<br>&#125;<br><br>dependencies &#123;<br>    implementation(platform(<span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-bom&quot;</span>))<br>    implementation(<span class="hljs-string">&quot;com.android.tools.build:gradle:4.1.1&quot;</span>)<br>    implementation(<span class="hljs-string">&quot;org.ow2.asm:asm:9.1&quot;</span>)<br>&#125;<br><br>gradlePlugin &#123;<br>    <span class="hljs-keyword">val</span> greeting <span class="hljs-keyword">by</span> plugins.creating &#123;<br>        id = <span class="hljs-string">&quot;asmtest&quot;</span><br>        implementationClass = <span class="hljs-string">&quot;com.yw.asm.MyPlugin&quot;</span><br>    &#125;<br>&#125;<br><br>java.sourceCompatibility = JavaVersion.VERSION_1_8<br>java.targetCompatibility = JavaVersion.VERSION_1_8<br></code></pre></td></tr></table></figure>



<blockquote>
<p>tips：通过gradle init命令可以生成Kotlin版本的插件默认代码</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>插件kotlin化</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean架构介绍</title>
    <url>/article/857fda5c/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<p>项目地址：</p>
<p>https://github.com/android10/Android-CleanArchitecture</p>
<p>https://github.com/android10/Android-CleanArchitecture-Kotlin</p>
<p>该架构主要用于分离业务逻辑和底层的实现，提高项目的可维护性、拓展性。</p>
<br/>

<p>Clean 架构是由软件工程师 Robert C. Martin（也被称为 Uncle Bob）提出的。他在他的书籍《Clean Architecture》中详细介绍了这种架构模式，旨在构建易于理解、灵活、可维护和可测试的软件系统。</p>
<br/>

<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ol>
<li>实体层： 包含应用程序的业务实体和核心业务逻辑，是整个架构的核心。这一层不依赖于任何其他层，它定义了应用程序的核心模型和规则。</li>
<li>用例层： 也称为交互器或业务逻辑层，负责应用程序的具体用例和业务规则。用例层依赖于实体层，但不依赖于任何特定的框架或技术。</li>
<li>接口适配器层： 这一层包含了外部框架和工具，如数据库、UI、Web 等。它负责将用例层的业务逻辑适配到外部工具，同时也负责将外部数据转换为用例层所需的格式。</li>
<li>框架与驱动器层： 包含与外部设备、框架或工具的代码，比如 UI、数据库等。这一层依赖于接口适配器层，但并不直接影响核心业务逻辑。</li>
</ol>
<br/>

<h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>Clean Architecture 强调依赖规则，通过依赖倒置原则和单一职责原则来减少各层之间的耦合度：</p>
<ul>
<li>依赖倒置原则： 高层模块不应该依赖于底层模块，而是应该依赖于抽象接口。即，抽象不应该依赖于具体实现，具体实现应该依赖于抽象。这一原则使得不同层次的组件之间的依赖更加灵活，易于替换和扩展。</li>
<li>单一职责原则： 每个模块、类或函数都应该只有一个单一的责任。在 Clean Architecture 中，每一层都有其明确的职责，遵循单一职责原则有助于代码的清晰度和可维护性。</li>
</ul>
<br/>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：可维护性高、测试性强、可扩展性、独立性、降低耦合；</p>
<p>缺点：复杂程度增加、过度设计风险、对小型项目增加不必要的开发成本。</p>
<br/>

<h2 id="与MVVM的区别"><a href="#与MVVM的区别" class="headerlink" title="与MVVM的区别"></a>与MVVM的区别</h2><ol>
<li>关注点不同： Clean Architecture 更侧重于整体应用程序的架构设计和分层，强调业务逻辑和依赖规则的组织；而 MVVM 更专注于界面和数据的绑定、视图模型的设计。</li>
<li>依赖关系不同： Clean Architecture 强调解耦合，通过分层和依赖规则来降低各部分之间的耦合度；而 MVVM 主要解决视图和业务逻辑的解耦合。</li>
<li>应用场景不同： Clean Architecture 适用于各种规模的项目，特别是需要长期维护和扩展的大型项目；MVVM 更适用于需要复杂、动态用户界面的应用程序，特别是基于 UI 数据绑定的框架（比如 Android 中的 Data Binding ）。</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义插件</title>
    <url>/article/a2759747/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="自定义Gradle-插件"><a href="#自定义Gradle-插件" class="headerlink" title="自定义Gradle-插件"></a>自定义Gradle-插件</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在gradle中，插件大概可以分为三种类型，第一种是.gradle文件的插件，通过apply from的方式进行引用；第二种是插件对象，通过apply plugin的方式进行引用；第三种是单独项目的插件。</p>
<p>.gradle 形式的用得并不多，相对比较简单。这里主要介绍对象型插件的自定义方式。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;groovy&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br><br>repositories &#123;<br>    google()<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br><br>    implementation <span class="hljs-string">&quot;com.android.tools.build:gradle:4.2.1&quot;</span><br>    implementation gradleApi()<br>    implementation localGroovy()<br><br>    implementation <span class="hljs-string">&#x27;org.ow2.asm:asm:9.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.ow2.asm:asm-util:9.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.ow2.asm:asm-commons:9.2&#x27;</span><br>&#125;<br><br>gradlePlugin &#123;<br>    plugins &#123;<br>        greeting &#123;<br>            id = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>            implementationClass = <span class="hljs-string">&#x27;com.xs.track_asm.TrackPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>group = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br><br>uploadArchives &#123;<br>    repositories.mavenDeployer &#123;<br>        pom.groupId = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>        pom.artifactId = <span class="hljs-string">&#x27;track_asm&#x27;</span><br>        pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>        repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../repos&#x27;</span>))<br>    &#125;<br>&#125;<br><br><br>java &#123;<br>    sourceCompatibility = JavaVersion.VERSION_1_8<br>    targetCompatibility = JavaVersion.VERSION_1_8<br>&#125;<br><br><br><br>sourceSets &#123;<br>    main &#123;<br>        groovy &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/groovy&#x27;</span><br>        &#125;<br><br>        resources &#123;<br>            srcDir <span class="hljs-string">&#x27;src/main/resources&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>





<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>从gradle-7.0开始，apply plugin: ‘maven’  被移除掉了，因此uploadArchives 等方法将无法使用。需要用maven-publish 进行替换。</p>
<h2 id="gradle7-0之前"><a href="#gradle7-0之前" class="headerlink" title="gradle7.0之前"></a>gradle7.0之前</h2><p>导入maven</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">apply plugin: <span class="hljs-string">&#x27;maven&#x27;</span><br></code></pre></td></tr></table></figure>

<p>发布配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">uploadArchives &#123;<br>    repositories.mavenDeployer &#123;<br>        pom.groupId = <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>        pom.artifactId = <span class="hljs-string">&#x27;track_asm&#x27;</span><br>        pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>        repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;../repos&#x27;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发布命令：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">./gradlew uploadArchives<br></code></pre></td></tr></table></figure>





<h2 id="gradle7-0之后"><a href="#gradle7-0之后" class="headerlink" title="gradle7.0之后"></a>gradle7.0之后</h2><p>导入maven</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br></code></pre></td></tr></table></figure>

<p>发布配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">publishing &#123;<br>    publications &#123;<br>        mavenJava(MavenPublication) &#123;<br>            groupId <span class="hljs-string">&#x27;com.xs.track_asm&#x27;</span><br>            artifactId <span class="hljs-string">&#x27;track_asm&#x27;</span><br>            version <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>        &#125;<br>    &#125;<br><br>    repositories &#123;<br>        maven &#123; url uri(<span class="hljs-string">&#x27;../repos&#x27;</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发布命令：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">./gradlew publish<br></code></pre></td></tr></table></figure>



<h3 id="权限拒绝"><a href="#权限拒绝" class="headerlink" title="权限拒绝"></a>权限拒绝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">zsh: permission denied: ./gradlew<br></code></pre></td></tr></table></figure>

<p>执行： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">chmod +x gradlew<br></code></pre></td></tr></table></figure>



<h2 id="打包文档"><a href="#打包文档" class="headerlink" title="打包文档"></a>打包文档</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">javadoc &#123;<br>    options &#123;<br>        <span class="hljs-comment">//防止注释出现乱码</span><br>        encoding <span class="hljs-string">&quot;UTF-8&quot;</span><br>        charSet <span class="hljs-string">&#x27;UTF-8&#x27;</span><br>        author <span class="hljs-literal">true</span><br>        version <span class="hljs-literal">true</span><br>        links <span class="hljs-string">&quot;http://docs.oracle.com/javase/7/docs/api&quot;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h2><p>优点：在buildSrc中定义的插件，可以直接在其他module中运用</p>
<p>即直接apply具体的类，而不是其发布名称，不管做什么修改，都能马上体现，而不需要等到重新发布版本。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Hilt框架介绍</title>
    <url>/article/fd33f9e4/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<blockquote>
<p>Hilt是由Google推出的基于Dagger的依赖注入框架，它旨在简化Dagger在Android应用中的使用，并提供更多的便利性和易用性。</p>
<p>tips:先学习dagger再来看Hilt框架会简单很多。</p>
</blockquote>
<br/>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>简化配置和使用：Hilt通过简化Dagger的模板代码，提供了更简单的注入方式，减少了开发者需要编写的代码量。引入了一些默认的配置，使得在大多数情况下无需手动配置模块。</p>
<p>自动生成代码和更高的抽象层级：Hilt生成一些常见的依赖注入代码，减少了开发者需要手动编写的代码量。引入了一些高级抽象，例如@ViewModelInject注解，用于更方便地注入ViewModel。</p>
<p>组件化和测试：Hilt鼓励更模块化的设计，使得组件更易于测试和维护。通过更好地支持单元测试，使得测试更容易进行。</p>
<p>Android特定的优化和集成：Hilt提供了特定于Android的功能，比如支持Android组件的生命周期管理，与ViewModel的集成等。</p>
<br/>

<h3 id="Hilt和Dagger对比"><a href="#Hilt和Dagger对比" class="headerlink" title="Hilt和Dagger对比"></a>Hilt和Dagger对比</h3><table>
<thead>
<tr>
<th>简化点</th>
<th>Hilt</th>
<th>Dagger</th>
</tr>
</thead>
<tbody><tr>
<td>模板代码的减少</td>
<td>引入默认配置和标准化注解，减少模板代码量</td>
<td>需要手动编写较多的模板代码来配置依赖注入</td>
</tr>
<tr>
<td>Android组件的注入</td>
<td>使用@AndroidEntryPoint简化Android组件的依赖注入</td>
<td>需要手动配置每个Android组件的依赖注入</td>
</tr>
<tr>
<td>ViewModel的注入</td>
<td>使用@HiltViewModel和by viewModels()简化ViewModel注入</td>
<td>需要手动配置特定Provider来注入ViewModel</td>
</tr>
<tr>
<td>生命周期管理</td>
<td>自动处理Android组件的生命周期，简化依赖对象的管理</td>
<td>需要手动管理依赖对象的创建和销毁，处理生命周期可能较繁琐</td>
</tr>
<tr>
<td>默认绑定和作用域</td>
<td>提供默认的绑定和作用域配置，简化依赖注入的配置</td>
<td>需要手动配置绑定和作用域，可能容易出错或需要更多的手动设置</td>
</tr>
</tbody></table>
<br/>

<h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在项目级别的build.gradle文件中添加Hilt插件</span><br>classpath <span class="hljs-string">&#x27;com.google.dagger:hilt-android-gradle-plugin:版本号&#x27;</span><br><br><span class="hljs-comment">//在应用的build.gradle文件中</span><br><span class="hljs-comment">// 应用Hilt插件</span><br>apply plugin: <span class="hljs-string">&#x27;dagger.hilt.android.plugin&#x27;</span><br><br><span class="hljs-comment">// 添加Hilt依赖</span><br>implementation <span class="hljs-string">&#x27;com.google.dagger:hilt-android:版本号&#x27;</span><br>kapt <span class="hljs-string">&#x27;com.google.dagger:hilt-compiler:版本号&#x27;</span><br></code></pre></td></tr></table></figure>

<br/>

<h3 id="HiltAndroidApp注解"><a href="#HiltAndroidApp注解" class="headerlink" title="@HiltAndroidApp注解"></a>@HiltAndroidApp注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-title">extends</span> <span class="hljs-title">Application</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="AndroidEntryPoint注解"><a href="#AndroidEntryPoint注解" class="headerlink" title="@AndroidEntryPoint注解"></a>@AndroidEntryPoint注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> <span class="hljs-title">extends</span> <span class="hljs-title">AppCompatActivity</span> &#123;<br>  <br>    <span class="hljs-meta">@Inject</span><br>    SomeDependency someDependency;<br>  <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="HiltViewModel注解"><a href="#HiltViewModel注解" class="headerlink" title="@HiltViewModel注解"></a>@HiltViewModel注解</h3><p>@HiltViewModel 注解被添加到 ViewModel 类上，表示这是一个需要 Hilt 进行依赖注入的 ViewModel。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRepository</span> &#123;<br>    <span class="hljs-comment">// Repository 的具体实现</span><br>&#125;<br><br><span class="hljs-meta">@HiltViewModel</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> <span class="hljs-title">extends</span> <span class="hljs-title">ViewModel</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository repository;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">public</span> MyViewModel(MyRepository repository) &#123;<br>        <span class="hljs-keyword">this</span>.repository = repository;<br>    &#125;<br><br>    <span class="hljs-comment">// ViewModel 的逻辑方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Hilt在dagger的基础上专门对Android做了简化，让依赖注入框架使用起来更方便，毕竟dagger是java的依赖注入库。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT认证介绍</title>
    <url>/article/881e5f30/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="传统认证流程-Cookie-Session"><a href="#传统认证流程-Cookie-Session" class="headerlink" title="传统认证流程 Cookie + Session"></a>传统认证流程 Cookie + Session</h2><p>基本工作流程：</p>
<ol>
<li>用户登录：<ul>
<li>用户提供用户名和密码进行登录。</li>
<li>服务器验证用户提供的凭证，如果验证通过，则创建一个 Session。</li>
</ul>
</li>
<li>Session 创建：<ul>
<li>服务器为该用户创建一个唯一的 Session 对象，并将其标识符（Session ID）存储在服务器端。</li>
<li>同时，在响应中向用户的浏览器发送一个包含 Session ID 的 Cookie。</li>
</ul>
</li>
<li>Cookie 存储：<ul>
<li>浏览器收到服务器响应后，将包含 Session ID 的 Cookie 存储在本地。</li>
</ul>
</li>
<li>后续请求：<ul>
<li>用户在之后的每个请求中都会携带该 Cookie。</li>
<li>服务器收到请求时，从 Cookie 中提取 Session ID。</li>
<li>服务器使用提取的 Session ID 来识别用户的 Session，从而验证用户身份和状态。</li>
</ul>
</li>
<li>会话管理：<ul>
<li>服务器在 Session 中存储用户的状态信息，如登录状态、权限等。</li>
<li>每次请求都使用 Cookie 中的 Session ID 识别用户，并根据该 Session 获取或更新用户的状态信息。</li>
</ul>
</li>
<li>登出：<ul>
<li>当用户登出时，服务器会销毁相应的 Session，删除相关信息。</li>
<li>同时，服务器发送一个指示浏览器删除 Cookie 的响应，从而清除本地保存的 Session ID。</li>
</ul>
</li>
</ol>
<p>不足：如跨站点请求伪造（CSRF）攻击、服务器端需要存储会话信息等。</p>
<br/>

<h2 id="基于-Token-的认证方式"><a href="#基于-Token-的认证方式" class="headerlink" title="基于 Token 的认证方式"></a>基于 Token 的认证方式</h2><p>JWT（JSON Web Token）是一种用于安全传输信息的开放标准（RFC 7519），它通过一种紧凑且自包含的方式在各方之间安全地传递信息。JWT 主要由三部分组成，它们以点号分隔，形成一个字符串，具有如下结构：header.payload.signature</p>
<ul>
<li>Header（头部）：包含了关于生成的 Token 类型（JWT）和所使用的签名算法等元数据信息，通常以 JSON 格式表示。</li>
<li>Payload（载荷）：存放着 Token 的主体信息，如用户的身份信息、权限等数据，也是以 JSON 格式表示。Payload 可以包含一些预定义的声明（Registered Claims），例如过期时间（Expiration Time）等。</li>
<li>Signature（签名）：使用指定的算法对前面两部分的内容进行签名，确保 Token 没有被篡改。签名部分需要使用一个密钥进行加密，并与 Token 一起发送。</li>
</ul>
<p>工作流程：</p>
<ol>
<li>生成 Token：在服务端，根据用户提供的信息生成 JWT，包括指定的头部、载荷信息，并使用密钥生成签名部分。</li>
<li>传递 Token：将生成的 JWT 作为身份验证令牌发送给客户端（通常是通过 HTTP 头部传递），客户端通常将 Token 存储在本地。</li>
<li>验证和解析 Token：每次客户端发送请求时，都会携带 Token。服务端接收到请求后，解析 Token，验证签名，检查 Token 是否有效和完整。</li>
<li>处理有效 Token：如果 Token 有效并通过验证，服务端根据载荷中的信息，进行相应的操作，如用户认证、授权等。</li>
<li>Token 更新和续期：在 Token 过期之前，可以考虑更新 Token，续期用户的会话状态。</li>
</ol>
<p>JWT 的优势在于它的轻量、紧凑、自包含性和可扩展性，使得它成为在不同系统之间安全地传递信息的一种流行方式。</p>
<br/>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>JWT 默认是不加密，但也可以加密：JWT 默认不加密，但可以使用密钥进行签名，也可以选择加密整个令牌。签名是为了确保令牌的完整性和真实性。</li>
<li>不在 JWT 中存储敏感数据：JWT 可以包含信息，但不应存储敏感数据，特别是不应该在不加密的情况下存储敏感信息。</li>
<li>JWT 可用于信息交换和减少数据库查询：JWT 可以携带信息，允许客户端与服务器之间传递信息，避免了一些额外的数据库查询。</li>
<li>无法废止或修改有效期内的 Token：这是 JWT 的一个局限性。一旦签发，JWT 在到期之前都是有效的，服务器不能立即废止或修改其权限。需要额外的逻辑来处理失效的情况。</li>
<li>泄露可能导致权限被滥用：JWT 一旦泄露，持有者可以使用其中的信息进行认证。因此，建议设置较短的有效期，并对于重要的操作再次进行认证。</li>
<li>使用 HTTPS 传输 JWT：为了保证安全，不应该在 HTTP 下明文传输 JWT。使用 HTTPS 协议传输可以加密通信，确保令牌安全传输。</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg使用总结</title>
    <url>/article/4f6e9117/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="通用命令格式"><a href="#通用命令格式" class="headerlink" title="通用命令格式"></a>通用命令格式</h2><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">ffmpeg [全局参数] [输入文件参数] -i 输入文件地址 [输出文件参数] 输出文件地址<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>音视频格式转换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 output.avi<br></code></pre></td></tr></table></figure>

<p>调整视频尺寸：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vf scale=640:480 output.mp4<br></code></pre></td></tr></table></figure>

<p>裁剪视频：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -ss 00:00:10 -to 00:00:30 -c copy output.mp4<br></code></pre></td></tr></table></figure>

<p>提取音频：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vn -acodec copy output.mp3<br></code></pre></td></tr></table></figure>

<p>合并视频和音频：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac -strict experimental output.mp4<br></code></pre></td></tr></table></figure>

<p>添加水印：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -i watermark.png -filter_complex &quot;overlay=10:10&quot; output.mp4<br></code></pre></td></tr></table></figure>

<p>调整音量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp3 -af &quot;volume=1.5&quot; output.mp3<br></code></pre></td></tr></table></figure>

<p>提取视频帧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ffmpeg -i input.mp4 -vf &quot;select=&#x27;eq(n\,100)&#x27;&quot; -vsync vfr frame_%03d.png<br></code></pre></td></tr></table></figure>

<p>转gif：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">ffmpeg -i file.mov -r <span class="hljs-number">15</span> file.gif <span class="hljs-comment">//帧率15</span><br></code></pre></td></tr></table></figure>

<p>更多命令教程： https://wklchris.github.io/blog/FFmpeg/FFmpeg.html</p>
<br/>

<h2 id="常用模块库"><a href="#常用模块库" class="headerlink" title="常用模块库"></a>常用模块库</h2><p>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构。</p>
<p>libavcodec：用于各种类型音视频编解码</p>
<p>libavutil：包含一些公共的工具函数</p>
<p>libswscale：用于视频场景比例缩放、色彩映射转换等</p>
<p>libpostproc：用于后期效果处理等</p>
<p>libswresample：提供音频重采样功能，包括采样频率、声道格式等</p>
<p>libavfilter：用于滤波器处理，如音视频倍速、水平翻转、叠加文字等功能</p>
<p>libavdevice：包含输入输出设备的库，实现音视频数据的抓取或渲染</p>
<br/>

<p>命令行工具：</p>
<p>ffmpeg：编解码小工具，可用于格式转换、解码或电视卡即时编码等</p>
<p>ffserver：一个HTTP多媒体即时广播串流服务器</p>
<p>ffplay：一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示</p>
<br/>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《FFmpeg入门详解–音视频原理及应用》</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>dagger使用总结</title>
    <url>/article/e8d0b96f/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>dagger可以在编译时生成代码，创建实例，进行注入，同时对类型进行安全检查。</p>
<br/>

<h2 id="常用注解介绍"><a href="#常用注解介绍" class="headerlink" title="常用注解介绍"></a>常用注解介绍</h2><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>标记一个接口或抽象类，用于连接依赖的提供者和需要依赖的消费者。通过@Component注解的接口可以生成一个Dagger组件，该组件负责创建和维护依赖项的实例。</p>
<br/>

<h3 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h3><p>标记一个类，用于提供依赖项的实例。@Module注解的类包含一个或多个带有@Provides注解的方法，这些方法返回依赖项的实例。</p>
<br/>

<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h3><p>标记一个依赖项，使其成为单例实例。当一个依赖项被标记为@Singleton时，Dagger会确保只有一个实例被创建和共享。</p>
<br/>

<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>用于创建自定义的限定符注解。限定符注解允许在具有相同类型的多个依赖项之间进行区分。</p>
<br/>

<h3 id="Provides使用"><a href="#Provides使用" class="headerlink" title="@Provides使用"></a>@Provides使用</h3><p>用于标记@Module注解的类中的方法，该方法返回依赖项的实例。Dagger使用这些方法来构建和提供依赖项的实例。</p>
<p>如果您使用 @Provides 修饰两个方法，两个方法都返回同一个接口的不同实现实例，那么在使用 @Inject 注解进行依赖注入时，您可以通过限定符（Qualifier）来区分不同的实例。</p>
<br/>

<p>首先，您需要定义一个限定符注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FirstImplementation &#123;<br>&#125;<br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecondImplementation &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，您可以在 @Provides 方法中使用这些限定符注解来标识不同的实现实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Provides</span><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-meta">@FirstImplementation</span><br><span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">provideFirstImplementationA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstImplementationA</span>();<br>&#125;<br><br><span class="hljs-meta">@Provides</span><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-meta">@SecondImplementation</span><br><span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">provideSecondImplementationA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondImplementationA</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，在需要注入 InterfaceA 实例的地方，您可以使用相应的限定符注解进行注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-meta">@FirstImplementation</span><br>InterfaceA implementationA;<br></code></pre></td></tr></table></figure>

<p>这样，Dagger 将根据限定符注解来选择正确的实现实例进行注入。</p>
<p>请注意，限定符注解应确保在运行时保留（使用 @Retention(RetentionPolicy.RUNTIME) 注解），以便 Dagger 在运行时可以正确解析和匹配限定符注解。</p>
<br/>

<h3 id="Binds-使用场景"><a href="#Binds-使用场景" class="headerlink" title="@Binds  使用场景"></a>@Binds  使用场景</h3><p>接口绑定：当你有一个接口，并且想要将其绑定到一个具体的实现类时，可以使用@Binds注解。</p>
<p>@Binds方法必须是抽象的（abstract）且没有方法体，因为它只是用于建立接口和实现类之间的绑定关系。此外，@Binds方法必须位于抽象类或接口的模块中。</p>
<br/>

<h3 id="ContributesAndroidInjector"><a href="#ContributesAndroidInjector" class="headerlink" title="@ContributesAndroidInjector"></a>@ContributesAndroidInjector</h3><ul>
<li><p>Activity 和 Fragment：当想要在 Activity 或 Fragment 中进行依赖注入时，可以使用 @ContributesAndroidInjector 注解来帮助 Dagger 2 自动生成相应的子组件和注入器代码。</p>
</li>
<li><p>模块的子模块：当希望在一个 Dagger 模块中包含其他模块时，可以使用 @ContributesAndroidInjector 注解来简化子模块的配置。</p>
</li>
</ul>
<p>模块的子模块例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentModule</span> &#123;<br><br>    <span class="hljs-meta">@ContributesAndroidInjector(modules = [ChildModule::class])</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contributeChildInjector</span><span class="hljs-params">()</span></span>: ChildActivity<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="IntoSet"><a href="#IntoSet" class="headerlink" title="@IntoSet"></a>@IntoSet</h3><p>用于将多个实例绑定到一个 Set 集合中。这对于在依赖注入时提供多个实例的情况很有用，例如在一个接口有多个实现类时，想要将它们统一管理。</p>
<br/>

<p>以下是一个简单的例子，展示如何使用 @IntoSet 将多个实例绑定到一个 Set 中：</p>
<p>假设有两个实现了 Logger 接口的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">// 实现文件日志记录</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">// 实现控制台日志输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，在 Dagger 的模块中使用 @IntoSet 注解将这两个实例添加到 Set 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerModule</span> &#123;<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    Logger <span class="hljs-title function_">provideFileLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLogger</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    Logger <span class="hljs-title function_">provideConsoleLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleLogger</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，当你在依赖注入的地方请求一个 Set<Logger> 时，Dagger 将自动收集这两个实例并提供给你：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br>Set&lt;Logger&gt; loggers; <span class="hljs-comment">// Dagger 将注入包含两个 Logger 实例的 Set</span><br><br><span class="hljs-comment">// 使用 loggers 集合中的实例进行日志记录等操作</span><br></code></pre></td></tr></table></figure>

<p>这样，你可以将多个实例统一管理，方便地进行依赖注入和使用。</p>
<br/>

<h3 id="IntoMap"><a href="#IntoMap" class="headerlink" title="@IntoMap"></a>@IntoMap</h3><p>用于将依赖注入的实例添加到一个 Map 集合中，在 Dagger 中使用它可以方便地将多个实例与特定的键关联起来。</p>
<p>以下是一个简单的例子，展示如何使用 @IntoMap 将多个实例添加到 Map 中：</p>
<p>假设有一个接口 Processor，有两个实现类 AddProcessor 和 SubtractProcessor，并且想要将它们关联到一个 Map&lt;String, Processor&gt; 中，其中键为操作类型（”add” 或 “subtract”）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，在 Dagger 的模块中使用 @IntoMap 注解将这些实例添加到 Map 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessorModule</span> &#123;<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoMap</span><br>    <span class="hljs-meta">@StringKey(&quot;add&quot;)</span> <span class="hljs-comment">// 键为 &quot;add&quot;</span><br>    Processor <span class="hljs-title function_">provideAddProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddProcessor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoMap</span><br>    <span class="hljs-meta">@StringKey(&quot;subtract&quot;)</span> <span class="hljs-comment">// 键为 &quot;subtract&quot;</span><br>    Processor <span class="hljs-title function_">provideSubtractProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubtractProcessor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，当你在依赖注入的地方请求一个 Map&lt;String, Processor&gt; 时，Dagger 将自动收集这些实例并以特定的键关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br>Map&lt;String, Processor&gt; processorMap; <span class="hljs-comment">// Dagger 将注入包含键值对的 Map</span><br><br><span class="hljs-comment">// 使用 processorMap 中的实例进行对应操作的处理</span><br><span class="hljs-type">Processor</span> <span class="hljs-variable">addProcessor</span> <span class="hljs-operator">=</span> processorMap.get(<span class="hljs-string">&quot;add&quot;</span>);<br><span class="hljs-type">Processor</span> <span class="hljs-variable">subtractProcessor</span> <span class="hljs-operator">=</span> processorMap.get(<span class="hljs-string">&quot;subtract&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这样，你就可以使用键值对来管理和获取不同类型的实例，很方便地进行依赖注入和使用。</p>
<br/>

<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>可参考NextCloud开源项目</p>
<p>https://github.com/nextcloud/talk-android/tree/master</p>
<p>https://github.com/nextcloud/android</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewDragHelper源码剖析</title>
    <url>/article/bc17390a/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="ViewDragHelper源码剖析"><a href="#ViewDragHelper源码剖析" class="headerlink" title="ViewDragHelper源码剖析"></a>ViewDragHelper源码剖析</h2><p>创建方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mHelper = ViewDragHelper.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewDragCallback</span>());<br></code></pre></td></tr></table></figure>

<p>消息拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mEnable) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onInterceptTouchEvent(ev);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mHelper.shouldInterceptTouchEvent(ev);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>        ignored.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mEnable) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTouchEvent(event);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mHelper.processTouchEvent(event);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>        ignored.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="回调方法详解"><a href="#回调方法详解" class="headerlink" title="回调方法详解"></a>回调方法详解</h2><p>ViewDragHelper 是一个用于处理拖拽和滑动的辅助类，通常用于创建可拖拽的用户界面元素，比如实现拖拽移动或侧滑删除等功能。</p>
<br/>

<h3 id="onViewDragStateChanged-int-state"><a href="#onViewDragStateChanged-int-state" class="headerlink" title="onViewDragStateChanged(int state)"></a>onViewDragStateChanged(int state)</h3><p>当拖拽状态改变时调用，参数 state 表示当前的拖拽状态。</p>
<br/>

<h3 id="onViewPositionChanged-View-changedView-int-left-int-top-int-dx-int-dy"><a href="#onViewPositionChanged-View-changedView-int-left-int-top-int-dx-int-dy" class="headerlink" title="onViewPositionChanged(View changedView, int left, int top, int dx, int dy)"></a>onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</h3><p>当被拖拽的 View 的位置发生改变时调用，参数包括变化的 View、左上角的新位置坐标、水平和垂直方向上的位移。</p>
<br/>

<h3 id="onViewCaptured-View-capturedChild-int-activePointerId"><a href="#onViewCaptured-View-capturedChild-int-activePointerId" class="headerlink" title="onViewCaptured(View capturedChild, int activePointerId)"></a>onViewCaptured(View capturedChild, int activePointerId)</h3><p>当一个 View 被捕获时调用，参数为被捕获的 View 和触摸点的 ID。</p>
<br/>

<h3 id="onViewReleased-View-releasedChild-float-xvel-float-yvel"><a href="#onViewReleased-View-releasedChild-float-xvel-float-yvel" class="headerlink" title="onViewReleased(View releasedChild, float xvel, float yvel)"></a>onViewReleased(View releasedChild, float xvel, float yvel)</h3><p>当被捕获的 View 被释放时调用，参数包括被释放的 View 和释放时的水平和垂直速度。</p>
<br/>

<h3 id="onEdgeTouched-int-edgeFlags-int-pointerId"><a href="#onEdgeTouched-int-edgeFlags-int-pointerId" class="headerlink" title="onEdgeTouched(int edgeFlags, int pointerId)"></a>onEdgeTouched(int edgeFlags, int pointerId)</h3><p>当触摸到边缘时调用，参数包括边缘标志和触摸点的 ID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the left edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_LEFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the right edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_RIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the top edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_TOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Edge flag indicating that the bottom edge should be affected.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EDGE_BOTTOM</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="onEdgeLock-int-edgeFlags"><a href="#onEdgeLock-int-edgeFlags" class="headerlink" title="onEdgeLock(int edgeFlags)"></a>onEdgeLock(int edgeFlags)</h3><p>当边缘锁定时调用，返回一个布尔值表示是否锁定边缘。</p>
<p>如果锁定了，就不会调用onEdgeDragStarted函数。</p>
<br/>

<h3 id="onEdgeDragStarted-int-edgeFlags-int-pointerId"><a href="#onEdgeDragStarted-int-edgeFlags-int-pointerId" class="headerlink" title="onEdgeDragStarted(int edgeFlags, int pointerId)"></a>onEdgeDragStarted(int edgeFlags, int pointerId)</h3><p>当开始拖动边缘时调用，参数包括边缘标志和触摸点的 ID。</p>
<blockquote>
<p>需要注意的是，上面的3个回调函数默认都不会通知返回，需要我们额外调用mDragger.setEdgeTrackingEnabled（ViewDragHelper.EDGE_LEFT |ViewDragHelper.EDGE_TOP）来开启边缘捕捉功能。</p>
</blockquote>
<br/>

<h3 id="getOrderedChildIndex-int-index"><a href="#getOrderedChildIndex-int-index" class="headerlink" title="getOrderedChildIndex(int index)"></a>getOrderedChildIndex(int index)</h3><p>获取指定索引位置的子 View 的顺序。</p>
<br/>

<h3 id="getViewHorizontalDragRange-View-child"><a href="#getViewHorizontalDragRange-View-child" class="headerlink" title="getViewHorizontalDragRange(View child)"></a>getViewHorizontalDragRange(View child)</h3><p>返回水平方向上允许拖动的范围。</p>
<br/>

<h3 id="getViewVerticalDragRange-View-child"><a href="#getViewVerticalDragRange-View-child" class="headerlink" title="getViewVerticalDragRange(View child)"></a>getViewVerticalDragRange(View child)</h3><p>返回垂直方向上允许拖动的范围。</p>
<br/>

<h3 id="tryCaptureView-View-child-int-pointerId"><a href="#tryCaptureView-View-child-int-pointerId" class="headerlink" title="tryCaptureView(View child, int pointerId)"></a>tryCaptureView(View child, int pointerId)</h3><p>尝试捕获指定的 View，返回一个布尔值表示是否成功捕获。</p>
<p>View child：当前用户触摸的子控件的View对象。</p>
<p>pointerId：当前触摸此控件的手指所对应的pointerId。触摸过程中pointerId不变，但是其索引会改变。</p>
<p>return boolean：返回值，表示是否对这个View进行各种事件的捕捉。如果返回值为false，那么就表示不对这个View进行捕捉，在手指触摸到这个View及这个View发生变动时，ViewDragHelper.Callback中的回调函数不会有任何反馈。</p>
<br/>

<h3 id="clampViewPositionHorizontal-View-child-int-left-int-dx"><a href="#clampViewPositionHorizontal-View-child-int-left-int-dx" class="headerlink" title="clampViewPositionHorizontal(View child, int left, int dx)"></a>clampViewPositionHorizontal(View child, int left, int dx)</h3><p>在水平方向上限制 View 移动的位置。</p>
<p>View child：当前手指横向移动所在的子View。</p>
<p>int left：当前子View如果跟随手指移动，那么它即将移动到的位置的left坐标值就是这里的left。</p>
<p>int dx：手指横向移动的距离。</p>
<p>return int：返回子View的新left坐标值，系统会把该子View的left坐标移动到这个位置。在代码中如果return left，则是让View横向跟随手指移动。</p>
<br/>

<h3 id="clampViewPositionVertical-View-child-int-top-int-dy"><a href="#clampViewPositionVertical-View-child-int-top-int-dy" class="headerlink" title="clampViewPositionVertical(View child, int top, int dy)"></a>clampViewPositionVertical(View child, int top, int dy)</h3><p>在垂直方向上限制 View 移动的位置，和clampViewPositionHorizontal类似。</p>
<br/>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="captureChildView-View-childView-int-activePointerId"><a href="#captureChildView-View-childView-int-activePointerId" class="headerlink" title="captureChildView(View childView, int activePointerId)"></a>captureChildView(View childView, int activePointerId)</h3><p>绕过tryCaptureView，直接开启对指定View的捕捉功能。</p>
<p>View childView：要捕捉拖动动作的childView对象。</p>
<p>int activePointerId：激活当前childView进行捕捉操作的手指id。</p>
<p><strong>开启的捕捉功能，只会临时开启，当用户松手时，此次捕捉结束，回到初始状态。</strong></p>
<p><strong>通过captureChildView捕捉的childView，会根据手指的移动轨迹相对于自身的原始位置移动，而不会跑到手指下方来跟随手指移动。</strong></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>apk签名介绍</title>
    <url>/article/e77709f1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="如何确保消息正确？"><a href="#如何确保消息正确？" class="headerlink" title="如何确保消息正确？"></a>如何确保消息正确？</h2><p>客户端利用 Hash 算法针对数据得出一个摘要，使用公钥加密，连同对称加密的数据一起发送过去，服务端收到消息后，先利用对称密钥对内容解密，再进行 Hash 计算得出摘要。使用私钥将摘要内容解密，和再次计算得出的摘要作对比，一致就代表消息无误。</p>
<h2 id="如何保证公钥的正确性？"><a href="#如何保证公钥的正确性？" class="headerlink" title="如何保证公钥的正确性？"></a>如何保证公钥的正确性？</h2><p>使用数字证书，包含的信息有：</p>
<p>主体信息：证书的主体是公钥的拥有者</p>
<p>公钥：证书中包含了公钥的信息，用于进行加密或数字签名验证</p>
<p>证书颁发者（CA）信息：证书颁发者是证书的签发机构</p>
<p>证书有效期：包括证书的起始日期和截止日期</p>
<p>数字签名：证书内容经过 CA 使用私钥进行数字签名，验证方可以使用 CA 的公钥对签名进行验证</p>
<p>证书序列号：唯一标识证书的序列号，用于区分不同的证书</p>
<p>扩展信息：包括一些额外的信息，如密钥用途、颁发者策略等</p>
<h2 id="ADB增量APK安装"><a href="#ADB增量APK安装" class="headerlink" title="ADB增量APK安装"></a>ADB增量APK安装</h2><p>生成差分文件》生成增量补丁》传输并应用增量补丁</p>
<p>可行性检测： adb install –incremental</p>
<p>增量安装时，adb 会要求 .apk.idsig 文件存在于 .apk 旁边（APK v4的签名文件.apk.idsig并不会打包进apk文件中）</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>https://blog.csdn.net/chzphoenix/article/details/130130934</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket介绍</title>
    <url>/article/a0966911/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="WebSocket介绍"><a href="#WebSocket介绍" class="headerlink" title="WebSocket介绍"></a>WebSocket介绍</h2><p>基于TCP协议，客户端和服务端保持长连接，使用帧（Frame）来封装和传输数据，采用事件驱动，使用加密的 WebSocket（wss:&#x2F;&#x2F;）连接，支持跨域通信，常用语聊天、实时协作等需要实时数据推送的场景。</p>
<br/>

<h2 id="Android中使用"><a href="#Android中使用" class="headerlink" title="Android中使用"></a>Android中使用</h2><p>借助 OkHttp 可以很轻易的实现 WebSocket，它的 OkHttpClient 中，提供了 newWebSocket() 方法，可以直接建立一个 WebSocket 连接并完成通信。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionWebSockt</span><span class="hljs-params">(hostName:<span class="hljs-type">String</span>,port:<span class="hljs-type">Int</span>)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> httpClient = OkHttpClient.Builder()<br>      .pingInterval(<span class="hljs-number">40</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 设置 PING 帧发送间隔</span><br>      .build()<br>  <span class="hljs-keyword">val</span> webSocketUrl = <span class="hljs-string">&quot;ws://<span class="hljs-subst">$&#123;hostName&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>&quot;</span><br>  <span class="hljs-keyword">val</span> request = Request.Builder()<br>      .url(webSocketUrl)<br>      .build()<br>  httpClient.newWebSocket(request, <span class="hljs-keyword">object</span>:WebSocketListener()&#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onOpen(webSocket, response)<br>      <span class="hljs-comment">// WebSocket 连接建立</span><br>      mWebSocket = webSocket<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, text: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onMessage(webSocket, text)<br>      <span class="hljs-comment">// 收到服务端发送来的 String 类型消息</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosing</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosing(webSocket, code, reason)<br>      <span class="hljs-comment">// 收到服务端发来的 CLOSE 帧消息，准备关闭连接</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosed</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosed(webSocket, code, reason)<br>      <span class="hljs-comment">// WebSocket 连接关闭</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, t: <span class="hljs-type">Throwable</span>, response: <span class="hljs-type">Response</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onFailure(webSocket, t, response)<br>      <span class="hljs-comment">// 出错了</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="MockWebSocket"><a href="#MockWebSocket" class="headerlink" title="MockWebSocket"></a>MockWebSocket</h2><p>有时候为了方便我们测试，OkHttp 还提供了扩展的 MockWebSocket 服务，来模拟服务端。</p>
<p>MockWebSocket 需要添加额外的 Gradle 引用，最好和 OkHttp 版本保持一致：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">api <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:3.9.1&#x27;</span><br>api <span class="hljs-string">&#x27;com.squareup.okhttp3:mockwebserver:3.9.1&#x27;</span><br></code></pre></td></tr></table></figure>

<p>MockWebServer 的使用也非常简单，只需要利用 MockWebSocket 类即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> mMockWebSocket: MockWebServer? = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mockWebSocket</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (mMockWebSocket != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  mMockWebSocket = MockWebServer()<br>  mMockWebSocket?.enqueue(MockResponse().withWebSocketUpgrade(<span class="hljs-keyword">object</span> : WebSocketListener() &#123;<br>     <span class="hljs-comment">//...</span><br> &#125;))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>c++锁的使用总结</title>
    <url>/article/f80a2866/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h2><p>可以传递参数： 参数是一个枚举值，可以是 std::defer_lock、std::adopt_lock。</p>
<p>使用 std::adopt_lock 时，std::unique_lock 对象会认为互斥量已经被锁定，因此它不会尝试再次锁定互斥量。而是直接将自己关联到已锁定的互斥量上，然后你可以在合适的地方使用这个 std::unique_lock 对象来解锁。</p>
<p>std::try_lock 允许一次性尝试锁定多个互斥量，如果无法成功锁定所有互斥量，则不会阻塞线程，并返回适当的结果。</p>
<p>std::once_flag 和 std::call_once：这些用于实现只执行一次的操作，保证在多线程环境中某个函数只会被执行一次。</p>
<br/>

<h2 id="std-shared-lock"><a href="#std-shared-lock" class="headerlink" title="std::shared_lock"></a>std::shared_lock</h2><p> 可以同时被多个线程持有，允许并发的共享访问。</p>
<p>pthread_rwlock_t 是 POSIX 线程库中提供的一种读写锁（Read-Write Lock）。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。 </p>
<br/>

<h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard 是一个轻量级的互斥锁封装，用于在代码块中自动锁定和解锁互斥量。它的锁定和解锁是在构造和析构函数中完成的，适用于需要在作用域内自动管理锁定的场景。 </p>
<br/>

<h2 id="std-scoped-lock"><a href="#std-scoped-lock" class="headerlink" title="std::scoped_lock"></a>std::scoped_lock</h2><p>是 C++11 引入的一个锁，用于同时锁定多个互斥量，实现死锁避免和提高代码可读性。与 std::lock 不同，std::scoped_lock 是在构造时锁定互斥量，在析构时解锁互斥量，从而确保在任何情况下都会正确释放锁。 </p>
<br/>

<h2 id="递归锁（std-recursive-mutex）"><a href="#递归锁（std-recursive-mutex）" class="headerlink" title="递归锁（std::recursive_mutex）"></a>递归锁（std::recursive_mutex）</h2><p>递归锁（std::recursive_mutex）允许同一个线程多次获取锁，这在某些递归调用的情况下非常有用。 </p>
<br/>

<h2 id="自旋锁（std-atomic-flag）"><a href="#自旋锁（std-atomic-flag）" class="headerlink" title="自旋锁（std::atomic_flag）"></a>自旋锁（std::atomic_flag）</h2><p>自旋锁不是标准库提供的，但是可以使用原子标志（std::atomic_flag）实现。它在尝试获得锁失败时，不会进入休眠状态，而是一直在一个循环中自旋等待锁被释放。适用于短时间内锁被占用的情况。</p>
<br/>

<h2 id="FIFO支持"><a href="#FIFO支持" class="headerlink" title="FIFO支持"></a>FIFO支持</h2><p>在 C++ 标准库中，std::mutex 和 std::unique_lock 是不支持 FIFO（先来先服务）策略的锁，因为它们的锁定顺序不受先后顺序的限制，而是由操作系统或编译器实现来决定。</p>
<p>C++17 引入了一种新的锁类型 std::shared_mutex，它在共享锁定时支持 FIFO 策略，这意味着等待共享锁的线程会按照它们请求锁的顺序依次获得锁。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ xlog源码剖析</title>
    <url>/article/5ee48928/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="库简介"><a href="#库简介" class="headerlink" title="库简介"></a>库简介</h2><p>xlog属于mars项目的一个小组件，主要解决线上程序崩溃后日志消失的问题。崩溃日志往往在内存中，程序crash后，无法记录内存中的日志，导致无法捕获到对应关键的crash日志信息。该库主要采用mmap的方法进行日志系统设计，主要功能包含压缩、加密、写入文件等。</p>
<p>源码地址：https://github.com/Tencent/mars/tree/49c4bcf49fd8a80bfc8e1efaabdc71202542f4d3/mars/xlog</p>
<br/>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>开辟一块内存，对文件进行映射，日志到来时通通写入到该内存中，当内存内容达到阈值时，开始将内存中的内容上锁，另一个线程开始工作，将该内存中的日志信息写入到硬盘文件中。这里的内存也叫高速缓冲区，避免了频繁地对文件写操作。</p>
<br/>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为啥会映射一小块，等到小块满了之后再挨个读取写入到文件中，而不是一开始就对整个文件进行映射呢？或者采用滑动窗口方式，先映射一小块，满了再往后滑动窗口，实现文件分块映射呢？</p>
<p>看源码发现项目中主要使用的是boost的方法来做内存映射。</p>
<p>boost库中的文件映射源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Path&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mapped_file::open</span><span class="hljs-params">(<span class="hljs-type">const</span> basic_mapped_file_params&lt;Path&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123; delegate_.<span class="hljs-built_in">open_impl</span>(p); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Path&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mapped_file::open</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Path&amp; path, mapmode flags, </span></span><br><span class="hljs-params"><span class="hljs-function">    size_type length, stream_offset offset )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">param_type <span class="hljs-title">p</span><span class="hljs-params">(path)</span></span>;<br>    p.flags = flags;<br>    p.length = length;<br>    p.offset = offset;<br>    <span class="hljs-built_in">open</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从源码来看似乎是可行的，xlog主要是使用第一个open方法进行映射文件，那第二个方法呢？这里我做了个小实验，使用第二个open方法进行文件映射，遗憾的是结果并不成功，会报错。内部是不支持，无论是更改窗口大小或者更改偏移量offset，都是会映射失败的，有感兴趣的朋友可以尝试下。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>FlutterBoost源码剖析</title>
    <url>/article/a56a3a15/</url>
    <content><![CDATA[<p>[TOC]</p>
<blockquote>
<p>FlutterBoost 的理念是使用 Flutter 就像使用 WebView 一样简单。FlutterBoost 会为您处理页面分辨率。唯一需要关心的是页面的名称（通常可以是 URL）。</p>
</blockquote>
<p>官方源码： https://github.com/alibaba/flutter_boost</p>
<br/>

<h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ul>
<li>Flutter SDK升级不需要Boost升级</li>
<li>简化架构</li>
<li>简化界面</li>
<li>双端接口统一设计</li>
<li>解决了首要问题</li>
<li>Android不需要区分AndroidX和Support</li>
</ul>
<br/>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="FlutterApplication初始化"><a href="#FlutterApplication初始化" class="headerlink" title="FlutterApplication初始化"></a>FlutterApplication初始化</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 1. initialize default engine</span><br><span class="hljs-comment">// 2. set delegate</span><br><span class="hljs-comment">// 3. register ActivityLifecycleCallbacks</span><br></code></pre></td></tr></table></figure>

<p>声明周期监听，前后台变化isBackForegroundEventOverridden参数控制，只要没有复写前后台方法，那么默认原生的前后台变化和flutter同步，同时解决对外提供的currentActivity方法。</p>
<p>预加载操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (!engine.getDartExecutor().isExecutingDart()) &#123;<br>    <span class="hljs-comment">// Pre-warm the cached FlutterEngine.</span><br>    engine.getNavigationChannel().setInitialRoute(options.initialRoute());<br>    engine.getDartExecutor().executeDartEntrypoint(<span class="hljs-keyword">new</span> DartExecutor.DartEntrypoint(<br>            FlutterMain.findAppBundlePath(), options.dartEntrypoint()), options.dartEntrypointArgs());<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="flutterview构造"><a href="#flutterview构造" class="headerlink" title="flutterview构造"></a>flutterview构造</h3><p>flutterboost在构造flutterview时传入一个surfaceview或者textureview，为啥会传入这两个呢，而不是view？主要的原因还是flutter页面的会有大量的图形渲染的操作，需要一个支持硬件加速的view的来显示。</p>
<p>将surface进行传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Start rendering on the previous surface.</span><br><span class="hljs-comment">// This surface is typically `FlutterSurfaceView` or `FlutterTextureView`.</span><br>renderSurface.attachToRenderer(renderer);<br></code></pre></td></tr></table></figure>

<p>下面是flutterview的创建过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><br>View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(</span><br><span class="hljs-params">    LayoutInflater inflater,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> ViewGroup container,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> flutterViewId,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> shouldDelayFirstAndroidViewDraw)</span> &#123;<br>  Log.v(TAG, <span class="hljs-string">&quot;Creating FlutterView.&quot;</span>);<br>  ensureAlive();<br><br>  <span class="hljs-keyword">if</span> (host.getRenderMode() == RenderMode.surface) &#123;<br>    <span class="hljs-type">FlutterSurfaceView</span> <span class="hljs-variable">flutterSurfaceView</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterSurfaceView</span>(<br>            host.getContext(), host.getTransparencyMode() == TransparencyMode.transparent);<br><br>    <span class="hljs-comment">// Allow our host to customize FlutterSurfaceView, if desired.</span><br>    host.onFlutterSurfaceViewCreated(flutterSurfaceView);<br><br>    <span class="hljs-comment">// Create the FlutterView that owns the FlutterSurfaceView.</span><br>    flutterView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterView</span>(host.getContext(), flutterSurfaceView);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">FlutterTextureView</span> <span class="hljs-variable">flutterTextureView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterTextureView</span>(host.getContext());<br><br>    flutterTextureView.setOpaque(host.getTransparencyMode() == TransparencyMode.opaque);<br><br>    <span class="hljs-comment">// Allow our host to customize FlutterSurfaceView, if desired.</span><br>    host.onFlutterTextureViewCreated(flutterTextureView);<br><br>    <span class="hljs-comment">// Create the FlutterView that owns the FlutterTextureView.</span><br>    flutterView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterView</span>(host.getContext(), flutterTextureView);<br>  &#125;<br><br>  <span class="hljs-comment">// Add listener to be notified when Flutter renders its first frame.</span><br>  flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener);<br><br>  Log.v(TAG, <span class="hljs-string">&quot;Attaching FlutterEngine to FlutterView.&quot;</span>);<br>  flutterView.attachToFlutterEngine(flutterEngine);<br>  flutterView.setId(flutterViewId);<br><br>  <span class="hljs-type">SplashScreen</span> <span class="hljs-variable">splashScreen</span> <span class="hljs-operator">=</span> host.provideSplashScreen();<br><br>  <span class="hljs-keyword">if</span> (splashScreen != <span class="hljs-literal">null</span>) &#123;<br>    Log.w(<br>        TAG,<br>        <span class="hljs-string">&quot;A splash screen was provided to Flutter, but this is deprecated. See&quot;</span><br>            + <span class="hljs-string">&quot; flutter.dev/go/android-splash-migration for migration steps.&quot;</span>);<br>    <span class="hljs-type">FlutterSplashView</span> <span class="hljs-variable">flutterSplashView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterSplashView</span>(host.getContext());<br>    flutterSplashView.setId(ViewUtils.generateViewId(FLUTTER_SPLASH_VIEW_FALLBACK_ID));<br>    flutterSplashView.displayFlutterViewWithSplash(flutterView, splashScreen);<br><br>    <span class="hljs-keyword">return</span> flutterSplashView;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (shouldDelayFirstAndroidViewDraw) &#123;<br>    delayFirstAndroidViewDraw(flutterView);<br>  &#125;<br>  <span class="hljs-keyword">return</span> flutterView;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="Pigeon插件使用"><a href="#Pigeon插件使用" class="headerlink" title="Pigeon插件使用"></a>Pigeon插件使用</h3><p>通过查看flutterBoost源码可以发现，内部flutter和原生通信的主要借助了一个名叫Pigeon的代码生成器工具。Pigeon是一个flutter插件，主要有以下优点：</p>
<ul>
<li>自动生成通信代码：根据开发者定义的数据结构和方法生成相应的Dart和原生平台的通信代码，简化了跨平台通信的实现过程。</li>
<li>定义消息传递格式： 开发者可以使用Pigeon定义数据结构和方法，包括参数和返回值的类型、方法的名称等，以便在Flutter和原生代码之间进行消息传递。</li>
<li>支持异步通信：能够处理异步方法调用，允许Flutter与原生代码之间进行异步操作。</li>
<li>增强了类型安全性： 通过Pigeon生成的代码，可以提供类型安全性，避免在不同平台之间传递数据时的类型错误。</li>
</ul>
<p>@HostApi()&#x2F;&#x2F; 用于Flutter调用原生的方法，原生方法实现</p>
<p>@FlutterApi()&#x2F;&#x2F; 用于原生调用Flutter的方法，Flutter方法实现</p>
<p>最终自动生成的接口方法等可参考Messages类。</p>
<blockquote>
<p>思考：如何自动生成代码的呢？</p>
<p>build_runner和source_gen</p>
</blockquote>
<br/>

<h3 id="自定义的FlutterBoostPlugin插件"><a href="#自定义的FlutterBoostPlugin插件" class="headerlink" title="自定义的FlutterBoostPlugin插件"></a>自定义的FlutterBoostPlugin插件</h3><p>为何会有flutter插件，主要是允许开发者在 Flutter 应用中集成原生代码或第三方库，调用 flutterEngine.getPlugins() 方法可以获得当前 Flutter 引擎中加载的所有插件的列表。</p>
<p>插件注册多数情况下是在原生端完成，利用原生平台的特定功能和能力，极少数是在flutter端注册的。</p>
<p>来看看FlutterBoostPlugin插件的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlutterBoostPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlutterPlugin</span>, NativeRouterApi, ActivityAware &#123;<br></code></pre></td></tr></table></figure>

<p>NativeRouterApi：主要是原生导航相关的接口方法，用于在flutter端调用；</p>
<p>ActivityAware：用于在 Flutter 插件中获取和管理 Android Activity 的接口，在Activity 生命周期中接收回调。</p>
<p>功能作用：</p>
<p>用于在 Flutter 和原生 Android（或 iOS）之间建立桥接，提供了一种在原生应用中嵌入 Flutter 页面的机制。它的主要功能包括：页面路由管理、混合开发支持、生命周期管理、跨平台支持等。</p>
<br/>

<h3 id="FlutterViewContainer"><a href="#FlutterViewContainer" class="headerlink" title="FlutterViewContainer"></a>FlutterViewContainer</h3><p>实现类主要有：FlutterBoostActivity、FlutterBoostFragment、FlutterBoostView；</p>
<p>其中FlutterBoostView继承于LifecycleView、而LifecycleView继承于FrameLayout；</p>
<p>ViewContainer的显示过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onContainerAppeared</span><span class="hljs-params">(FlutterViewContainer container, Runnable onPushRouteComplete)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uniqueId</span> <span class="hljs-operator">=</span> container.getUniqueId();<br>    <span class="hljs-keyword">if</span> (isDebugLoggingEnabled()) Log.d(TAG, <span class="hljs-string">&quot;#onContainerAppeared: &quot;</span> + uniqueId + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">this</span>);<br>    FlutterContainerManager.instance().activateContainer(uniqueId, container);<br>    pushRoute(uniqueId, container.getUrl(), container.getUrlParams(), reply -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (FlutterContainerManager.instance().isTopContainer(uniqueId)) &#123;<br>            <span class="hljs-keyword">if</span> (onPushRouteComplete != <span class="hljs-literal">null</span>) &#123;<br>                onPushRouteComplete.run();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//onContainerDisappeared并非异步触发，为了匹配对应，onContainerShow也不做异步</span><br>    onContainerShow(uniqueId);<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="BoostInterceptor使用"><a href="#BoostInterceptor使用" class="headerlink" title="BoostInterceptor使用"></a>BoostInterceptor使用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;T&gt; pushWithInterceptor&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>      <span class="hljs-built_in">String?</span> name, <span class="hljs-built_in">bool</span> isFromHost, <span class="hljs-built_in">bool</span> isFlutterPage,<br>      &#123;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;? arguments,<br>      <span class="hljs-built_in">String?</span> uniqueId,<br>      <span class="hljs-built_in">bool?</span> withContainer,<br>      <span class="hljs-built_in">bool</span> opaque = <span class="hljs-keyword">true</span>&#125;) &#123;<br>    Logger.log(<span class="hljs-string">&#x27;pushWithInterceptor, uniqueId=<span class="hljs-subst">$uniqueId</span>, name=<span class="hljs-subst">$name</span>&#x27;</span>);<br>    <span class="hljs-keyword">var</span> pushOption = BoostInterceptorOption(name,<br>        uniqueId: uniqueId,<br>        isFromHost: isFromHost,<br>        arguments: arguments ?? &lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&#123;&#125;);<br>    InterceptorState&lt;BoostInterceptorOption&gt;? state =<br>        InterceptorState&lt;BoostInterceptorOption&gt;(pushOption);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> interceptor <span class="hljs-keyword">in</span> interceptors) &#123;<br>      <span class="hljs-keyword">final</span> pushHandler = PushInterceptorHandler();<br>      interceptor.onPrePush(state!.data, pushHandler);<br><br>      <span class="hljs-comment">// user resolve or do nothing</span><br>      <span class="hljs-keyword">if</span> (pushHandler.state?.type != InterceptorResultType.next) &#123;<br>        Logger.log(<span class="hljs-string">&#x27;The page was intercepted by user. name:<span class="hljs-subst">$name</span>, &#x27;</span><br>            <span class="hljs-string">&#x27;isFromHost=<span class="hljs-subst">$isFromHost</span>, isFlutterPage=<span class="hljs-subst">$isFlutterPage</span>&#x27;</span>);<br>        <span class="hljs-keyword">return</span> Future&lt;T&gt;.value(state.data <span class="hljs-keyword">as</span> T);<br>      &#125;<br>      state = pushHandler.state <span class="hljs-keyword">as</span> InterceptorState&lt;BoostInterceptorOption&gt;?;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (state?.type == InterceptorResultType.next) &#123;<br>      pushOption = state!.data;<br>      <span class="hljs-keyword">if</span> (isFromHost) &#123;<br>        pushContainer(name,<br>            uniqueId: pushOption.uniqueId,<br>            isFromHost: isFromHost,<br>            arguments: pushOption.arguments);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFlutterPage) &#123;<br>          <span class="hljs-keyword">return</span> pushWithResult(pushOption.name,<br>              uniqueId: pushOption.uniqueId,<br>              arguments: pushOption.arguments,<br>              withContainer: withContainer!,<br>              opaque: opaque);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">final</span> params = CommonParams()<br>            ..pageName = pushOption.name<br>            ..arguments = pushOption.arguments;<br>          nativeRouterApi.pushNativeRoute(params);<br>          <span class="hljs-keyword">return</span> pendNativeResult(pushOption.name);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Future&lt;T&gt;.value();<br>  &#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="BoostFlutterBinding"><a href="#BoostFlutterBinding" class="headerlink" title="BoostFlutterBinding"></a>BoostFlutterBinding</h3><p>主要作用：接管flutter的生命周期。</p>
<p>BoostFlutterBinding对WidgetsFlutterBinding进行了扩展，复写了initInstances和handleAppLifecycleStateChanged这两个方法。</p>
<p>思考：BoostFlutterBinding是如何拦截到生命周期进行处理的呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>  ...<br>  CustomFlutterBinding();<br>  ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFlutterBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WidgetsFlutterBinding</span></span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">BoostFlutterBinding</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>从官方给的demo看必须要new一个FlutterBinding实例才可以，其实原理和WidgetsFlutterBinding的ensureInitialized()方法类似。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> WidgetsBinding ensureInitialized() &#123;<br>  <span class="hljs-keyword">if</span> (WidgetsBinding._instance == <span class="hljs-keyword">null</span>) &#123;<br>    WidgetsFlutterBinding();<br>  &#125;<br>  <span class="hljs-keyword">return</span> WidgetsBinding.instance;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BoostContainer使用"><a href="#BoostContainer使用" class="headerlink" title="BoostContainer使用"></a>BoostContainer使用</h3><br/>

<h3 id="如何理解BoostContainerWidget"><a href="#如何理解BoostContainerWidget" class="headerlink" title="如何理解BoostContainerWidget"></a>如何理解BoostContainerWidget</h3><p>持有container，小组件所属的container；</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">The Widget build for a [BoostContainer]</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">It overrides the &quot;==&quot; and &quot;hashCode&quot;,</span></span><br><span class="hljs-comment">/// <span class="language-markdown">to avoid rebuilding when its parent element call element.updateChild</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoostContainerWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  BoostContainerWidget(&#123;LocalKey? key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.container&#125;)<br>      : <span class="hljs-keyword">super</span>(key: container.key);<br><br>  <span class="hljs-comment">/// <span class="language-markdown">The container this widget belong</span></span><br>  <span class="hljs-keyword">final</span> BoostContainer container;<br></code></pre></td></tr></table></figure>

<p>BoostContainerWidget外面包裹的是OverlayEntry，源码如下，该OverlayEntry是不透明，且状态保留的，可以进行复用。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerOverlayEntry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OverlayEntry</span> </span>&#123;<br>  ContainerOverlayEntry(BoostContainer container)<br>      : containerUniqueId = container.pageInfo.uniqueId,<br>        <span class="hljs-keyword">super</span>(<br>            builder: (ctx) =&gt; BoostContainerWidget(container: container),<br>            opaque: <span class="hljs-keyword">true</span>,<br>            maintainState: <span class="hljs-keyword">true</span>);<br><br>  <span class="hljs-comment">/// <span class="language-markdown">This overlay&#x27;s id, which is the same as the it&#x27;s related container</span></span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String?</span> containerUniqueId;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="flutter页面核心部分"><a href="#flutter页面核心部分" class="headerlink" title="flutter页面核心部分"></a>flutter页面核心部分</h3><p>页面的父widget是一个Overlay组件。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">      child: Listener(<br>          onPointerDown: _handlePointerDown,<br>          onPointerUp: _handlePointerUpOrCancel,<br>          onPointerCancel: _handlePointerUpOrCancel,<br>          child: Overlay(<br>            key: overlayKey,<br>            initialEntries: <span class="hljs-keyword">const</span> &lt;OverlayEntry&gt;[],<br>          ))));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双层路由栈"><a href="#双层路由栈" class="headerlink" title="双层路由栈"></a>双层路由栈</h3><br/>

<h2 id="路由导航–NavigatorExt"><a href="#路由导航–NavigatorExt" class="headerlink" title="路由导航–NavigatorExt"></a>路由导航–NavigatorExt</h2><p>这个类让用户调用“Navigator.pop()”等于BoostNavigator.instance.pop()</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Future&lt;T?&gt; pushNamed&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<span class="hljs-built_in">String</span> routeName,<br>    &#123;<span class="hljs-built_in">Object?</span> arguments&#125;) &#123;<br>...<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> pop&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;([T? result]) &#123;<br>  <span class="hljs-comment">// Taking over container page</span><br>  <span class="hljs-keyword">if</span> (!canPop()) &#123;<br>    BoostNavigator.instance.pop(result ?? &#123;&#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">super</span>.pop(result);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的源码看出，只是把pop方法复写了，为啥可以实现等价调用呢？是在什么时候调用到BoostNavigator.instance.pop()的呢？</p>
<p>继续，进入Navigator.of(context)方法查看，可以发现它会调用findAncestorStateOfType来查找，从父节点找最近的State，实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> NavigatorState of(<br> BuildContext context, &#123;<br> <span class="hljs-built_in">bool</span> rootNavigator = <span class="hljs-keyword">false</span><br>&#125;) &#123;<br>...<br>navigator = navigator ?? context.findAncestorStateOfType&lt;NavigatorState&gt;();<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="BoostContainerState"><a href="#BoostContainerState" class="headerlink" title="BoostContainerState"></a>BoostContainerState</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Widget build(BuildContext context) &#123;<br>  <span class="hljs-keyword">return</span> HeroControllerScope(<br>      controller: HeroController(),<br>      child: NavigatorExt(<br>        key: container._navKey,<br>        pages: <span class="hljs-built_in">List</span>&lt;Page&lt;<span class="hljs-built_in">dynamic</span>&gt;&gt;.of(container.pages),<br>        onPopPage: (route, result) &#123;<br>          <span class="hljs-keyword">if</span> (route.didPop(result)) &#123;<br>            <span class="hljs-keyword">assert</span>(route.settings <span class="hljs-keyword">is</span> BoostPage);<br>            _updatePagesList(route.settings <span class="hljs-keyword">as</span> BoostPage, result);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;,<br>        observers: &lt;NavigatorObserver&gt;[<br>          BoostNavigatorObserver(),<br>        ],<br>      ));<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>flutterboost核心使用单引擎处理flutter，原生页面跳转flutter页面，用到了一个flutteractivity类。</li>
<li>flutterfragment主要是在fragment中集成flutter，flutteractivity则是在activity中展示完整的flutter页面，而flutterfragmentactivity则是在activity页面中展示部分flutter页面。</li>
<li>package io.flutter.embedding.android：主要是放一些Android中展示flutter相关的一些工具类或者接口等。例如要在原生页面中展示一个flutterview，则需要把自定义的类写到这个包中；</li>
<li>flutterview的构造需要一个surfaceview或者textureview来显示flutter内容，为啥一定需要这么两个中的一个，因为他们都支持硬件加速，flutterview会涉及到大量的图像渲染内容，且是在原生中显示，则需要一个view来承接内容。</li>
<li>flutterboost主要是通过Pigeon插件来实现原生交互，flutter端的页面均继承于OverlayEntry，插件有自定义Navigator，用于对原来的Navigator.pop等方法进行补充。在原生页面中打开flutter页面，本质上是启动一个Activity来承载显示flutter的view，如果是跳转不同的flutter页面，可以通过url来定位，并且flutter端有自定义的拦截器，可以对跳转等操作进行拦截处理。</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter FFI源码剖析</title>
    <url>/article/96ba32cc/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<h2 id="ffi调用原理"><a href="#ffi调用原理" class="headerlink" title="ffi调用原理"></a>ffi调用原理</h2><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> DynamicLibrary nativeAddLib = Platform.isAndroid<br>    ? DynamicLibrary.open(<span class="hljs-string">&#x27;libnative_add.so&#x27;</span>)<br>    : DynamicLibrary.process();<br></code></pre></td></tr></table></figure>

<p>由此可见，调用方法主要是先加载整个动态链接库，再进一步调用库中对应的方法。</p>
<p>好在Android studio有提供专门的ffi插件模板，可以自动创建ffi插件，统一对动态链接库进行包装，提供对flutter可以调用的方法。</p>
<br/>

<h2 id="ffi插件使用"><a href="#ffi插件使用" class="headerlink" title="ffi插件使用"></a>ffi插件使用</h2><h3 id="普通方法调用"><a href="#普通方法调用" class="headerlink" title="普通方法调用"></a>普通方法调用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sumPtr =<br>    _lookup&lt;ffi.NativeFunction&lt;ffi.IntPtr <span class="hljs-built_in">Function</span>(ffi.IntPtr, ffi.IntPtr)&gt;&gt;(<br>        <span class="hljs-string">&#x27;sum&#x27;</span>);<br><span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sum = _sumPtr.asFunction&lt;<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="异步方法调用"><a href="#异步方法调用" class="headerlink" title="异步方法调用"></a>异步方法调用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">int</span>&gt; sumAsync(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> SendPort helperIsolateSendPort = <span class="hljs-keyword">await</span> _helperIsolateSendPort;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> requestId = _nextSumRequestId++;<br>  <span class="hljs-keyword">final</span> _SumRequest request = _SumRequest(requestId, a, b);<br>  <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">int</span>&gt; completer = Completer&lt;<span class="hljs-built_in">int</span>&gt;();<br>  _sumRequests[requestId] = completer;<br>  helperIsolateSendPort.send(request);<br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>开启一个helperIsolate，拿到helperIsolateSendPort，之后可以复用该SendPort。</p>
<p>_helperIsolateSendPort 是一个在定义时立即执行的异步函数表达式（immediately invoked asynchronous function expression，IIFE），它会在定义时执行一次，然后将结果赋给 _helperIsolateSendPort 变量。代码中巧妙使用了completer，结合final Map&lt;int, Completerint&gt;&gt; _sumRequests &#x3D; &lt;int,Completer<int>&gt;{};实现了请求数据和completer的一一对应。</p>
<p>源码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">The SendPort belonging to the helper isolate.</span></span><br>Future&lt;SendPort&gt; _helperIsolateSendPort = () <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">// The helper isolate is going to send us back a SendPort, which we want to</span><br>  <span class="hljs-comment">// wait for.</span><br>  <span class="hljs-keyword">final</span> Completer&lt;SendPort&gt; completer = Completer&lt;SendPort&gt;();<br><br>  <span class="hljs-comment">// Receive port on the main isolate to receive messages from the helper.</span><br>  <span class="hljs-comment">// We receive two types of messages:</span><br>  <span class="hljs-comment">// 1. A port to send messages on.</span><br>  <span class="hljs-comment">// 2. Responses to requests we sent.</span><br>  <span class="hljs-keyword">final</span> ReceivePort receivePort = ReceivePort()<br>    ..listen((<span class="hljs-built_in">dynamic</span> data) &#123;<br>      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> SendPort) &#123;<br>        <span class="hljs-comment">// The helper isolate sent us the port on which we can sent it requests.</span><br>        completer.complete(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> _SumResponse) &#123;<br>        <span class="hljs-comment">// The helper isolate sent us a response to a request we sent.</span><br>        <span class="hljs-keyword">final</span> Completer&lt;<span class="hljs-built_in">int</span>&gt; completer = _sumRequests[data.id]!;<br>        _sumRequests.remove(data.id);<br>        completer.complete(data.result);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">&#x27;Unsupported message type: <span class="hljs-subst">$&#123;data.runtimeType&#125;</span>&#x27;</span>);<br>    &#125;);<br><br>  <span class="hljs-comment">// Start the helper isolate.</span><br>  <span class="hljs-keyword">await</span> Isolate.spawn((SendPort sendPort) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> ReceivePort helperReceivePort = ReceivePort()<br>      ..listen((<span class="hljs-built_in">dynamic</span> data) &#123;<br>        <span class="hljs-comment">// On the helper isolate listen to requests and respond to them.</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> _SumRequest) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> result = _bindings.sum_long_running(data.a, data.b);<br>          <span class="hljs-keyword">final</span> _SumResponse response = _SumResponse(data.id, result);<br>          sendPort.send(response);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">&#x27;Unsupported message type: <span class="hljs-subst">$&#123;data.runtimeType&#125;</span>&#x27;</span>);<br>      &#125;);<br><br>    <span class="hljs-comment">// Send the port to the main isolate on which we can receive requests.</span><br>    sendPort.send(helperReceivePort.sendPort);<br>  &#125;, receivePort.sendPort);<br><br>  <span class="hljs-comment">// Wait until the helper isolate has sent us back the SendPort on which we</span><br>  <span class="hljs-comment">// can start sending requests.</span><br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;();<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="ffigen插件"><a href="#ffigen插件" class="headerlink" title="ffigen插件"></a>ffigen插件</h3><p>dart在调用c方法时，是不可以直接通过方法名调用的，需要像jni那样包装下。而ffigen插件主要的功能就是提供自动包装转化功能。</p>
<p>如下所示，将c的_sum方法转为dart的_sum方法，之后便可以直接调用了。</p>
<p>插件官网： https://pub.dev/packages/ffigen</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ffi&#x27;</span> <span class="hljs-keyword">as</span> ffi;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeLibrary</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> ffi.Pointer&lt;T&gt; <span class="hljs-built_in">Function</span>&lt;T <span class="hljs-keyword">extends</span> ffi.NativeType&gt;(<span class="hljs-built_in">String</span> symbolName)<br>      _lookup;<br>  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)<br>      : _lookup = dynamicLibrary.lookup;<br>  NativeLibrary.fromLookup(<br>      ffi.Pointer&lt;T&gt; <span class="hljs-built_in">Function</span>&lt;T <span class="hljs-keyword">extends</span> ffi.NativeType&gt;(<span class="hljs-built_in">String</span> symbolName)<br>          lookup)<br>      : _lookup = lookup;<br><br>  <span class="hljs-built_in">int</span> sum(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> _sum(a, b);<br>  &#125;<br><br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sumPtr = _lookup&lt;ffi.NativeFunction&lt;ffi.Int <span class="hljs-built_in">Function</span>(ffi.Int, ffi.Int)&gt;&gt;(<span class="hljs-string">&#x27;sum&#x27;</span>);<br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _sum = _sumPtr.asFunction&lt;<span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="是否可以调用c-方法呢？"><a href="#是否可以调用c-方法呢？" class="headerlink" title="是否可以调用c++方法呢？"></a>是否可以调用c++方法呢？</h3><p>直接调用是不支持的，不过可以通过c间接调用。方式和JNI类似，需要使用extern “C”包裹C++方法的实现，然后打包成动态链接库，通过DynamicLibrary.open进行加载。</p>
<p>官方文档：https://flutter.cn/docs/development/platform-integration/android/c-interop</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器--倒计时插件</title>
    <url>/article/eceecfb7/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<p>平时写代码可能会忘记时间，于是乎就想着准备开发一个编辑器的倒计时插件，方便提醒自己。</p>
<br/>

<h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id(<span class="hljs-string">&quot;java&quot;</span>)<br>    id(<span class="hljs-string">&quot;idea&quot;</span>)<br>    id(<span class="hljs-string">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version <span class="hljs-string">&quot;1.7.10&quot;</span><br>    id(<span class="hljs-string">&quot;org.jetbrains.intellij&quot;</span>) version <span class="hljs-string">&quot;1.8.0&quot;</span><br>&#125;<br><br>group = <span class="hljs-string">&quot;com.xxsu&quot;</span><br>version = <span class="hljs-string">&quot;1.0&quot;</span><br><br>repositories &#123;<br>    google()<br>    mavenCentral()<br>    jcenter()<br>&#125;<br><br>dependencies &#123;<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;</span>)<br><span class="hljs-comment">//    implementation(&quot;com.github.adedayo.intellij.sdk:forms_rt:142.1&quot;)</span><br>    implementation(<span class="hljs-string">&quot;com.intellij:forms_rt:7.0.3&quot;</span>)<br>    implementation(<span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Configure Gradle IntelliJ Plugin</span><br><span class="hljs-comment">// Read more: https://plugins.jetbrains.com/docs/intellij/tools-gradle-intellij-plugin.html</span><br>intellij &#123;<br>    version.set(<span class="hljs-string">&quot;2021.3.3&quot;</span>)<br>    type.set(<span class="hljs-string">&quot;IC&quot;</span>) <span class="hljs-comment">// Target IDE Platform  //IC指IDEA社区版(免费版本)，IU指旗舰版(收费版本)</span><br><br>    plugins.set(listOf(<span class="hljs-string">&quot;com.intellij.java&quot;</span>,<span class="hljs-string">&quot;android&quot;</span>))<br>&#125;<br><br>tasks &#123;<br>    <span class="hljs-comment">// Set the JVM compatibility versions</span><br>    withType&lt;JavaCompile&gt; &#123;<br>        sourceCompatibility = <span class="hljs-string">&quot;11&quot;</span><br>        targetCompatibility = <span class="hljs-string">&quot;11&quot;</span><br>    &#125;<br>    withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt; &#123;<br>        kotlinOptions.jvmTarget = <span class="hljs-string">&quot;11&quot;</span><br>    &#125;<br><br>    patchPluginXml &#123;<br><span class="hljs-comment">// 这里配置sinceBuild=213，表示插件只能被版本号大于等于2021.3版本的IDEA安装，低于这个版本的将抛无法兼容的错误</span><br>        sinceBuild.set(<span class="hljs-string">&quot;213&quot;</span>)<br>        untilBuild.set(<span class="hljs-string">&quot;223.*&quot;</span>)<br>    &#125;<br><br>    signPlugin &#123;<br>        certificateChain.set(System.getenv(<span class="hljs-string">&quot;CERTIFICATE_CHAIN&quot;</span>))<br>        privateKey.set(System.getenv(<span class="hljs-string">&quot;PRIVATE_KEY&quot;</span>))<br>        password.set(System.getenv(<span class="hljs-string">&quot;PRIVATE_KEY_PASSWORD&quot;</span>))<br>    &#125;<br><br>    publishPlugin &#123;<br>        token.set(System.getenv(<span class="hljs-string">&quot;PUBLISH_TOKEN&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h2><p>这里主要是插件的一些配置信息，也包括一些类的注册。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">applicationListeners</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        项目打开关闭监听--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;project_module.ProjectOpenCloseListener&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">topic</span>=<span class="hljs-string">&quot;com.intellij.openapi.project.ProjectManagerListener&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">applicationListeners</span>&gt;</span><br></code></pre></td></tr></table></figure>

<br/>

<h2 id="封装一个工具类来创建倒计时UI"><a href="#封装一个工具类来创建倒计时UI" class="headerlink" title="封装一个工具类来创建倒计时UI"></a>封装一个工具类来创建倒计时UI</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> time_module<br><br><span class="hljs-keyword">import</span> com.intellij.openapi.Disposable<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionGroup<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.actionSystem.ActionPlaces<br><span class="hljs-keyword">import</span> com.intellij.openapi.application.ApplicationManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.project.Project<br><span class="hljs-keyword">import</span> com.intellij.openapi.util.Disposer<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.StatusBar<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.WindowManager<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.impl.status.widget.StatusBarWidgetsActionGroup<br><span class="hljs-keyword">import</span> com.intellij.openapi.wm.impl.status.widget.StatusBarWidgetsManager<br><span class="hljs-keyword">import</span> com.intellij.ui.awt.RelativePoint<br><span class="hljs-keyword">import</span> utils.MyPopupHandler<br><span class="hljs-keyword">import</span> utils.ToastUtils<br><span class="hljs-keyword">import</span> java.util.function.Function<br><span class="hljs-keyword">import</span> javax.swing.JComponent<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeHelper</span> : <span class="hljs-type">Disposable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> statusBar: StatusBar<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTimeStatusWidget</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>?)</span></span> &#123;<br>        project ?: <span class="hljs-keyword">return</span><br>        statusBar = WindowManager.getInstance().getStatusBar(project) ?: <span class="hljs-keyword">return</span><br>        statusBar.addWidget(TimeWidget(project), <span class="hljs-keyword">this</span>)<br><br>        <span class="hljs-keyword">val</span> group = Function &#123; am: ActionManager -&gt;<br>            <span class="hljs-keyword">val</span> action = am.getAction(StatusBarWidgetsActionGroup.GROUP_ID)<br>            <span class="hljs-keyword">if</span> (action <span class="hljs-keyword">is</span> ActionGroup) &#123;<br>                <span class="hljs-keyword">return</span><span class="hljs-symbol">@Function</span> action<br>            &#125;<br>            <span class="hljs-literal">null</span><br>        &#125;<br>        MyPopupHandler.installPopupMenu(statusBar <span class="hljs-keyword">as</span> JComponent, group, ActionPlaces.STATUS_BAR_PLACE, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br><br>        <span class="hljs-keyword">val</span> statusBarWidgetsManager: StatusBarWidgetsManager =<br>            project.getService(StatusBarWidgetsManager::<span class="hljs-keyword">class</span>.java) ?: <span class="hljs-keyword">return</span><br>        ApplicationManager.getApplication().invokeLater &#123; statusBarWidgetsManager.installPendingWidgets() &#125;<br>        Disposer.register(statusBar) &#123; statusBarWidgetsManager.disableAllWidgets() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRelativePoint</span><span class="hljs-params">()</span></span>:RelativePoint&#123;<br>        <span class="hljs-keyword">return</span> RelativePoint.getCenterOf(statusBar.component)<br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        Disposer.dispose(statusBar)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="弹框工具类"><a href="#弹框工具类" class="headerlink" title="弹框工具类"></a>弹框工具类</h2><p>用于消息提示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyPopupHandler &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installPopupMenu</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        component: <span class="hljs-type">JComponent</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        group: <span class="hljs-type">Function</span>&lt;<span class="hljs-type">ActionManager</span>, ActionGroup?&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        place: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        actionManager: <span class="hljs-type">ActionManager</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        menuListener: <span class="hljs-type">PopupMenuListener</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: PopupHandler &#123;<br>        <span class="hljs-keyword">if</span> (ApplicationManager.getApplication() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : PopupHandler() &#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokePopup</span><span class="hljs-params">(comp: <span class="hljs-type">Component</span>?, x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> &#123;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">val</span> popupHandler: PopupHandler = <span class="hljs-keyword">object</span> : PopupHandler() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokePopup</span><span class="hljs-params">(comp: <span class="hljs-type">Component</span>?, x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">val</span> manager = actionManager ?: ActionManager.getInstance()<br>                <span class="hljs-keyword">val</span> actionGroup: ActionGroup = manager?.let &#123; group.apply(it) &#125; ?: <span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">val</span> popupMenu = manager.createActionPopupMenu(place, actionGroup)<br>                popupMenu.setTargetComponent(component)<br>                <span class="hljs-keyword">val</span> menu = popupMenu.component<br>                <span class="hljs-keyword">if</span> (menuListener != <span class="hljs-literal">null</span>) &#123;<br>                    menu.addPopupMenuListener(menuListener)<br>                &#125;<br>                menu.show(comp, x, y)<br>            &#125;<br>        &#125;<br>        component.addMouseListener(popupHandler)<br>        <span class="hljs-keyword">return</span> popupHandler<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="自定义UI组件"><a href="#自定义UI组件" class="headerlink" title="自定义UI组件"></a>自定义UI组件</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeWidget</span>(<span class="hljs-keyword">val</span> project: Project) : CustomStatusBarWidget, TextPresentation &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myLabel = JLabel(<span class="hljs-string">&quot;「00:00」&quot;</span>)<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">object</span> : ClickListener() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(e: <span class="hljs-type">MouseEvent</span>, clickCount: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>                <span class="hljs-keyword">val</span> myPopupMenu = JPopupMenu()<br>                myPopupMenu.add(<span class="hljs-keyword">object</span> : AbstractAction(<span class="hljs-string">&quot;设置倒计时&quot;</span>, IconsUtils.settingIcon) &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> &#123;<br>                        AppObserver.getInstance(project).openSettingDialog.increment()<br>                    &#125;<br>                &#125;)<br>                myPopupMenu.addSeparator()<br>                myPopupMenu.add(<span class="hljs-keyword">object</span> : AbstractAction(<span class="hljs-string">&quot;暂停/恢复&quot;</span>, getIconByStatus()) &#123;<br>                    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> &#123;<br>                        <span class="hljs-keyword">if</span> (CountDownHelper.getInstance(project).isPauseStatus()) &#123;<br>                            <span class="hljs-keyword">if</span> (!CountDownHelper.getInstance(project).resumeCountDown()) &#123;<br>                                ToastUtils.show(project, <span class="hljs-string">&quot;恢复失败,请重启开启~&quot;</span>)<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            CountDownHelper.getInstance(project).pauseCountDown()<br>                        &#125;<br>                        <span class="hljs-keyword">this</span>.putValue(SMALL_ICON, getIconByStatus())<br>                    &#125;<br>                &#125;)<br><br>                <span class="hljs-keyword">val</span> dimension: Dimension = myLabel.preferredSize<br>                <span class="hljs-keyword">val</span> at = Point(<span class="hljs-number">0</span>, -dimension.height)<br>                myPopupMenu.show(e.component, at.x - <span class="hljs-number">20</span>, at.y - <span class="hljs-number">20</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;.installOn(myLabel, <span class="hljs-literal">true</span>)<br><br>        AppObserver.getInstance(project).startCountDown.addObserver &#123;<br>            startCountDown()<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getIconByStatus</span><span class="hljs-params">()</span></span>: Icon &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (CountDownHelper.getInstance(project).isPauseStatus()) &#123;<br>            IconsUtils.stopIcon<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            IconsUtils.runningIcon<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startCountDown</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> totalMinutes = SpUtils.getIntValue(TimeConstants.SpKey.key_minutes) ?: <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (totalMinutes == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        CountDownHelper.getInstance(project).startCountDown(totalMinutes * <span class="hljs-number">60</span>, &#123;<br>            <span class="hljs-keyword">val</span> minutes = it / <span class="hljs-number">60</span><br>            <span class="hljs-keyword">val</span> seconds = it % <span class="hljs-number">60</span><br>            <span class="hljs-keyword">val</span> minutesStr = <span class="hljs-keyword">if</span> (minutes &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-string">&quot;0<span class="hljs-variable">$minutes</span>&quot;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minutes<br>            &#125;<br>            <span class="hljs-keyword">val</span> secondsStr = <span class="hljs-keyword">if</span> (seconds &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-string">&quot;0<span class="hljs-variable">$seconds</span>&quot;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                seconds<br>            &#125;<br>            myLabel.text = <span class="hljs-string">&quot;「<span class="hljs-variable">$minutesStr</span>:<span class="hljs-variable">$secondsStr</span>」&quot;</span><br>        &#125;, &#123;<br>            myLabel.text = <span class="hljs-string">&quot;「00:00」&quot;</span><br>            ToastUtils.show(<br>                project,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;SpUtils.getValue(TimeConstants.SpKey.key_minutes)&#125;</span>分钟的任务已结束，请check:\n &quot;</span><br>                        + SpUtils.getValue(TimeConstants.SpKey.key_task)<br>            )<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ID</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(statusBar: <span class="hljs-type">StatusBar</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getComponent</span><span class="hljs-params">()</span></span>: JComponent &#123;<br>        <span class="hljs-keyword">return</span> myLabel<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPresentation</span><span class="hljs-params">()</span></span>: WidgetPresentation &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTooltipText</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;点击进行更多设置&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getClickConsumer</span><span class="hljs-params">()</span></span>: Consumer&lt;MouseEvent&gt; &#123;<br>        <span class="hljs-keyword">return</span> Consumer &#123; _: MouseEvent? -&gt;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getText</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TimeWidget&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAlignment</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>        <span class="hljs-keyword">return</span> Component.CENTER_ALIGNMENT<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        CountDownHelper.getInstance(project).cancelCountDownTimer()<br>        AppObserver.getInstance(project).startCountDown.removeAllObservers()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是倒计时插件的主要代码，此外还有些小的工具类就不一一粘贴了。下面看下效果吧:)</p>
<br/>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/./../../images/skill-countdown/countdown.gif" alt="倒计时"></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>效率工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用总结</title>
    <url>/article/65761caa/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<blockquote>
<p>Docker 是一个开源的容器化平台，主要用于打包、发布和运行应用程序。它的作用在于提供了一种轻量级、可移植、自包含的环境，使应用程序能够在不同的环境中快速部署和运行。</p>
</blockquote>
<br/>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>以下是一些常用的 Docker 命令：</p>
<ol>
<li>镜像相关命令：<ul>
<li>docker images：列出本地所有镜像。</li>
<li>docker pull &lt;镜像名&gt;：拉取镜像。</li>
<li>docker rmi &lt;镜像ID&gt;：删除指定镜像。</li>
</ul>
</li>
<li>容器相关命令：<ul>
<li>docker ps：列出正在运行的容器。</li>
<li>docker ps -a：列出所有容器，包括已停止的。</li>
<li>docker inspect <container_name_or_id> 查看容器的详细信息。</li>
<li>docker run &lt;镜像名&gt;：运行一个容器。</li>
<li>docker start &lt;容器ID或名称&gt;：启动一个停止的容器。</li>
<li>docker stop &lt;容器ID或名称&gt;：停止一个运行中的容器。</li>
<li>docker rm &lt;容器ID或名称&gt;：删除一个容器。</li>
</ul>
</li>
<li>容器日志：<ul>
<li>docker logs &lt;容器ID或名称&gt;：查看容器日志。</li>
<li>docker logs -f &lt;容器ID或名称&gt;：实时查看容器日志。</li>
</ul>
</li>
<li>容器操作：<ul>
<li>docker exec -it &lt;容器ID或名称&gt; &lt;命令&gt;：在运行中的容器中执行命令。</li>
<li>docker cp &lt;本地路径&gt; &lt;容器ID或名称&gt;:&lt;容器内路径&gt;：将本地文件复制到容器中。</li>
</ul>
</li>
<li>网络相关命令：<ul>
<li>docker network ls：列出 Docker 网络。</li>
<li>docker network inspect &lt;网络名称&gt;：查看网络详细信息。</li>
</ul>
</li>
<li>其他命令：<ul>
<li>docker-compose up&#x2F;down：通过 Docker Compose 启动&#x2F;停止服务。</li>
<li>docker version：查看 Docker 版本信息。</li>
<li>docker info：查看 Docker 系统信息。</li>
</ul>
</li>
</ol>
<br/>

<h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><p>在docker inspect输出结果中，查找 “IPAddress” 和 “HostPort” 字段，分别对应容器的 IP 地址和端口号。</p>
<p><strong>查看挂载的源文件</strong>： docker inspect my-container | grep Source</p>
<p><strong>修改容器的名称</strong>： docker rename &lt;容器ID或容器名&gt; &lt;新容器名&gt;   。需要注意的是，容器名不能包含特殊字符（如 &#x2F;、: 等）以及空格。</p>
<p>为正在运行的容器进行文件挂载：docker exec -it -v &#x2F;path&#x2F;to&#x2F;local&#x2F;file:&#x2F;path&#x2F;to&#x2F;container&#x2F;file CONTAINER COMMAND</p>
<p><strong>如何保证容器停止后重启内容数据保留？</strong></p>
<p>使用volume来创建Docker 卷，例如 docker volume create xx-data，并在启动时使用-v 将docker卷关联到本地。</p>
<br/>

<h2 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker Compose简介"></a>Docker Compose简介</h2><blockquote>
<p>Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。它允许您通过一个单独的配置文件来定义和管理多个容器，这些容器可以相互协作组成一个完整的应用程序。</p>
</blockquote>
<br/>

<h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><ol>
<li>创建一个 docker-compose.yml 文件：在项目目录中创建一个名为 docker-compose.yml 的配置文件。</li>
<li>定义服务：在 docker-compose.yml 文件中，可以定义每个服务的配置。每个服务通常对应一个容器，可以指定容器的镜像、端口映射、环境变量、数据卷等。</li>
<li>定义服务间的关系：如果应用程序由多个服务组成，可以在 docker-compose.yml 文件中定义它们之间的依赖关系和通信方式。这样 Docker Compose 就知道如何启动和连接这些服务。</li>
<li>启动应用程序：使用 docker-compose up 命令，Docker Compose 将根据配置文件创建和启动所有的服务。</li>
<li>停止应用程序：使用 docker-compose down 命令，Docker Compose 将停止并删除应用程序中的所有服务和相关容器。</li>
</ol>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mockserver部署总结</title>
    <url>/article/20276bc2/</url>
    <content><![CDATA[<p>[TOC]</p>
<br/>

<p>官方网址：https://www.mock-server.com/</p>
<p>容器部署：https://www.mock-server.com/mock_server&#x2F;running_mock_server.html#docker_container</p>
<br/>

<h2 id="命令行添加期望"><a href="#命令行添加期望" class="headerlink" title="命令行添加期望"></a>命令行添加期望</h2><p>官方例子： https://github.com/mock-server/mockserver/blob/master/mockserver-examples/curl_examples.md</p>
<p>期望添加失败，可能是端口不正确导致；可以用docker ps查看端口；如下图所示，本地访问应该使用32768这个端口；</p>
<p><img src="/./skill-mockserver/image-20231222133537654.png" alt="image-20231222133537654"></p>
<p>例子：</p>
<p>1、实现简单的接口mock：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">curl -X PUT <span class="hljs-string">&#x27;localhost:1090/mockserver/expectation&#x27;</span> \<br>-d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;httpRequest&quot;: &#123;</span><br><span class="hljs-string">    &quot;method&quot;: &quot;GET&quot;,</span><br><span class="hljs-string">    &quot;path&quot;: &quot;/test&quot;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;httpResponse&quot;: &#123;</span><br><span class="hljs-string">    &quot;body&quot;: &quot;OK&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>2、使用自定义的类回调</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">curl -v -X PUT <span class="hljs-string">&quot;http://localhost:1080/mockserver/expectation&quot;</span> -d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    &quot;httpRequest&quot; : &#123;</span><br><span class="hljs-string">        &quot;path&quot; : &quot;/some.*&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;httpResponseClassCallback&quot; : &#123;</span><br><span class="hljs-string">        &quot;callbackClass&quot; : &quot;org.mockserver.examples.mockserver.CallbackActionExamples$TestExpectationResponseCallback&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&#x27;</span> <br></code></pre></td></tr></table></figure>

<br/>

<h2 id="代码实现动态返回"><a href="#代码实现动态返回" class="headerlink" title="代码实现动态返回"></a>代码实现动态返回</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">cd mockserver-examples<br>mvn clean <span class="hljs-keyword">package</span>    #打包成mockserver-examples-<span class="hljs-number">5.15</span><span class="hljs-number">.0</span>.jar<br>拷贝 mockserver-examples-<span class="hljs-number">5.15</span><span class="hljs-number">.0</span>.jar 到libs目录下<br><br>docker run --rm -d -p <span class="hljs-number">1080</span>:<span class="hljs-number">1080</span> -v $(pwd)/expectation.json:/tmp/mockserver/expectation.json -v $(pwd)/config:/config -v $(pwd)/libs:/libs -w /tmp/mockserver --name my-mock-server mockserver/mockserver -logLevel INFO -serverPort <span class="hljs-number">1080</span><br><br>请求 http:<span class="hljs-comment">//localhost:1080/mockserver/dashboard</span><br></code></pre></td></tr></table></figure>

<br/>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>docker run在run后面添加–rm 只要关闭就自动删除。</p>
<p>查看所有的期望的id：<br> ​curl -X GET http://localhost:1080/mockserver/expectations​​</p>
<p>删除对应期望id的配置，其他保留：<br> ​curl -X PUT “http://localhost:1080/mockserver/clear" -d '{    "id": "676a5f8a-8b9b-4b79-9a49-b535f54f9e20" }'​​</p>
<p>列出当前MockServer中的所有请求和期望：result.json  是当前命令的路径：<br> ​curl -X PUT http://localhost:1090/mockserver/retrieve > result.json​​</p>
<p>put操作失败可能是端口不正确。</p>
<br/>

<h2 id="踩坑："><a href="#踩坑：" class="headerlink" title="踩坑："></a>踩坑：</h2><p>config中的mockserver.properties的功能没有仔细参考官网给的例子（https://raw.githubusercontent.com/mock-server/mockserver/master/mockserver.example.properties），参数配置不齐全；重要是这几个参数，导致配置文件一直没有生效；</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">mockserver.persistExpectations=<span class="hljs-literal">true</span><br>mockserver.persistedExpectationsPath=/tmp/mockserver/expectation.json<br>mockserver.initializationJsonPath=/tmp/mockserver/expectation.json<br>mockserver.watchInitializationJson=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<br/>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MockServer 和 EasyMock 都是用于进行测试和模拟的工具，但它们在实现和使用方式上有一些区别。MockServer相对重量级，学习成本较高，如果只是简单的接口测试，那还是使用EasyMock方便些。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>mockserver</tag>
      </tags>
  </entry>
  <entry>
    <title>FlutterRedux源码剖析</title>
    <url>/article/fa044df7/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>当前最新版：flutter_redux: ^0.10.0</p>
<p>源码：https://github.com/brianegan/flutter_redux&#x2F;blob&#x2F;master&#x2F;lib&#x2F;flutter_redux.dart</p>
<h2 id="flutter-redux原理"><a href="#flutter-redux原理" class="headerlink" title="flutter_redux原理"></a>flutter_redux原理</h2><p>flutter_redux 是一个 Flutter 库，它提供了将 Redux 状态管理模式与 Flutter 框架无缝集成的能力。它的原理主要基于以下几个要素：</p>
<ol>
<li>Redux 架构: Redux 是一种用于管理应用状态的设计模式，它将应用的状态存储在单一的不可变对象中，通过使用纯函数来修改状态。核心概念包括 Store（存储应用状态的容器）、Action（描述状态变化的动作）、Reducer（处理状态变化的纯函数）和 Middleware（处理额外操作的扩展）。</li>
<li>Store 的集成: flutter_redux 将 Redux 中的 Store 与 Flutter 的 InheritedWidget 有机地结合在一起。它通过 StoreProvider 将 Redux 的 Store 提供给整个 Flutter Widget 树。</li>
<li>数据流管理: 当应用状态发生变化时，Redux 的 Store 会调用注册的 Reducer 函数，生成新的状态。flutter_redux 利用 StoreConnector 将特定部件与 Store 关联起来，以便在状态变化时更新相关部件。</li>
<li>StoreConnector: 这个 Widget 允许 Flutter 组件订阅 Store 中的特定状态，并在状态发生变化时重新构建自身。通过传递 converter 函数，StoreConnector 可以将全局状态中的一部分映射到当前部件所需的局部状态。</li>
<li>Dispatch 动作: 通过 Store 的 dispatch 方法，可以派发 Action 到 Reducer，从而触发状态的变化。StoreConnector 可以使用 Store 的 dispatch 方法来发送 Action。</li>
</ol>
<br/>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="StoreProvider类"><a href="#StoreProvider类" class="headerlink" title="StoreProvider类"></a>StoreProvider类</h3><p>继承于InheritedWidget，StoreProvider 在 Flutter Redux 中扮演着将 Redux store 与 Flutter Widget 树连接起来的重要角色，使得状态管理变得更加简洁高效。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;<span class="hljs-built_in">bool</span> listen = <span class="hljs-keyword">true</span>&#125;) &#123;<br>  <span class="hljs-keyword">final</span> provider = (listen<br>      ? context.dependOnInheritedWidgetOfExactType&lt;StoreProvider&lt;S&gt;&gt;()<br>      : context<br>          .getElementForInheritedWidgetOfExactType&lt;StoreProvider&lt;S&gt;&gt;()<br>          ?.widget) <span class="hljs-keyword">as</span> StoreProvider&lt;S&gt;?;<br><br>  <span class="hljs-keyword">if</span> (provider == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> StoreProviderError&lt;StoreProvider&lt;S&gt;&gt;();<br><br>  <span class="hljs-keyword">return</span> provider._store;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="dependOnInheritedWidgetOfExactType"><a href="#dependOnInheritedWidgetOfExactType" class="headerlink" title="dependOnInheritedWidgetOfExactType"></a>dependOnInheritedWidgetOfExactType</h3><p>该方法用于在Widget树上获取离当前widget最近的一个父级InheritFromWidget，原因是在初始化完成后，Widget树中的InheritFromWidget也可能会发生变化，所以正确的做法应该在build（）方法或didChangeDependencies()中调用它。</p>
<br/>

<h3 id="getElementForInheritedWidgetOfExactType"><a href="#getElementForInheritedWidgetOfExactType" class="headerlink" title="getElementForInheritedWidgetOfExactType"></a>getElementForInheritedWidgetOfExactType</h3><p>返回最近的 Widget 元素：根据传入的泛型类型 T，寻找在当前 Widget 树中最近的对应 InheritedWidget 子类的元素，如果找不到，则返回 null。</p>
<p>不建立依赖关系：与 dependOnInheritedWidgetOfExactType 不同，该方法获取元素但不建立依赖关系。</p>
<p>不应在 State.dispose 中调用：因为在 dispose 阶段，元素树已经不稳定。如果需要在 dispose 阶段引用祖先元素，应该在 State.didChangeDependencies 中调用 dependOnInheritedWidgetOfExactType 来保存对祖先的引用。但在 State.deactivate 中调用是安全的，因为这个方法在部件从树中移除时被调用。</p>
<br/>

<h3 id="StoreConnector类"><a href="#StoreConnector类" class="headerlink" title="StoreConnector类"></a>StoreConnector类</h3><p>StoreConnector 是 flutter_redux 库中的一个关键部件，用于根据 Redux 的 Store 状态构建部件，继承于StatelessWidget。其主要功能和作用如下：</p>
<ul>
<li>根据 Store 状态构建部件: StoreConnector 根据 Redux 中的 Store 状态来构建 Flutter 组件，这允许你根据应用状态动态地构建 UI。</li>
<li>使用 converter 函数转换状态: 在执行 builder 之前，converter 函数会将 Store 转换成更特定的 ViewModel。这有助于将全局状态映射为当前部件所需的局部状态。</li>
<li>依赖 ViewModel 更新重建部件: 每当 Store 发生变化时，StoreConnector 会根据 ViewModel 的变化重新构建部件。为了正确执行此功能，你需要为 ViewModel 实现 &#x3D;&#x3D; 和 hashCode 方法，并在创建 StoreConnector 时设置 distinct 选项为 true。这样可以确保只有当 ViewModel 发生实际变化时，部件才会被重建，提高性能并避免不必要的重建。</li>
</ul>
<p>总之，StoreConnector 充当了连接 Redux 的 Store 和 Flutter 部件的桥梁，通过 converter 将全局状态转换为局部状态，并利用 ViewModel 变化来优化部件的重建。这样可以实现有效的状态管理和动态 UI 构建。</p>
<br/>

<h3 id="Store类"><a href="#Store类" class="headerlink" title="Store类"></a>Store<state>类</h3><p>它在 flutter_redux 库中扮演着存储和管理应用状态的角色。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>&lt;<span class="hljs-title">State</span>&gt; </span>&#123;<br>  Reducer&lt;State&gt; reducer;<br>  <span class="hljs-keyword">final</span> StreamController&lt;State&gt; _changeController;<br>  <span class="hljs-keyword">late</span> State _state;<br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;NextDispatcher&gt; _dispatchers;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Store(<br>  <span class="hljs-keyword">this</span>.reducer, &#123;<br>  <span class="hljs-keyword">required</span> State initialState,<br>  <span class="hljs-built_in">List</span>&lt;Middleware&lt;State&gt;&gt; middleware = <span class="hljs-keyword">const</span> [],<br>  <span class="hljs-built_in">bool</span> syncStream = <span class="hljs-keyword">false</span>,<br>  <span class="hljs-built_in">bool</span> distinct = <span class="hljs-keyword">false</span>,<br>&#125;) : _changeController = StreamController.broadcast(<span class="hljs-keyword">sync</span>: syncStream) &#123;<br>  _state = initialState;<br>  _dispatchers = _createDispatchers(<br>    middleware,<br>    _createReduceAndNotify(distinct),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中的distinct如果设置为 true，如果从 [reducer] 返回的新状态 响应操作等于之前的状态，则 Store 将不会发出 onChange 事件。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">NextDispatcher _createReduceAndNotify(<span class="hljs-built_in">bool</span> distinct) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dynamic</span> action) &#123;<br>    <span class="hljs-keyword">final</span> state = reducer(_state, action);<br><br>    <span class="hljs-keyword">if</span> (distinct &amp;&amp; state == _state) <span class="hljs-keyword">return</span>;<br><br>    _state = state;<br>    _changeController.add(state);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h3 id="Dispatchers创建"><a href="#Dispatchers创建" class="headerlink" title="Dispatchers创建"></a>Dispatchers创建</h3><p>形成一个拦截链对action处理</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span>&lt;NextDispatcher&gt; _createDispatchers(<br>  <span class="hljs-built_in">List</span>&lt;Middleware&lt;State&gt;&gt; middleware,<br>  NextDispatcher reduceAndNotify,<br>) &#123;<br>  <span class="hljs-keyword">final</span> dispatchers = &lt;NextDispatcher&gt;[]..add(reduceAndNotify);<br><br>  <span class="hljs-comment">// Convert each [Middleware] into a [NextDispatcher]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> nextMiddleware <span class="hljs-keyword">in</span> middleware.reversed) &#123;<br>    <span class="hljs-keyword">final</span> next = dispatchers.last;<br><br>    dispatchers.add(<br>      (<span class="hljs-built_in">dynamic</span> action) =&gt; nextMiddleware(<span class="hljs-keyword">this</span>, action, next),<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dispatchers.reversed.toList();<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">dynamic</span> dispatch(<span class="hljs-built_in">dynamic</span> action) &#123;<br>  <span class="hljs-keyword">return</span> _dispatchers[<span class="hljs-number">0</span>](action);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用dispatch方法，_dispatchers中的头一个处理器进行处理，根据action得到新的state值，根据distinct判断是否去重，拿到新的state值后添加到_changeController中，_changeController.add(state);</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _createStream() &#123;<br>  _stream = widget.store.onChange<br>      .where(_ignoreChange)<br>      .map((_) =&gt; widget.converter(widget.store))<br>      .transform(StreamTransformer.fromHandlers(<br>        handleError: _handleConverterError,<br>      ))<br>      <span class="hljs-comment">// Don&#x27;t use `Stream.distinct` because it cannot capture the initial</span><br>      <span class="hljs-comment">// ViewModel produced by the `converter`.</span><br>      .where(_whereDistinct)<br>      <span class="hljs-comment">// After each ViewModel is emitted from the Stream, we update the</span><br>      <span class="hljs-comment">// latestValue. Important: This must be done after all other optional</span><br>      <span class="hljs-comment">// transformations, such as ignoreChange.</span><br>      .transform(StreamTransformer.fromHandlers(<br>        handleData: _handleChange,<br>      ))<br>      <span class="hljs-comment">// Handle any errors from converter/onWillChange/onDidChange</span><br>      .transform(StreamTransformer.fromHandlers(<br>        handleError: _handleError,<br>      ));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上源码所示，得到新的state后就会通知到onChange进行处理。这里有个_whereDistinct方法，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> _whereDistinct(ViewModel vm) &#123;<br>  <span class="hljs-keyword">if</span> (widget.distinct) &#123;<br>    <span class="hljs-keyword">return</span> vm != _latestValue;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里的distinct主要用来判断生成后的viewmodel的是否一致，区别于Stream.distinct。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp框架分析</title>
    <url>/article/cec99305/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>基于Socket， 和HttpUrlConnection同级但并不属于HttpUrlConnection（断点续传的关键）</p>
<p>目前相对主流的框架Retrofit，Glide中都是内置了OkHttp</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">()</span> &#123;<br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dispatcher</span>();<span class="hljs-comment">// 调度者</span><br>  protocols = DEFAULT_PROTOCOLS;<br>  connectionSpecs = DEFAULT_CONNECTION_SPECS;<span class="hljs-comment">// 传输层版本和连接协议</span><br>  eventListenerFactory = EventListener.factory(EventListener.NONE);<br>  proxySelector = ProxySelector.getDefault();<br>  <span class="hljs-keyword">if</span> (proxySelector == <span class="hljs-literal">null</span>) &#123;<br>    proxySelector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullProxySelector</span>();<br>  &#125;<br>  cookieJar = CookieJar.NO_COOKIES;<br>  socketFactory = SocketFactory.getDefault();<br>  hostnameVerifier = OkHostnameVerifier.INSTANCE;<span class="hljs-comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span><br>  certificatePinner = CertificatePinner.DEFAULT;<span class="hljs-comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span><br>  proxyAuthenticator = Authenticator.NONE;<span class="hljs-comment">// 代理身份验证</span><br>  authenticator = Authenticator.NONE;<span class="hljs-comment">// 身份验证</span><br>  connectionPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionPool</span>();<span class="hljs-comment">// 连接池，最大连接数量为5，空闲时间上限为5分钟；</span><br>  dns = Dns.SYSTEM;<br>  followSslRedirects = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 安全套接层重定向</span><br>  followRedirects = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 本地重定向</span><br>  retryOnConnectionFailure = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 重试连接失败</span><br>  callTimeout = <span class="hljs-number">0</span>;<br>  connectTimeout = <span class="hljs-number">10_000</span>;<br>  readTimeout = <span class="hljs-number">10_000</span>;<br>  writeTimeout = <span class="hljs-number">10_000</span>;<br>  pingInterval = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="获取拦截器链"><a href="#获取拦截器链" class="headerlink" title="获取拦截器链"></a>获取拦截器链</h2><p>添加各种拦截器，然后建立拦截器链，来处理对请求对象的拦截操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-comment">// Build a full stack of interceptors.</span><br>  List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  interceptors.addAll(client.interceptors());<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryAndFollowUpInterceptor</span>(client));<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BridgeInterceptor</span>(client.cookieJar()));<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>(client.internalCache()));<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectInterceptor</span>(client));<br>  <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>    interceptors.addAll(client.networkInterceptors());<br>  &#125;<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallServerInterceptor</span>(forWebSocket));<br><br>  Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>,<br>      originalRequest, <span class="hljs-built_in">this</span>, client.connectTimeoutMillis(),<br>      client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">calledNoMoreExchanges</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(originalRequest);<br>    <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>      closeQuietly(response);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    calledNoMoreExchanges = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>      transmitter.noMoreExchanges(<span class="hljs-literal">null</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>关键类为RealInterceptorChain。</p>
<p>一个具体的拦截器链，包含整个拦截器链：所有应用程序拦截器，OkHttp核心，所有网络拦截器，最后是网络调用者。如果该链用于应用程序拦截器，则connection必须为空。如果它是用于网络拦截器的，则connection必须为非空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Connection <span class="hljs-title function_">connection</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> exchange != <span class="hljs-literal">null</span> ? exchange.connection() : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>包括常见异常日志打印；拦截器的链式调用；责任链模式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request, Transmitter transmitter, <span class="hljs-meta">@Nullable</span> Exchange exchange)</span><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br><br>  calls++;<br><br>  <span class="hljs-comment">// If we already have a stream, confirm that the incoming request will use it.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.exchange != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.exchange.connection().supportsUrl(request.url())) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="hljs-number">1</span>)<br>        + <span class="hljs-string">&quot; must retain the same host and port&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.exchange != <span class="hljs-literal">null</span> &amp;&amp; calls &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="hljs-number">1</span>)<br>        + <span class="hljs-string">&quot; must call proceed() exactly once&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 调用链中的下一个拦截器。</span><br>  <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, exchange,<br>      index + <span class="hljs-number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);<br>  <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors.get(index);<br>  <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> interceptor.intercept(next);<br><br>  <span class="hljs-comment">// Confirm that the next interceptor made its required call to chain.proceed().</span><br>  <span class="hljs-keyword">if</span> (exchange != <span class="hljs-literal">null</span> &amp;&amp; index + <span class="hljs-number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;network interceptor &quot;</span> + interceptor<br>        + <span class="hljs-string">&quot; must call proceed() exactly once&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Confirm that the intercepted response isn&#x27;t null.</span><br>  <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;interceptor &quot;</span> + interceptor + <span class="hljs-string">&quot; returned null&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>        <span class="hljs-string">&quot;interceptor &quot;</span> + interceptor + <span class="hljs-string">&quot; returned a response with no body&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>    .url(url)<br>    .build();<br><br>client.newCall(request).enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;<br>      e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ...<br>    &#125;<br>)<br></code></pre></td></tr></table></figure>



<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(AsyncCall call)</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    readyAsyncCalls.add(call); <span class="hljs-comment">//准备好异步调用的运行顺序。</span><br><br><span class="hljs-comment">//对AsyncCall进行突变，以使其将现有正在运行的调用的AtomicInteger共享给同一主机。</span><br>    <span class="hljs-keyword">if</span> (!call.get().forWebSocket) &#123;<br>      <span class="hljs-type">AsyncCall</span> <span class="hljs-variable">existingCall</span> <span class="hljs-operator">=</span> findExistingCallWithHost(call.host());<br>      <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-literal">null</span>) call.reuseCallsPerHostFrom(existingCall);<br>    &#125;<br>  &#125;<br>  promoteAndExecute();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="相关异步回调"><a href="#相关异步回调" class="headerlink" title="相关异步回调"></a>相关异步回调</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//准备好异步调用的运行顺序。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br><span class="hljs-comment">//运行异步调用。包括尚未结束的已取消呼叫。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br><span class="hljs-comment">//运行同步呼叫。包括尚未结束的已取消呼叫。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>



<h3 id="promoteAndExecute"><a href="#promoteAndExecute" class="headerlink" title="promoteAndExecute"></a>promoteAndExecute</h3><p>将合格的回调从readyAsyncCalls更新到runningAsyncCalls，并在执行程序服务上运行它们。</p>
<p>不能以同步方式调用，因为执行调用可以调用用户代码。</p>
<p>@return如果调度程序当前正在运行回调，则为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">promoteAndExecute</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">assert</span> (!Thread.holdsLock(<span class="hljs-built_in">this</span>));<br><br>  List&lt;AsyncCall&gt; executableCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-type">boolean</span> isRunning;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;<br>      <span class="hljs-type">AsyncCall</span> <span class="hljs-variable">asyncCall</span> <span class="hljs-operator">=</span> i.next();<br><br>      <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Max capacity.</span><br>      <span class="hljs-keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Host max capacity.</span><br><br>      i.remove();<br>      asyncCall.callsPerHost().incrementAndGet();<br>      executableCalls.add(asyncCall);<br>      runningAsyncCalls.add(asyncCall);<br>    &#125;<br>    isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL干货总结</title>
    <url>/article/7de12c1b/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h2><p><img src="/article/7de12c1b/image-20231227165141908.png" alt="image-20231227165141908"></p>
<br/>

<h2 id="VAO、VBO、IBO-等区别作用"><a href="#VAO、VBO、IBO-等区别作用" class="headerlink" title="VAO、VBO、IBO 等区别作用"></a>VAO、VBO、IBO 等区别作用</h2><p>VAO：顶点数组对象，存储顶点属性指针的配置（如顶点坐标、颜色、纹理坐标等），使得在渲染时可以更有效地切换顶点属性的配置。</p>
<p>VBO：顶点缓冲对象，存储顶点数据，例如顶点坐标、法线、纹理坐标等。</p>
<p>EBO&#x2F;IBO：索引缓冲对象，存储图元的索引数据，例如三角形列表或三角形带的索引。</p>
<p>使用结构数组的方式效率最高。</p>
<br/>

<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 顶点数据</span><br><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><br><span class="hljs-comment">// 索引数据</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO, VAO, IBO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;IBO);<br><br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>    <span class="hljs-built_in">processInput</span>(window);<br><br>    <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>    <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br><br>    <span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>    <span class="hljs-built_in">glfwPollEvents</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>x和y轴坐标范围：0到1，超出则采取环绕方式。</p>
<table>
<thead>
<tr>
<th>环绕方式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GL_REPEAT</td>
<td>默认，重复纹理图像</td>
</tr>
<tr>
<td>GL_MIRRORED_REPEAT</td>
<td>重复，镜像放置</td>
</tr>
<tr>
<td>GL_CLAMP_TO_EDGE</td>
<td>重复边缘，边缘被拉伸的效果</td>
</tr>
<tr>
<td>GL_CLAMP_TO_BORDER</td>
<td>指定边缘颜色</td>
</tr>
</tbody></table>
<p>纹理过滤：邻近过滤和线性过滤</p>
<p>远距离物体可以采用多级渐远纹理；</p>
<p>设置方法：glTexParameteri</p>
<p>纹理加载方法：stb_image.h</p>
<p>绑定多个纹理：纹理单元。使用前需激活纹理单元，再将纹理绑定到对应的纹理单元。</p>
<br/>

<h2 id="向量、矩阵"><a href="#向量、矩阵" class="headerlink" title="向量、矩阵"></a>向量、矩阵</h2><p>点乘：求向量夹角，即cosθ；</p>
<p>叉乘：求法线；不满足乘法交换律；</p>
<p>向量的w分量：齐次坐标。增加的w分量主要方便通过矩阵实现向量的缩放、旋转、平移；</p>
<p>弧度转角度：角度 &#x3D; 弧度 * (180.0f &#x2F; PI)</p>
<p>角度转弧度：弧度 &#x3D; 角度 * (PI &#x2F; 180.0f)</p>
<p>GLM数学库例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">glm::mat4 mat = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>)<br>glm::mat4 trans;<br>glm::<span class="hljs-built_in">translate</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br>glm::<span class="hljs-built_in">rotate</span>(trans, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">90.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>));<br>glm::<span class="hljs-built_in">scale</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>));<br></code></pre></td></tr></table></figure>

<br/>

<h2 id="MVP矩阵"><a href="#MVP矩阵" class="headerlink" title="MVP矩阵"></a>MVP矩阵</h2><p>MVP&#x3D;Projection×View×Model</p>
<p>M：局部坐标到世界坐标</p>
<p>V：世界坐标到观察坐标</p>
<p>P：观察坐标到裁剪空间</p>
<p>透视投影：越远越小</p>
<p>正交投影：大小一致</p>
<br/>

<h2 id="摄像机坐标方向"><a href="#摄像机坐标方向" class="headerlink" title="摄像机坐标方向"></a>摄像机坐标方向</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//相机方向</span><br>glm::vec3 cameraTarget = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>glm::vec3 cameraDirection = glm::<span class="hljs-built_in">normalize</span>(cameraPos - cameraTarget);<br><span class="hljs-comment">//相机右轴</span><br>glm::vec3 up = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>); <br>glm::vec3 cameraRight = glm::<span class="hljs-built_in">normalize</span>(glm::<span class="hljs-built_in">cross</span>(up, cameraDirection));<br><span class="hljs-comment">//上轴</span><br>glm::vec3 cameraUp = glm::<span class="hljs-built_in">cross</span>(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure>

<p>lookAt矩阵：glm::LookAt函数(位置、目标、上向量）</p>
<br/>

<br/>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>https://learnopengl-cn.github.io/</p>
]]></content>
      <categories>
        <category>图形API</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
</search>
