<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bat命令</title>
    <url>/article/ad6c93b9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="批处理程序"><a href="#批处理程序" class="headerlink" title="批处理程序"></a>批处理程序</h2><blockquote>
<p>bat文件，常用于文件的批量处理，对提高工作效率很帮助。命令很简单，短短几句，掌握了之后可节约很多的时间。下面做个简单的总结，当然要全部掌握，以下这些是不够的，还需多练习，挖掘出更多的用法。</p>
</blockquote>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>%~dp0  ：当前执行bat的目录，运行过程不会变化；</p>
<p>%cd%  ：bat 脚本执行时，运行的目录，随bat运行变化；</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>set /p string=请输入：</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 用于输出字符串，和输出内容之间一般用空格隔离，当然也可以用逗号，推荐使用空格（在特殊情况下逗号不被允许使用）</p>
<p>举例：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem 关闭回显</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br></pre></td></tr></table></figure>



<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>%1~9 表示参数的占位符，%0不用于参数表示，表示批处理文件本身；若大于9个参数乃至更多的参数，请使用shift 标识符；</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>[&gt;&gt;]和[&gt;] 的区别，一个是追加，一个是重新写入；</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的三大功能：截取、替换、合并</p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> [<span class="keyword">NOT</span>] <span class="keyword">ERRORLEVEL</span> number command</span><br><span class="line"><span class="keyword">IF</span> [<span class="keyword">NOT</span>] string1==string2 command</span><br><span class="line"><span class="keyword">IF</span> [<span class="keyword">NOT</span>] <span class="keyword">EXIST</span> filename command</span><br></pre></td></tr></table></figure>



<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>文件目录操作</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">for</span> <span class="selector-attr">[option]</span> %%<span class="selector-tag">i</span> <span class="selector-tag">in</span> () <span class="selector-tag">do</span> ()</span><br></pre></td></tr></table></figure>

<p>/d  :匹配目录名</p>
<p>/r：递归</p>
<p>/l：增量递增</p>
<p>/f：内容提取</p>
<h2 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h2><p>setlocal和endlocal  </p>
<h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><p>call  调用bat文件，</p>
<p>goto到子程序，可采用 exit /b %errorlevel%  返回给父进程</p>
<h2 id="路径栈"><a href="#路径栈" class="headerlink" title="路径栈"></a>路径栈</h2><p>pushd 和popd 路径压栈，出栈</p>
<h2 id="调用程序"><a href="#调用程序" class="headerlink" title="调用程序"></a>调用程序</h2><p>start 开启程序</p>
<h2 id="宏使用"><a href="#宏使用" class="headerlink" title="宏使用"></a>宏使用</h2><p>$g  :重定向到设备或文件</p>
<p>$g$g:追加到文件末尾</p>
<p>$b:将宏输出给命令，同管道</p>
<p>$t:命令分隔符</p>
<p>$1-9:参数</p>
<p>$*:后续命令</p>
<p>echo off …. echo on，使得整个宏运行时不会多次换行</p>
<p>更多内容后续更新，点关注不迷路…</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>bat命令</tag>
      </tags>
  </entry>
  <entry>
    <title>优美的句子</title>
    <url>/article/35fb243/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="统计单词个数"><a href="#统计单词个数" class="headerlink" title="统计单词个数"></a>统计单词个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String text = <span class="string">"Good morning. Have a good class. "</span> + <span class="string">"Have a good visit. Have fun!"</span>;</span><br><span class="line">		Stream.of(text.split(<span class="string">"[\\s+\\p&#123;P&#125;]"</span>)).parallel().filter(e -&gt; e.length() &gt; <span class="number">0</span>)</span><br><span class="line">				.collect(Collectors.groupingBy(String::toLowerCase, TreeMap::<span class="keyword">new</span>, Collectors.counting()))</span><br><span class="line">				.forEach((k, v) -&gt; System.out.println(k + <span class="string">" "</span> + v));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br/>

<h2 id="计算文件大小"><a href="#计算文件大小" class="headerlink" title="计算文件大小"></a>计算文件大小</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getSize</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">			<span class="keyword">return</span> file.length();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> Files.list(file.toPath()).parallel().mapToLong(e -&gt; getSize(e.toFile())).sum();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String dir = in.nextLine();</span><br><span class="line">		System.out.println(getSize(<span class="keyword">new</span> File(dir)) + <span class="string">"bytes"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA并发编程-原子性、可见性、有序性</title>
    <url>/article/1a8f4df9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，是不可被中断的。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">233</span>;        <span class="comment">//语句1</span></span><br><span class="line">b = a;          <span class="comment">//语句2</span></span><br><span class="line">a++;            <span class="comment">//语句3</span></span><br><span class="line">a = a + <span class="number">1</span>;      <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>a++和 a = a+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>Java内存模型只提供了基本的读取和赋值原子操作保证，若要对大范围的操作提供原子保证，可以通过synchronized和Lock来实现，来达到线程安全。</p>
<h2 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile保证了不同线程对这个变量进行操作时的可见性</p>
<p>1）一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的（拷贝副本》修改副本》刷新回主存）；</p>
<p>2）禁止进行指令重排序；</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">result = init();   <span class="comment">//语句1</span></span><br><span class="line">flag = <span class="keyword">true</span>;       <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!flag )&#123;</span><br><span class="line">  Thread.sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomething(result);</span><br></pre></td></tr></table></figure>

<p>若flag未加volatile 修饰，可能先于语句1执行，在多线程环境下，result还未取到结果，可flag已为true，线程2误以为result有值，便开始执行doSomething…，最后发生异常~</p>
<p>除此之外，常见用volatile 关键字的地方还有双重判空的单例模式；</p>
<p>因 volatile关键字会在内存中产生一个内存屏障，起到阻挡作用，禁止了指令的重排。</p>
<h3 id="synchronized和Lock"><a href="#synchronized和Lock" class="headerlink" title="synchronized和Lock"></a>synchronized和Lock</h3><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>即程序执行的顺序按照代码的先后顺序执行。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”；但并不是100%，毕竟volatile无法保证操作的原子性；</p>
<p>synchronized关键字通过加锁可以使线程达到同步，但是会产生阻塞，涉及到<strong>用户模式</strong>和<strong>内核模式</strong>的转换，这会很影响程序执行的效率。那么存在不用加锁的吗？当然有—无锁机制CAS，原子类的实现原理，放在后面讲解，这里不做讨论。</p>
<p>通过使用以及原理对比，我们可以发现，volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性！</p>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p>摘自—-《深入理解Java虚拟机》</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>abbrlink踩坑</title>
    <url>/article/856a5aa8/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>博客搭建有一段时间了，但是链接地址却和文件名紧紧绑定在一起，及其不方便扩展，也给写作带来些许不便。</p>
<p>于是乎，今天便想着来搞搞；为了生成永久链接，这里使用abbrlink这个插件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部安装</span></span><br><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>嗯哼~ 安装失败….再来</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>ok了，这里配置了镜像，还是cnpm好用；</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>继续，开始配置外部的 _config.yml </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">article/:abbrlink/</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment">#true(default)</span></span><br><span class="line">     <span class="attr">depth:</span>        <span class="comment">#3(default)</span></span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#enable auto title, it can auto fill the title by path</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> <span class="comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span></span><br></pre></td></tr></table></figure>

<p>大家应该都看得懂了~</p>
<p>不过这里有个注意事项，auto_category 默认是true，这里我设置成false；下面是auto_category的源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> opt_AutoCategoryEnable = config.auto_category &amp;&amp; config.auto_category.enable;</span><br><span class="line"><span class="keyword">var</span> overwrite = config.auto_category &amp;&amp; config.auto_category.over_write;</span><br><span class="line"><span class="keyword">if</span> (opt_AutoCategoryEnable &amp;&amp; overwrite) &#123;</span><br><span class="line">	<span class="keyword">var</span> categories = data.source.split(<span class="string">'/'</span>);</span><br><span class="line">	<span class="keyword">var</span> opt_AutoCategoryDepth = config.auto_category.depth || <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">var</span> depth = opt_AutoCategoryDepth || categories.length - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (categories.length - <span class="number">2</span> == <span class="number">0</span> || depth == <span class="number">0</span>) &#123;</span><br><span class="line">		tmpPost.categories = <span class="keyword">this</span>.config.default_category;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> newCategories = categories.slice(<span class="number">1</span>, <span class="number">1</span> + <span class="built_in">Math</span>.min(depth, categories.length - <span class="number">2</span>));</span><br><span class="line">		<span class="comment">//prevents duplicate file changes</span></span><br><span class="line">		<span class="keyword">if</span> (</span><br><span class="line">			!<span class="built_in">Array</span>.isArray(tmpPost.categories) ||</span><br><span class="line">			!tmpPost.categories.join(<span class="string">'_'</span>) == newCategories.join(<span class="string">'_'</span>)</span><br><span class="line">		) &#123;</span><br><span class="line">			tmpPost.categories = newCategories;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来查看一下hexo-abbrlink的版本</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">npm view hexo-abbrlink versions --json</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.0"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.1"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.2"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"1.0.3"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.1"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.2"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.4"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.0.5"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.1.5"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.1.6"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.2.0"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"2.2.1"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure>

<p>默认安装的是最新版是2.2.1；</p>
<p>abbrlink 的原理是在每篇文章的属性里加上一个16位/32位的十六进制的数，来作为文章唯一的id。具体内部实现依靠hexo-fs插件来进行写入生成；</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>在配置好以上内容之后，就可以开始执行生成索引了，这是最后一步了。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>

<p>可执行了以上命令之后，情况又不妙了~</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">Error: EEXIST: file already exists, mkdir '</span>F:\software2\MyGithubPage\hexo\source\_posts\Android<span class="string">'</span></span><br><span class="line"><span class="string">    at Object.mkdirSync (fs.js:729:3)</span></span><br><span class="line"><span class="string">    at Object.writeFileSync (F:\software2\MyGithubPage\hexo\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js:63:6)</span></span><br><span class="line"><span class="string">    at Hexo.logic (F:\software2\MyGithubPage\hexo\node_modules\_hexo-abbrlink@2.2.1@hexo-abbrlink\lib\logic.js:98:20)</span></span><br><span class="line"><span class="string">    at Hexo.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Hexo.&lt;anonymous&gt; (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\method.js:15:34)</span></span><br><span class="line"><span class="string">    at Promise.each.filter (F:\software2\MyGithubPage\hexo\node_modules\hexo\lib\extend\filter.js:62:52)</span></span><br><span class="line"><span class="string">    at tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Object.gotValue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:166:18)</span></span><br><span class="line"><span class="string">    at Object.gotAccum (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\reduce.js:155:25)</span></span><br><span class="line"><span class="string">    at Object.tryCatcher (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Promise._settlePromiseFromHandler (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:547:31)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:604:18)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise0 (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:649:10)</span></span><br><span class="line"><span class="string">    at Promise._settlePromises (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\promise.js:729:18)</span></span><br><span class="line"><span class="string">    at _drainQueueStep (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:93:12)</span></span><br><span class="line"><span class="string">    at _drainQueue (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:86:9)</span></span><br><span class="line"><span class="string">    at Async._drainQueues (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:102:5)</span></span><br><span class="line"><span class="string">    at Immediate.Async.drainQueues [as _onImmediate] (F:\software2\MyGithubPage\hexo\node_modules\bluebird\js\release\async.js:15:14)</span></span><br><span class="line"><span class="string">    at runCallback (timers.js:693:18)</span></span><br><span class="line"><span class="string">    at tryOnImmediate (timers.js:664:5)</span></span><br><span class="line"><span class="string">    at processImmediate (timers.js:646:5)</span></span><br></pre></td></tr></table></figure>

<p>报了一堆堆栈日志，通过观察，我们可以看到程序是在执行了 logic.js 之后，接着执行 fs.js 报错的；文件已存在，程序还在强行创建!!!!</p>
<p>为了一探究竟，我们进入到logic.js 中看看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFileSync(data.full_source, postStr, <span class="string">'utf-8'</span>);</span><br></pre></td></tr></table></figure>

<p>程序是执行了这段代码导致的，如果abbrlink不存在的话，该插件会遍历文件夹中的文件进行写入，然后创建新的文件夹；继续追，查看下package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  "hexo-front-matter": "^1.0.0",</span><br><span class="line">  "hexo-fs": "^3.1.0"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>依赖的最新的fs是3.1。进入hexo-js中，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeFileSync</span>(<span class="params">path, data, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'path is required!'</span>);</span><br><span class="line"></span><br><span class="line">  fs.mkdirSync(dirname(path), &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  fs.writeFileSync(path, data, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好家伙，直接就创建了，都不检查下的吗？？</p>
<h2 id="手动修改hexo-fs"><a href="#手动修改hexo-fs" class="headerlink" title="手动修改hexo-fs"></a>手动修改hexo-fs</h2><p>路径：<code>\node_modules\_hexo-fs@3.1.0@hexo-fs\lib\fs.js</code>  文件</p>
<p>在文件中添加以下函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkParentSync</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'path is required!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> parent = dirname(path);</span><br><span class="line">  <span class="keyword">var</span> exist = fs.existsSync(parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exist) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mkdirsSync(parent);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'EEXIST'</span>) <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将fs.mkdirSync 注释掉，增加 checkParentSync(path);  的调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs.mkdirSync(dirname(path), &#123; recursive: true &#125;);</span></span><br><span class="line">checkParentSync(path);</span><br></pre></td></tr></table></figure>



<p>最后，大功告成~:happy:</p>
]]></content>
      <categories>
        <category>踩坑日记</category>
      </categories>
      <tags>
        <tag>abbrlink</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA数据结构之Map集合</title>
    <url>/article/497b1455/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 继承于AbstractMap，实现于Map接口；由数组加链表实现，默认大小16，加载因子0.75</p>
<p>众所周知，HashMap是线程不安全的，HashTable才是线程安全的，那么究竟是什么导致线程不安全的呢？</p>
<p>put操作，在多线程模式下，触发扩容机制，导致数据被覆盖；</p>
<p>但是在单线程模式下还是可以使用的，其结构采用数组+链表的形式；通过hashcode 值得到索引，再追加到链表中，当链表的长度大于8时，采用红黑树算法；</p>
<p>为了使其线程安全，在 java.util.Collections  集合中有个Collections.synchronizedMap包装器；该包装器可以使其达到线程安全的效果；</p>
<p>示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>+ finalI *<span class="number">250</span>; j &lt;<span class="number">250</span>+finalI *<span class="number">250</span>; j++) &#123;</span><br><span class="line">                        map.put(String.valueOf(j), String.valueOf(j));</span><br><span class="line">                        map2.put(String.valueOf(j), String.valueOf(j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!String.valueOf(i).equals(map.get(String.valueOf(i)))) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"map false"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!String.valueOf(i).equals(map2.get(String.valueOf(i)))) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"map2 false"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">map2 <span class="literal">false</span></span><br><span class="line">...</span><br><span class="line">map2 <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>补充：hash冲突： 开发寻址法：线性探测法、二次探测法、双重哈希；链表法</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>而hashtable之所以线程安全，因为它的put和get操作均添加有synchronized关键字，进行同步操作，获取锁，使其他线程阻塞等待；</p>
<p>因为当一个线程访问hashtable的同步方法时，其他线程再次尝试访问的时候，会进入阻塞或者轮询状态，比如当线程1使用put进行元素添加的时候，线程2不但不能使用put来添加元素，而且不能使用get获取元素。</p>
<p>虽然达到了线程安全的效果，但是极大的降低了效率，不推荐使用；</p>
<p>既然HashMap是线程不安全的，而HashTable的效率又不是很高，那么有没有除了他俩之外的其他数据结构呢？</p>
<p>答案当然有，如：ConcurrentHashMap等等；</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>通过属性值可知，和HashMap一样，默认容量也是16，大于8转为树，并且还是线程安全的；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">static <span class="keyword">final</span> <span class="built_in">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 采用了一种叫做分段锁的机制，分段进行加锁，同时进行读写，大大地提高了效率；比围绕非线程安全Map的Collections.synchronizedMap包装器性能更高。</p>
<p>且在jdk1.8中对ConcurrentHashMap 进行了优化，采用compareAndSwapInt+synchronized 方式进而大大提高了效率。</p>
<p>除此之外，它还提供了一些原子操作的方法：</p>
<p><strong>putIfAbsent</strong></p>
<p>putIfAbsent方法主要是在向ConcurrentHashMap中添加键—值对的时候，它会先判断该键值对是否已经存在。</p>
<ul>
<li>如果不存在（新的entry），那么会向map中添加该键值对，并返回null；</li>
<li>如果已经存在，那么不会覆盖已有的值，直接返回已经存在的值；</li>
</ul>
<p><strong>computeIfAbsent</strong></p>
<ul>
<li>如果 key 对应的 value 不存在，则使用获取 remappingFunction 重新计算后的值，并保存为该 key 的 value，否则返回 value。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li>LinkedHashMap属于HashMap的子类，与HashMap的区别在于LinkedHashMap保存了记录插入的顺序。</li>
<li>LinkedHashMap 是一个双向的链表，包含有链表头、尾的指针，因这个特性，所以LinkedHashMap 是有序的，而HashMap是无序的。</li>
<li>LinkedHashMap的构造函数中有个 accessOrder 变量，true 表示链表按访问顺序，false 表示按插入顺序；</li>
<li>如下所示，通过对该变量的控制，可以利用LinkedHashMap实现LruCache的核心思想;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li><p>TreeMap实现了SortedMap接口，TreeMap有能力对插入的记录根据key排序，默认按照升序排序，也可以自定义比较强，在使用TreeMap的时候，key应当实现Comparable。</p>
</li>
<li><p>TreeMap基于红黑树实现，非线程安全 ；</p>
</li>
<li><p>与HashMap比较：两者均是线程不安全的；通常情况下HashMap通常比TreeMap快些，若是使用排序选择TreeMap，其他情况则建议多使用HashMap；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法稳定性介绍</title>
    <url>/article/a0d5c7de/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="不稳定排序算法"><a href="#不稳定排序算法" class="headerlink" title="不稳定排序算法"></a>不稳定排序算法</h3><ol>
<li>选择排序 — O(n²)</li>
<li>希尔排序 — O(nlogn)</li>
<li>堆排序 — O(nlogn)</li>
<li>快速排序 — O(nlogn) 期望时间,O(n²) 最坏情况; </li>
</ol>
<br/>

<h3 id="稳定排序算法"><a href="#稳定排序算法" class="headerlink" title="稳定排序算法"></a>稳定排序算法</h3><ol>
<li>冒泡排序  — O(n²)</li>
<li>插入排序 — O(n²)</li>
<li>桶排序 — O(n); 需要 O(k)额外空间</li>
<li>计数排序  — O(n+k); 需要O(n+k) 额外空间</li>
<li>合并排序  — O(nlogn); 需要O(n) 额外空间</li>
<li>二叉排序树排序   —O(n log n) 期望时间; O(n²)最坏时间; 需要O(n) 额外空间</li>
<li>基数排序  —O(n·k); 需要O(n) 额外空间</li>
</ol>
<h2 id="快排code"><a href="#快排code" class="headerlink" title="快排code"></a>快排code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] qSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = arr[s], i = s, j = e;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((i&lt;j)&amp;&amp;(arr[j]&gt;p)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((i&lt;j)&amp;&amp;(arr[i]&lt;p)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((arr[i]==arr[j])&amp;&amp;(i&lt;j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s&lt;i-<span class="number">1</span>) arr=qSort(arr,s,i-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (j+<span class="number">1</span>&lt;e) arr=qSort(arr,j+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">return</span> (arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    arr=qSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:arr) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>几个经典的动态规划问题</title>
    <url>/article/b2b6f046/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="硬币找零"><a href="#硬币找零" class="headerlink" title="硬币找零"></a>硬币找零</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(a,Integer.MAX_VALUE);</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; value) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                a[i] = Math.min(a[i], a[i - value] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+ <span class="string">" : "</span>+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>] &gt;= a[i]) &#123;</span><br><span class="line">            anchor = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, i - anchor + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">char</span>[] b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>][b.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[a.length][b.length]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者模式</title>
    <url>/article/e6c2b842/</url>
    <content><![CDATA[<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>通过使用CountDownLatch 来模拟并发场景，用synchronized来进行多线程间的同步，保障线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> full = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNum = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> LinkedBlockingQueue&lt;String&gt; link = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Runnable product = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == full) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    link.add(Thread.currentThread().getName() + <span class="string">" product: "</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" consumer: "</span> + link.poll());</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            Thread pThread = <span class="keyword">new</span> Thread(product);</span><br><span class="line">            pThread.start();</span><br><span class="line">            Thread cThread = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">            cThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="image-20210306193021365.png" alt="image-20210306193021365"></p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>采用重入锁（ReentrantLock）机制来实现，使用了两个Condition，分别控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> full = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNum = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkedBlockingQueue&lt;String&gt; link = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Runnable product = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == full) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    link.add(Thread.currentThread().getName() + <span class="string">" product: "</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (link.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        notEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" consumer: "</span> + link.poll());</span><br><span class="line">                    notFull.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            Thread pThread = <span class="keyword">new</span> Thread(product);</span><br><span class="line">            pThread.start();</span><br><span class="line">            Thread cThread = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">            cThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<p><img src="image-20210306193529183.png" alt="image-20210306193529183"></p>
<p>当然除了以上两种方式之外，还可以用Semaphore 共享锁机制来实现以及阻塞队列的take方法，感兴趣的可以去实现一下。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>生产者与消费者</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/article/71c610d3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表创建"><a href="#单链表创建" class="headerlink" title="单链表创建"></a>单链表创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">SingleNode</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(a[i]);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单链表逆序输出"><a href="#单链表逆序输出" class="headerlink" title="单链表逆序输出"></a>单链表逆序输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=f(head.next);</span><br><span class="line">    System.out.print(head.data + <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p>链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">f2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>||head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=f2(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">head=f2(head);</span><br></pre></td></tr></table></figure>



<h3 id="逆序输出并未反转"><a href="#逆序输出并未反转" class="headerlink" title="逆序输出并未反转"></a>逆序输出并未反转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=f(head.next);</span><br><span class="line">    System.out.print(head.data + <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">f(head);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发编程-ThreadLocal</title>
    <url>/article/b0029a08/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="number">2020</span>);</span><br><span class="line">    System.out.println(<span class="string">"parent-thread-s:"</span> + threadLocal.get());</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"child-thread-s:"</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="number">2021</span>);</span><br><span class="line">            System.out.println(<span class="string">"child-thread-e:"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">"parent-thread-e:"</span> + threadLocal.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">parent-thread-s:<span class="number">2020</span></span><br><span class="line">parent-thread-e:<span class="number">2020</span></span><br><span class="line">child-thread-s:<span class="literal">null</span></span><br><span class="line">child-thread-e:<span class="number">2021</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>有利必有弊，虽然解决了上面说到的问题，但是每个线程都创建了变量副本，这时就要考虑它对资源的消耗，使用ThreadLocal时占用的内存资源肯定是会比没有使用的时占用的多。</p>
<p>在之前的文章有提到synchronized，同样是解决线程安全的，那么他俩到底有啥区别呢？</p>
<p> synchronized，采用的是阻塞的方式，让线程等待，保证有序进行访问；不占用其他资源，可以说是采用了时间换取空间的策略；而ThreadLocal和线程同步机制相比较，恰好相反，它采用的是以空间换取时间的策略。</p>
<p>下面来看下ThreadLocal的源码</p>
<h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，一个线程中的多个ThreadLocal是通过该线程的ThreadLocalMap来管理的；也就是说，每个线程都维护有一个ThreadLocalMap。当在线程中使用来自其他线程的ThreadLocal时，在set的时候，是在根据线程名查找自己线程中是否有ThreadLocalMap，若没有则创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocalMap构造函数"><a href="#ThreadLocalMap构造函数" class="headerlink" title="ThreadLocalMap构造函数"></a>ThreadLocalMap构造函数</h3><p>ThreadLocalMap是ThreadLocal的一个静态内部类，一个简单的Map结构，阈值为16*2/3,底层为数组，数组元素为Entry，Entry采用的是弱引用的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry持有ThreadLocal的弱引用，而table属于ThreadLocalMap，因而，ThreadLocalMap的key采用对ThreadLocal的弱引用。弱引用的生命周期短语软引用，远短于强引用，因此，还需注意垃圾回收的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法先是获取到当前线程的ThreadLocalMap，再根据ThreadLocal这个key来获取值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据hashcode值来进行获取数组中对应的Entry对象元素；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果没有获取到，那么用线性碰撞的方式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该位置置空，再哈希；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>移除的是当前线程中ThreadLocalMap对应的ThreadLocal  key值，解除弱引用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ThreadLocal为变量在每个线程中都创建了一个副本，每个线程访问自己内部的副本变量，而彼此不会相互影响；</li>
<li>一个ThreadLocal对应着多个ThreadLocalMap，每个ThreadLocalMap对应着一个线程；</li>
<li>如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaPoet讲解</title>
    <url>/article/fa8ccf2d/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="JavaPoet"><a href="#JavaPoet" class="headerlink" title="JavaPoet"></a>JavaPoet</h2><p>JavaPoet是Square推出的开源Java代码生成框架，提供Java Api生成.java源文件。通过这个框架可以很方便的使用它根据注解、数据库模式、协议格式等来对应生成代码。用这种自动化生产代码的方式可以来替换冗杂重复的工作，提高工作效率。</p>
<p>代码生成技术相当于元编程，可用于编译期根据注解等元数据动态生成Java类。在框架Dagger、ButterKnife等等中就是利用JavaPoet注解的方式实现生成所需的类。</p>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ul>
<li>JavaFile：用于构造输出包含一个顶级类的Java文件，是对.java文件的抽象；</li>
<li>TypeSpec：TypeSpec是类/接口/枚举的抽象；</li>
<li>MethodSpec：MethodSpec是方法/构造函数的抽象；</li>
<li>FieldSpec：FieldSpec是成员变量/字段的抽象；</li>
<li>ParameterSpec：ParameterSpec用于创建参数；</li>
<li>AnnotationSpec：AnnotationSpec用于创建注解；</li>
<li>TypeName：类型；</li>
<li>ClassName：用来包装一个类；</li>
</ul>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><ul>
<li>$L     参数，方法中的参数；</li>
<li>$S     字符串，和String.format中%s一样；</li>
<li>$N     方法或变量的名称，我们自己生成的方法名或者变量名等等；</li>
<li>$T     类型名，指的是TypeName，该模板主要将Class抽象出来，用传入的TypeName指向的Class来代替；</li>
</ul>
<p>设置方法抛出异常,可以使用addException方法,传入指定的异常的ClassName,即可为该方法设置其抛出该异常.</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compileOnly <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class="line">annotationProcessor <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class="line">implementation <span class="string">'com.squareup:javapoet:1.12.1'</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，还需要配合注解解释器来使用才行，一般我们常用的或注解解释器为 AutoService 和 gradle-incap-helper。</p>
<h4 id="自定义处理器"><a href="#自定义处理器" class="headerlink" title="自定义处理器"></a>自定义处理器</h4><p>注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以自定义注解，并注册相应的注解处理器（自定义的注解处理器需继承自AbstractProcessor）。</p>
<p>注意：注解处理器是运行在独立的虚拟机JVM中，javac启动一个完整Java虚拟机来运行注解处理器。</p>
<h5 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h5><ul>
<li>init(ProcessingEnvironment env): 初始化方法，会被注解处理器调用，可以从ProcessingEnviroment对象中获取到如Elements, Types,Messager和Filer等工具类；</li>
<li>process(Set&lt; ? extends TypeElement&gt; annotations, RoundEnvironment env): 真正的处理方法，也是核心的方法。在这里写如何处理注解的代码，以及生成的java文件需要存放的位置。参数RoundEnviroment可以查询出包含特定注解的被注解元素。</li>
<li>getSupportedAnnotationTypes(): 指定注解处理器是注册给哪个注解的。返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。</li>
<li>getSupportedSourceVersion(): 用来指定你使用的Java版本。通常返回SourceVersion.latestSupported()。</li>
</ul>
<p>技巧：后面两个方法还有另一种写法（通过注解给定）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(&#123;Constants.BINDERVIEW_ANNOTATION_TYPES&#125;)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SupportedAnnotationTypes</span>(<span class="title">Constant</span>.<span class="title">ANY_TYPE</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CustomProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Filer filer; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">    filer = processingEnvironment.getFiler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">            .returns(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            .addParameter(String[].class, "args")</span><br><span class="line">            .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">            .addMethod(main)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        javaFile.writeTo(filer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SourceVersion.RELEASE_7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="kapt和transform的差别"><a href="#kapt和transform的差别" class="headerlink" title="kapt和transform的差别"></a>kapt和transform的差别</h4><p>AbstractProcessor只能处理注解，然后根据注解通过javapoet生成一个新的java类。而transfrom则是通过gradle插件的transfrom方法，对.class文件做的修改。</p>
<p>AbstractProcessor是一个抽象类，它的父类是Processer。Processor会在编译阶段初始化，然后对当前模块内的代码进行一次扫描，然后获取到对应的注解，之后调用process方法，然后我们根据这些注解类来做一些后续操作。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>source(源代码) -&gt; processor（处理器） -&gt; generate （文件生成）-&gt; javacompiler -&gt; .class文件 -&gt; .dex(只针对安卓)。</p>
<p><em>官方链接：<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">https://github.com/square/javapoet</a></em></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>JavaPoet</tag>
      </tags>
  </entry>
  <entry>
    <title>线程模型&amp;线程池</title>
    <url>/article/a6b81681/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h2><ul>
<li>内核级线程模型</li>
<li>用户级线程模型</li>
<li>混合型线程模型</li>
</ul>
<h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>用户线程与内核线程是1对1关系。</p>
<p>优点：该模型在一个线程执行阻塞系统调用时，能够允许另一个线程继续执行，允许多个线程并行运行在多处理器系统上。</p>
<p>缺点：创建一个用户线程就要创建一个相应的内核线程。为了提升性能，大多数实现限制了系统支持的线程数量。</p>
<p>应用：Linux、Windows 操作系统都实现了一对一模型。</p>
<h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户线程与内核线程是多对1关系。映射多个用户级线程到一个内核线程。</p>
<p>优点：线程管理是由用户空间的线程库来完成的，因此效率更高。</p>
<p>缺点：如果一个线程执行阻塞系统调用，那么整个进程将会阻塞。再者，因为任一时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上。</p>
<p>应用：现在几乎没有系统继续使用这个模型，因为它无法利用多个处理核。</p>
<h3 id="混合型线程模型"><a href="#混合型线程模型" class="headerlink" title="混合型线程模型"></a>混合型线程模型</h3><p>用户线程与内核线程是多对多关系。</p>
<p>优点：开发人员可以创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。而且，当一个线程执行阻塞系统调用时，内核可以调度另一个线程来执行；</p>
<p>缺点：这种动态关联机制的实现很复杂，也需要用户自己去实现；</p>
<p>应用：Go语言中的并发就是使用的这种实现方式。</p>
<h2 id="线程生命状态"><a href="#线程生命状态" class="headerlink" title="线程生命状态"></a>线程生命状态</h2><ul>
<li><strong>NEW</strong> ，新建</li>
<li><strong>RUNNABLE</strong> ，运行</li>
<li><strong>BLOCKED</strong> ，阻塞</li>
<li><strong>WAITING</strong> ，等待</li>
<li><strong>TIMED_WAITING</strong> ，超时等待</li>
<li><strong>TERMINATED</strong>，终结</li>
</ul>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>使用ExecutorService线程池</li>
</ul>
<blockquote>
<p>注意：其中前两种方式线程执行完后都没有返回值，<strong>后两种是带返回值</strong>的。</p>
</blockquote>
<p>例子</p>
<p><img src="image-20210221163248651.png" alt="image-20210221163248651"></p>
<p><img src="image-20210221163431129.png" alt="image-20210221163431129"></p>
<p>输出：</p>
<p><img src="image-20210221163506027.png" alt="image-20210221163506027"></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>默认线程池：ThreadPoolExecutor </li>
<li>定时线程池：ScheduledThreadPoolExecutor </li>
</ul>
<h3 id="五种线程池创建类型"><a href="#五种线程池创建类型" class="headerlink" title="五种线程池创建类型"></a>五种线程池创建类型</h3><ul>
<li><p>newFixedThreadPool（<strong>固定大小线程池</strong>）</p>
</li>
<li><p>newSingleThreadExecutor(<strong>单个后台线程</strong>）</p>
</li>
<li><p>newCachedThreadPool（<strong>无界线程池，可以进行自动线程回收</strong>）</p>
</li>
<li><p>newScheduledThreadPool (<strong>可调度</strong>)</p>
</li>
</ul>
<p>​      创建一个定长线程池，支持<strong>定时及周期性任务执行</strong>。和 其他线程池最大的区别是使用的阻塞队列是 <strong>DelayedWorkQueue</strong>，而且多了两个定时执行的方法scheduleAtFixedRate和scheduleWithFixedDelay</p>
<ul>
<li>newWorkStealingPool（<strong>并行操作</strong>）</li>
</ul>
<p>​     JDK1.8新增newWorkStealingPool，适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类<strong>ForkJoinPool</strong>的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很<strong>耗时</strong>的任务中。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>异步流使用详解</title>
    <url>/article/762aaa36/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123; <span class="comment">// 序列构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们正在计算</span></span><br><span class="line">        yield(i) <span class="comment">// 产生下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 假装我们在这里做了一些异步的事情</span></span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用Flow类型构建器函数：</p>
<ul>
<li>名为 flow的 Flow类型构建器函数。</li>
<li><code>flow { ... }</code> 构建块中的代码可以挂起。</li>
<li>函数 <code>simple</code> 不再标有 <code>suspend</code> 修饰符。</li>
<li>流使用 emit函数 <em>发射</em> 值。</li>
<li>流使用 collect 函数 <em>收集</em> 值。</li>
</ul>
<p>我们可以在 <code>simple</code> 的 <code>flow { ... }</code> 函数体内使用 <code>Thread.sleep</code> 代替 delay 以观察主线程在本案例中被阻塞了。</p>
<p>flow 构建器中的代码直到流被收集的时候才运行</p>
<h3 id="流的超时取消"><a href="#流的超时取消" class="headerlink" title="流的超时取消"></a>流的超时取消</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)          </span><br><span class="line">        println(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123; <span class="comment">// 在 250 毫秒后超时</span></span><br><span class="line">        simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h3><p><code>flow { ... }</code> 构建器是最基础的一个    </p>
<p>flowOf 构建器定义了一个发射固定值集的流。<br>使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个整数区间转化为流</span></span><br><span class="line">(<span class="number">1</span>..<span class="number">3</span>).asFlow().collect &#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure>



<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="过渡流操作符"><a href="#过渡流操作符" class="headerlink" title="过渡流操作符"></a>过渡流操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 模仿长时间运行的异步工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"response <span class="variable">$request</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 一个请求流</span></span><br><span class="line">        .map &#123; request -&gt; performRequest(request) &#125;</span><br><span class="line">        .collect &#123; response -&gt; println(response) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">response <span class="number">1</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure>



<h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 一个请求流</span></span><br><span class="line">    .transform &#123; request -&gt;</span><br><span class="line">        emit(<span class="string">"Making request <span class="variable">$request</span>"</span>) </span><br><span class="line">        emit(performRequest(request)) </span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123; response -&gt; println(response) &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Making request <span class="number">1</span></span><br><span class="line">response <span class="number">1</span></span><br><span class="line">Making request <span class="number">2</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">Making request <span class="number">3</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure>



<h3 id="限长操作符"><a href="#限长操作符" class="headerlink" title="限长操作符"></a>限长操作符</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                          </span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>) </span><br><span class="line">        println(<span class="string">"This line will not execute"</span>)</span><br><span class="line">        emit(<span class="number">3</span>)    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">"Finally in numbers"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    numbers() </span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// 只获取前两个</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="末端流操作符"><a href="#末端流操作符" class="headerlink" title="末端流操作符"></a>末端流操作符</h3><p>末端操作符：</p>
<ul>
<li>转化为各种集合，例如 toList 与 toSet。</li>
<li>获取第一个（first）值与确保流发射单个（single）值的操作符。</li>
<li>使用 reduce 与 fold 将流规约到单个值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = (<span class="number">1</span>..<span class="number">5</span>).asFlow()</span><br><span class="line">    .map &#123; it * it &#125; <span class="comment">// 数字 1 至 5 的平方                        </span></span><br><span class="line">    .reduce &#123; a, b -&gt; a + b &#125; <span class="comment">// 求和（末端操作符）</span></span><br><span class="line">println(sum)</span><br></pre></td></tr></table></figure>

<p>输出： 55</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>过滤偶数并将其映射到字符串</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">5</span>).asFlow()</span><br><span class="line">    .filter &#123;</span><br><span class="line">        println(<span class="string">"Filter <span class="variable">$it</span>"</span>)</span><br><span class="line">        it % <span class="number">2</span> == <span class="number">0</span>              </span><br><span class="line">    &#125;              </span><br><span class="line">    .map &#123; </span><br><span class="line">        println(<span class="string">"Map <span class="variable">$it</span>"</span>)</span><br><span class="line">        <span class="string">"string <span class="variable">$it</span>"</span></span><br><span class="line">    &#125;.collect &#123; </span><br><span class="line">        println(<span class="string">"Collect <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Filter 1</span><br><span class="line">Filter 2</span><br><span class="line">Map 2</span><br><span class="line">Collect string 2</span><br><span class="line">Filter 3</span><br><span class="line">Filter 4</span><br><span class="line">Map 4</span><br><span class="line">Collect string 4</span><br><span class="line">Filter 5</span><br></pre></td></tr></table></figure>



<p>通常，withContext 用于在 Kotlin 协程中改变代码的上下文，但是 flow {…} 构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit）。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>异步流</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中协程的特点</title>
    <url>/article/2905e442/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Android中协程的特点"><a href="#Android中协程的特点" class="headerlink" title="Android中协程的特点"></a>Android中协程的特点</h2><ul>
<li><strong>轻量</strong>：您可以在单个线程上运行多个协程，因为协程支持<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html" target="_blank" rel="noopener">挂起</a>，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。</li>
<li><strong>内存泄漏更少</strong>：使用<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" target="_blank" rel="noopener">结构化并发</a>机制在一个作用域内执行多项操作。</li>
<li><strong>内置取消支持</strong>：<a href="https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html" target="_blank" rel="noopener">取消</a>操作会自动在运行中的整个协程层次结构内传播。</li>
<li><strong>Jetpack 集成</strong>：许多 Jetpack 库都包含提供全面协程支持的<a href="https://developer.android.com/kotlin/ktx?hl=zh-cn" target="_blank" rel="noopener">扩展</a>。某些库还提供自己的<a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-cn" target="_blank" rel="noopener">协程作用域</a>，可供您用于结构化并发。</li>
</ul>
<p>非受限的调度器是一种高级机制，可以在某些极端情况下提供帮助而不需要调度协程以便稍后执行或产生不希望的副作用， 因为某些操作必须立即在协程中执行。 非受限调度器不应该在通常的代码中使用。</p>
<p>协程可以在一个线程上挂起并在其它线程上恢复。</p>
<h3 id="在不同线程间跳转"><a href="#在不同线程间跳转" class="headerlink" title="在不同线程间跳转"></a>在不同线程间跳转</h3><p>使用 <code>-Dkotlinx.coroutines.debug</code> JVM 参数运行下面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSingleThreadContext(<span class="string">"Ctx1"</span>).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(<span class="string">"Ctx2"</span>).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(<span class="string">"Started in ctx1"</span>)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(<span class="string">"Working in ctx2"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">"Back to ctx1"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[Ctx1 @coroutine#1]</span> <span class="selector-tag">Started</span> <span class="selector-tag">in</span> <span class="selector-tag">ctx1</span></span><br><span class="line"><span class="selector-attr">[Ctx2 @coroutine#1]</span> <span class="selector-tag">Working</span> <span class="selector-tag">in</span> <span class="selector-tag">ctx2</span></span><br><span class="line"><span class="selector-attr">[Ctx1 @coroutine#1]</span> <span class="selector-tag">Back</span> <span class="selector-tag">to</span> <span class="selector-tag">ctx1</span></span><br><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" <span class="selector-tag">java</span><span class="selector-class">.security</span><span class="selector-class">.AccessControlException</span>: <span class="selector-tag">Access</span> <span class="selector-tag">control</span> <span class="selector-tag">exception</span> <span class="selector-tag">due</span> <span class="selector-tag">to</span> <span class="selector-tag">security</span> <span class="selector-tag">reasons</span> <span class="selector-tag">in</span> <span class="selector-tag">web</span> <span class="selector-tag">playground</span>: </span><br><span class="line"> <span class="selector-tag">access</span> <span class="selector-tag">denied</span> ("<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.RuntimePermission</span>" "<span class="selector-tag">modifyThread</span>")</span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.SecurityManager</span><span class="selector-class">.checkPermission</span> (<span class="selector-tag">SecurityManager</span><span class="selector-class">.java</span><span class="selector-pseudo">:549)</span></span><br></pre></td></tr></table></figure>

<p>使用 runBlocking 来显式指定了一个上下文，并且另一个使用 withContext 函数来改变协程的上下文，而仍然驻留在相同的协程中</p>
<p>当我们不再需要某个在 newSingleThreadContext 中创建的线程的时候， 它使用了 Kotlin 标准库中的 use 函数来释放该线程。</p>
<p>注意，CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式。</p>
<p>当一个父协程被取消的时候，所有它的子协程也会被递归的取消。然而，当使用 GlobalScope 来启动一个协程时，则新协程的作业没有父作业。 因此它与这个启动的作用域无关且独立运作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="string">"Started main coroutine"</span>)</span><br><span class="line"><span class="comment">// 运行两个后台值计算</span></span><br><span class="line"><span class="keyword">val</span> v1 = async(CoroutineName(<span class="string">"v1coroutine"</span>)) &#123;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    log(<span class="string">"Computing v1"</span>)</span><br><span class="line">    <span class="number">252</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> v2 = async(CoroutineName(<span class="string">"v2coroutine"</span>)) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="string">"Computing v2"</span>)</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">"The answer for v1 / v2 = <span class="subst">$&#123;v1.await() / v2.await()&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>



<p>协程上下文中定义多个元素</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Default + CoroutineName(<span class="string">"test"</span>)) &#123;</span><br><span class="line">    println(<span class="string">"I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="literal">I</span>'m working <span class="keyword">in</span> thread DefaultDispatcher-worker-<span class="number">1</span> <span class="meta">@test</span><span class="comment">#2</span></span><br></pre></td></tr></table></figure>



<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mainScope = CoroutineScope(Dispatchers.Default) <span class="comment">// use Default for test purposes</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mainScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class="line">        repeat(<span class="number">10</span>) &#123; i -&gt;</span><br><span class="line">            mainScope.launch &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// Activity 类结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> activity = Activity()</span><br><span class="line">    activity.doSomething() <span class="comment">// 运行测试函数</span></span><br><span class="line">    println(<span class="string">"Launched coroutines"</span>)</span><br><span class="line">    delay(<span class="number">500L</span>) <span class="comment">// 延迟半秒钟</span></span><br><span class="line">    println(<span class="string">"Destroying activity!"</span>)</span><br><span class="line">    activity.destroy() <span class="comment">// 取消所有的协程</span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 为了在视觉上确认它们没有工作    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Launched coroutines</span><br><span class="line">Coroutine <span class="number">0</span> <span class="keyword">is</span> done</span><br><span class="line">Coroutine <span class="number">1</span> <span class="keyword">is</span> done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>异步流的方法详解</title>
    <url>/article/76ae8ac8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a>flowOn 操作符</h2><p>该函数用于更改流发射的上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变消耗 CPU 代码上下文的正确方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">1</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">1</span></span><br><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">2</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">2</span></span><br><span class="line">[DefaultDispatcher-worker<span class="number">-1</span> @coroutine#<span class="number">2</span>] Emitting <span class="number">3</span></span><br><span class="line">[main @coroutine#<span class="number">1</span>] Collected <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p> flowOn 操作符已改变流的默认顺序性。 现在收集发生在一个协程中（“coroutine#1”）而发射发生在运行于另一个线程中与收集协程并发运行的另一个协程（“coroutine#2”）中。当上游流必须改变其上下文中的 CoroutineDispatcher 的时候，flowOn 操作符创建了另一个协程。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .buffer() <span class="comment">// 缓冲发射项，无需等待</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">1054</span> ms</span><br></pre></td></tr></table></figure>

<p>注意，当必须更改 CoroutineDispatcher 时，flowOn 操作符使用了相同的缓冲机制， 但是我们在这里显式地请求缓冲而不改变执行上下文。</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>当流代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的那个。</p>
<p>当收集器处理它们太慢的时候， conflate 操作符可以用于跳过中间值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .conflate() <span class="comment">// 合并发射项，不对每个值进行处理</span></span><br><span class="line">        .collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">749</span> ms</span><br></pre></td></tr></table></figure>



<h2 id="处理最新值"><a href="#处理最新值" class="headerlink" title="处理最新值"></a>处理最新值</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">            println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">            println(<span class="string">"Done <span class="variable">$value</span>"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br></pre></td></tr></table></figure>

<p>由于 collectLatest 的函数体需要花费 300 毫秒，但是新值每 100 秒发射一次，我们看到该代码块对每个值运行，但是只收集最后一个值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line">Collecting <span class="number">2</span></span><br><span class="line">Collecting <span class="number">3</span></span><br><span class="line">Done <span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">691</span> ms</span><br></pre></td></tr></table></figure>



<h2 id="Zip方法"><a href="#Zip方法" class="headerlink" title="Zip方法"></a>Zip方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow() <span class="comment">// 数字 1..3</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>) <span class="comment">// 字符串</span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 组合单个字符串</span></span><br><span class="line">    .collect &#123; println(it) &#125; <span class="comment">// 收集并打印</span></span><br></pre></td></tr></table></figure>

<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one</span><br><span class="line"><span class="symbol">2 </span>-&gt; two</span><br><span class="line"><span class="symbol">3 </span>-&gt; three</span><br></pre></td></tr></table></figure>



<h2 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h2><p>当流表示一个变量或操作的最新值时，可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// 发射数字 1..3，间隔 300 毫秒</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// 每 400 毫秒发射一次字符串</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始的时间</span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 使用“zip”组合单个字符串</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one at <span class="number">425</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; two at <span class="number">825</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; three at <span class="number">1227</span> ms from start</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// 发射数字 1..3，间隔 300 毫秒</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// 每 400 毫秒发射一次字符串</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始的时间</span></span><br><span class="line">nums.combine(strs) &#123; a, b -&gt; <span class="string">"<span class="variable">$a</span> -&gt; <span class="variable">$b</span>"</span> &#125; <span class="comment">// 使用“combine”组合单个字符串</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; one at <span class="number">443</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; one at <span class="number">644</span> ms from start</span><br><span class="line"><span class="symbol">2 </span>-&gt; two at <span class="number">845</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; two at <span class="number">944</span> ms from start</span><br><span class="line"><span class="symbol">3 </span>-&gt; three at <span class="number">1245</span> ms from start</span><br></pre></td></tr></table></figure>



<h2 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h2><p>连接模式由 flatMapConcat 与 flattenConcat 操作符实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapConcat &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">127</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">1</span>: Second at <span class="number">628</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: First at <span class="number">729</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: Second at <span class="number">1229</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: First at <span class="number">1329</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: Second at <span class="number">1830</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br></pre></td></tr></table></figure>



<h2 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h2><p>另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 flatMapMerge 与 flattenMerge 操作符实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapMerge &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">136</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: First at <span class="number">231</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: First at <span class="number">333</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">1</span>: Second at <span class="number">639</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">2</span>: Second at <span class="number">732</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br><span class="line"><span class="number">3</span>: Second at <span class="number">833</span> <span class="keyword">ms</span> <span class="title">from</span> <span class="literal">start</span></span><br></pre></td></tr></table></figure>



<h2 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: First"</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// 等待 500 毫秒</span></span><br><span class="line">    emit(<span class="string">"<span class="variable">$i</span>: Second"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// 记录开始时间</span></span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// 每 100 毫秒发射一个数字 </span></span><br><span class="line">        .flatMapLatest &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// 收集并打印</span></span><br><span class="line">            println(<span class="string">"<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">142</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">2</span>: First at <span class="number">322</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">3</span>: First at <span class="number">425</span> ms <span class="keyword">from</span> start</span><br><span class="line"><span class="number">3</span>: Second at <span class="number">931</span> ms <span class="keyword">from</span> start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA并发编程-阻塞队列之ArrayBlockingQueue详解</title>
    <url>/article/5a190551/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue 有两个构造方法，一个带fair，一个不带fair；</p>
<p>fair为true：表示公平锁机制，FIFO；</p>
<p>fair为false：表示非公平机制，随机；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞队列，使用 一个ReentrantLock 和两个Condition 保证队列的安全；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加元素主要依赖于offer方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，ArrayBlockingQueue 添加元素的最终方法还是offer方法；</p>
<p>offer 方法一共有两个，一个是延时添加，一个是非延时添加；</p>
<h3 id="offer-E-e"><a href="#offer-E-e" class="headerlink" title="offer(E e)"></a>offer(E e)</h3><p>带有返回值的添加，lock加锁保证原子操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="offer-E-e-long-timeout-TimeUnit-unit"><a href="#offer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="offer(E e, long timeout, TimeUnit unit)"></a>offer(E e, long timeout, TimeUnit unit)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//lockInterruptibly() 方法的作用：如果当前线程未被中断则获得锁,如果当前线程被中断则出现异常。</span></span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//注意事项：该处不能放入try中，不然当程序执行到finally处，将产生IllegalMonitorStateException 异常！！！</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 这里配对释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="lockInterruptibly和lock的区别"><a href="#lockInterruptibly和lock的区别" class="headerlink" title="lockInterruptibly和lock的区别"></a>lockInterruptibly和lock的区别</h4><blockquote>
<pre><code>lock.lockInterruptibly()：如果当前线程未被中断则获得锁,如果当前线程被中断则出现异常；
lock.lock()：即使调用了线程的interrupt()方法,也没有真正的中断线程，只是会产生中断异常，依然获取锁定</code></pre></blockquote>
<h3 id="awaitNanos-long-nanosTimeout"><a href="#awaitNanos-long-nanosTimeout" class="headerlink" title="awaitNanos(long nanosTimeout)"></a>awaitNanos(long nanosTimeout)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">long</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">//等待截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="comment">//返回剩余等待时间</span></span><br><span class="line">    <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="enqueue-E-x"><a href="#enqueue-E-x" class="headerlink" title="enqueue(E x)"></a>enqueue(E x)</h3><p>添加进入队列，通过源码可以看到，这里其实是数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="put-E-e"><a href="#put-E-e" class="headerlink" title="put(E e)"></a>put(E e)</h2><p>和offer方法类似，不同之处在于没有返回值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="poll-long-timeout-TimeUnit-unit"><a href="#poll-long-timeout-TimeUnit-unit" class="headerlink" title="poll(long timeout, TimeUnit unit)"></a>poll(long timeout, TimeUnit unit)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="itemAt-int-i"><a href="#itemAt-int-i" class="headerlink" title="itemAt(int i)"></a>itemAt(int i)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue()"></a>dequeue()</h3><p>出队操作，元素置空，并返回出队元素；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="elementDequeued"><a href="#elementDequeued" class="headerlink" title="elementDequeued()"></a>elementDequeued()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elementDequeued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        queueIsEmpty();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (takeIndex == <span class="number">0</span>)</span><br><span class="line">        takeIndexWrapped();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="queueIsEmpty"><a href="#queueIsEmpty" class="headerlink" title="queueIsEmpty()"></a>queueIsEmpty()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueIsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">        Itr it = p.get();</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.clear();</span><br><span class="line">            it.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    itrs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared state for currently active iterators, or null if there</span></span><br><span class="line"><span class="comment"> * are known not to be any.  Allows queue operations to update</span></span><br><span class="line"><span class="comment"> * iterator state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<h3 id="takeIndexWrapped"><a href="#takeIndexWrapped" class="headerlink" title="takeIndexWrapped()"></a>takeIndexWrapped()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">if</span> (isDetached())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (itrs.cycles - prevCycles &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// All the elements that existed at the time of the last</span></span><br><span class="line">        <span class="comment">// operation are gone, so abandon further iteration.</span></span><br><span class="line">        shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            takeIndex = putIndex;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.queueIsEmpty();</span><br><span class="line">            <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="removedAt-int-removedIndex"><a href="#removedAt-int-removedIndex" class="headerlink" title="removedAt(int removedIndex)"></a>removedAt(int removedIndex)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removedAt</span><span class="params">(<span class="keyword">int</span> removedIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="keyword">if</span> (isDetached())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">    <span class="keyword">int</span> cycleDiff = cycles - prevCycles;</span><br><span class="line">    <span class="keyword">if</span> (removedIndex &lt; takeIndex)</span><br><span class="line">        cycleDiff++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> removedDistance =</span><br><span class="line">        (cycleDiff * len) + (removedIndex - prevTakeIndex);</span><br><span class="line">    <span class="comment">// assert removedDistance &gt;= 0;</span></span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">    <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = distance(cursor, prevTakeIndex, len);</span><br><span class="line">        <span class="keyword">if</span> (x == removedDistance) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor == putIndex)</span><br><span class="line">                <span class="keyword">this</span>.cursor = cursor = NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance) &#123;</span><br><span class="line">            <span class="comment">// assert cursor != prevTakeIndex;</span></span><br><span class="line">            <span class="keyword">this</span>.cursor = cursor = dec(cursor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = distance(lastRet, prevTakeIndex, len);</span><br><span class="line">        <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">            <span class="keyword">this</span>.lastRet = lastRet = REMOVED;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">            <span class="keyword">this</span>.lastRet = lastRet = dec(lastRet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">    <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = distance(nextIndex, prevTakeIndex, len);</span><br><span class="line">        <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">            <span class="keyword">this</span>.nextIndex = nextIndex = REMOVED;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">            <span class="keyword">this</span>.nextIndex = nextIndex = dec(nextIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prevTakeIndex = DETACHED;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ArrayBlockingQueue的迭代器"><a href="#ArrayBlockingQueue的迭代器" class="headerlink" title="ArrayBlockingQueue的迭代器"></a>ArrayBlockingQueue的迭代器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Iterator for ArrayBlockingQueue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * To maintain weak consistency with respect to puts and takes, we</span></span><br><span class="line"><span class="comment">     * read ahead one slot, so as to not report hasNext true but then</span></span><br><span class="line"><span class="comment">     * not have an element to return.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We switch into "detached" mode (allowing prompt unlinking from</span></span><br><span class="line"><span class="comment">     * itrs without help from the GC) when all indices are negative, or</span></span><br><span class="line"><span class="comment">     * when hasNext returns false for the first time.  This allows the</span></span><br><span class="line"><span class="comment">     * iterator to track concurrent updates completely accurately,</span></span><br><span class="line"><span class="comment">     * except for the corner case of the user calling Iterator.remove()</span></span><br><span class="line"><span class="comment">     * after hasNext() returned false.  Even in this case, we ensure</span></span><br><span class="line"><span class="comment">     * that we don't remove the wrong element by keeping track of the</span></span><br><span class="line"><span class="comment">     * expected element to remove, in lastItem.  Yes, we may fail to</span></span><br><span class="line"><span class="comment">     * remove lastItem from the queue if it moved due to an interleaved</span></span><br><span class="line"><span class="comment">     * interior remove while in detached mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** Index to look for new nextItem; NONE at end */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Element to be returned by next call to next(); null if none */</span></span><br><span class="line">        <span class="keyword">private</span> E nextItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Index of nextItem; NONE if none, REMOVED if removed elsewhere */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Last element returned; null if none or not detached. */</span></span><br><span class="line">        <span class="keyword">private</span> E lastItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Index of lastItem, NONE if none, REMOVED if removed elsewhere */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lastRet;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Previous value of takeIndex, or DETACHED when detached */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> prevTakeIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Previous value of iters.cycles */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> prevCycles;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Special index value indicating "not available" or "undefined" */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Special index value indicating "removed elsewhere", that is,</span></span><br><span class="line"><span class="comment">         * removed by some operation other than a call to this.remove().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVED = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Special value for prevTakeIndex indicating "detached mode" */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DETACHED = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            lastRet = NONE;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// assert itrs == null;</span></span><br><span class="line">                    cursor = NONE;</span><br><span class="line">                    nextIndex = NONE;</span><br><span class="line">                    prevTakeIndex = DETACHED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">                    prevTakeIndex = takeIndex;</span><br><span class="line">                    nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">                    cursor = incCursor(takeIndex);</span><br><span class="line">                    <span class="keyword">if</span> (itrs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        itrs = <span class="keyword">new</span> Itrs(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        itrs.register(<span class="keyword">this</span>); <span class="comment">// in this order</span></span><br><span class="line">                        itrs.doSomeSweeping(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    prevCycles = itrs.cycles;</span><br><span class="line">                    <span class="comment">// assert takeIndex &gt;= 0;</span></span><br><span class="line">                    <span class="comment">// assert prevTakeIndex == takeIndex;</span></span><br><span class="line">                    <span class="comment">// assert nextIndex &gt;= 0;</span></span><br><span class="line">                    <span class="comment">// assert nextItem != null;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isDetached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">return</span> prevTakeIndex &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incCursor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (++index == items.length)</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (index == putIndex)</span><br><span class="line">                index = NONE;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if index is invalidated by the given number of</span></span><br><span class="line"><span class="comment">         * dequeues, starting from prevTakeIndex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">invalidated</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> prevTakeIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">long</span> dequeues, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> distance = index - prevTakeIndex;</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                distance += length;</span><br><span class="line">            <span class="keyword">return</span> dequeues &gt; distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adjusts indices to incorporate all dequeues since the last</span></span><br><span class="line"><span class="comment">         * operation on this iterator.  Call only from iterating thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incorporateDequeues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="comment">// assert itrs != null;</span></span><br><span class="line">            <span class="comment">// assert !isDetached();</span></span><br><span class="line">            <span class="comment">// assert count &gt; 0;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cycles != prevCycles || takeIndex != prevTakeIndex) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">                <span class="comment">// how far takeIndex has advanced since the previous</span></span><br><span class="line">                <span class="comment">// operation of this iterator</span></span><br><span class="line">                <span class="keyword">long</span> dequeues = (cycles - prevCycles) * len</span><br><span class="line">                    + (takeIndex - prevTakeIndex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check indices for invalidation</span></span><br><span class="line">                <span class="keyword">if</span> (invalidated(lastRet, prevTakeIndex, dequeues, len))</span><br><span class="line">                    lastRet = REMOVED;</span><br><span class="line">                <span class="keyword">if</span> (invalidated(nextIndex, prevTakeIndex, dequeues, len))</span><br><span class="line">                    nextIndex = REMOVED;</span><br><span class="line">                <span class="keyword">if</span> (invalidated(cursor, prevTakeIndex, dequeues, len))</span><br><span class="line">                    cursor = takeIndex;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    detach();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.prevCycles = cycles;</span><br><span class="line">                    <span class="keyword">this</span>.prevTakeIndex = takeIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called when itrs should stop tracking this iterator, either</span></span><br><span class="line"><span class="comment">         * because there are no more indices to update (cursor &lt; 0 &amp;&amp;</span></span><br><span class="line"><span class="comment">         * nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) or as a special exception, when</span></span><br><span class="line"><span class="comment">         * lastRet &gt;= 0, because hasNext() is about to return false for the</span></span><br><span class="line"><span class="comment">         * first time.  Call only from iterating thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Switch to detached mode</span></span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="comment">// assert cursor == NONE;</span></span><br><span class="line">            <span class="comment">// assert nextIndex &lt; 0;</span></span><br><span class="line">            <span class="comment">// assert lastRet &lt; 0 || nextItem == null;</span></span><br><span class="line">            <span class="comment">// assert lastRet &lt; 0 ^ lastItem != null;</span></span><br><span class="line">            <span class="keyword">if</span> (prevTakeIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// assert itrs != null;</span></span><br><span class="line">                prevTakeIndex = DETACHED;</span><br><span class="line">                <span class="comment">// try to unlink from itrs (but not too hard)</span></span><br><span class="line">                itrs.doSomeSweeping(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * For performance reasons, we would like not to acquire a lock in</span></span><br><span class="line"><span class="comment">         * hasNext in the common case.  To allow for this, we only access</span></span><br><span class="line"><span class="comment">         * fields (i.e. nextItem) that are not modified by update operations</span></span><br><span class="line"><span class="comment">         * triggered by queue modifications.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">if</span> (nextItem != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            noNext();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">noNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// assert cursor == NONE;</span></span><br><span class="line">                <span class="comment">// assert nextIndex == NONE;</span></span><br><span class="line">                <span class="keyword">if</span> (!isDetached()) &#123;</span><br><span class="line">                    <span class="comment">// assert lastRet &gt;= 0;</span></span><br><span class="line">                    incorporateDequeues(); <span class="comment">// might update lastRet</span></span><br><span class="line">                    <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        lastItem = itemAt(lastRet);</span><br><span class="line">                        <span class="comment">// assert lastItem != null;</span></span><br><span class="line">                        detach();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// assert isDetached();</span></span><br><span class="line">                <span class="comment">// assert lastRet &lt; 0 ^ lastItem != null;</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">final</span> E x = nextItem;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                    incorporateDequeues();</span><br><span class="line">                <span class="comment">// assert nextIndex != NONE;</span></span><br><span class="line">                <span class="comment">// assert lastItem == null;</span></span><br><span class="line">                lastRet = nextIndex;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">                <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    nextItem = itemAt(nextIndex = cursor);</span><br><span class="line">                    <span class="comment">// assert nextItem != null;</span></span><br><span class="line">                    <span class="keyword">this</span>.cursor = incCursor(cursor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextIndex = NONE;</span><br><span class="line">                    nextItem = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 0;</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                    incorporateDequeues(); <span class="comment">// might update lastRet or detach</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">                <span class="keyword">this</span>.lastRet = NONE;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isDetached())</span><br><span class="line">                        removeAt(lastRet);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> E lastItem = <span class="keyword">this</span>.lastItem;</span><br><span class="line">                        <span class="comment">// assert lastItem != null;</span></span><br><span class="line">                        <span class="keyword">this</span>.lastItem = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (itemAt(lastRet) == lastItem)</span><br><span class="line">                            removeAt(lastRet);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastRet == NONE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                <span class="comment">// else lastRet == REMOVED and the last returned element was</span></span><br><span class="line">                <span class="comment">// previously asynchronously removed via an operation other</span></span><br><span class="line">                <span class="comment">// than this.remove(), so nothing to do.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span>)</span><br><span class="line">                    detach();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="comment">// assert lastRet == NONE;</span></span><br><span class="line">                <span class="comment">// assert lastItem == null;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called to notify the iterator that the queue is empty, or that it</span></span><br><span class="line"><span class="comment">         * has fallen hopelessly behind, so that it should abandon any</span></span><br><span class="line"><span class="comment">         * further iteration, except possibly to return one more element</span></span><br><span class="line"><span class="comment">         * from next(), as promised by returning true from hasNext().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            cursor = NONE;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>)</span><br><span class="line">                nextIndex = REMOVED;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                lastRet = REMOVED;</span><br><span class="line">                lastItem = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prevTakeIndex = DETACHED;</span><br><span class="line">            <span class="comment">// Don't set nextItem to null because we must continue to be</span></span><br><span class="line">            <span class="comment">// able to return it on next().</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Caller will unlink from itrs when convenient.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> prevTakeIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> distance = index - prevTakeIndex;</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                distance += length;</span><br><span class="line">            <span class="keyword">return</span> distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called whenever an interior remove (not at takeIndex) occurred.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if this iterator should be unlinked from itrs</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">removedAt</span><span class="params">(<span class="keyword">int</span> removedIndex)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (isDetached())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cycles = itrs.cycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevCycles = <span class="keyword">this</span>.prevCycles;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevTakeIndex = <span class="keyword">this</span>.prevTakeIndex;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> len = items.length;</span><br><span class="line">            <span class="keyword">int</span> cycleDiff = cycles - prevCycles;</span><br><span class="line">            <span class="keyword">if</span> (removedIndex &lt; takeIndex)</span><br><span class="line">                cycleDiff++;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> removedDistance =</span><br><span class="line">                (cycleDiff * len) + (removedIndex - prevTakeIndex);</span><br><span class="line">            <span class="comment">// assert removedDistance &gt;= 0;</span></span><br><span class="line">            <span class="keyword">int</span> cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">            <span class="keyword">if</span> (cursor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(cursor, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor == putIndex)</span><br><span class="line">                        <span class="keyword">this</span>.cursor = cursor = NONE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance) &#123;</span><br><span class="line">                    <span class="comment">// assert cursor != prevTakeIndex;</span></span><br><span class="line">                    <span class="keyword">this</span>.cursor = cursor = dec(cursor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lastRet = <span class="keyword">this</span>.lastRet;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(lastRet, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.lastRet = lastRet = REMOVED;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.lastRet = lastRet = dec(lastRet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = distance(nextIndex, prevTakeIndex, len);</span><br><span class="line">                <span class="keyword">if</span> (x == removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.nextIndex = nextIndex = REMOVED;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; removedDistance)</span><br><span class="line">                    <span class="keyword">this</span>.nextIndex = nextIndex = dec(nextIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cursor &lt; <span class="number">0</span> &amp;&amp; nextIndex &lt; <span class="number">0</span> &amp;&amp; lastRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.prevTakeIndex = DETACHED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called whenever takeIndex wraps around to zero.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if this iterator should be unlinked from itrs</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">            <span class="keyword">if</span> (isDetached())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs.cycles - prevCycles &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// All the elements that existed at the time of the last</span></span><br><span class="line">                <span class="comment">// operation are gone, so abandon further iteration.</span></span><br><span class="line">                shutdown();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         /** Uncomment for debugging. */</span></span><br><span class="line"><span class="comment">//         public String toString() &#123;</span></span><br><span class="line"><span class="comment">//             return ("cursor=" + cursor + " " +</span></span><br><span class="line"><span class="comment">//                     "nextIndex=" + nextIndex + " " +</span></span><br><span class="line"><span class="comment">//                     "lastRet=" + lastRet + " " +</span></span><br><span class="line"><span class="comment">//                     "nextItem=" + nextItem + " " +</span></span><br><span class="line"><span class="comment">//                     "lastItem=" + lastItem + " " +</span></span><br><span class="line"><span class="comment">//                     "prevCycles=" + prevCycles + " " +</span></span><br><span class="line"><span class="comment">//                     "prevTakeIndex=" + prevTakeIndex + " " +</span></span><br><span class="line"><span class="comment">//                     "size()=" + size() + " " +</span></span><br><span class="line"><span class="comment">//                     "remainingCapacity()=" + remainingCapacity());</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ArrayBlockingQueue是一个数据结构为数组的阻塞队列，由ReentrantLock来实现线程安全，内部操作</p>
<p>由Condition的await和signal来实现等待唤醒的功能。有两种创建方式，可指定是否为公平队列和非公平队列；</p>
<ul>
<li>poll方法移除头部元素并返回，可延迟；</li>
<li>take等待到有元素为止；</li>
<li>peek只是返回头部元素，不移除；</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具类的使用</title>
    <url>/article/22df6896/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常见的并发工具类有这几个：CountDownLatch，CyclicBarrier，Semaphore。除此之外，还有一个不常用的线程同步器类Exchanger。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个同步计数器，当计数器等于0时，开始触发。</p>
<p>应用场景：</p>
<ul>
<li>让多个线程同时阻塞在某一位置， 等待信号到来，再同时继续执行，模拟并发场景；</li>
<li>让单个线程等待，合并多个线程结果；</li>
</ul>
<p>例子1：</p>
<p><img src="image-20210212152635201.png" alt="image-20210212152635201"></p>
<p>输出</p>
<p><img src="image-20210212152709098.png" alt="image-20210212152709098"></p>
<p>例子2:</p>
<p><img src="image-20210212153137792.png" alt="image-20210212153137792"></p>
<p>输出：</p>
<p><img src="image-20210212153211891.png" alt="image-20210212153211891"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>从countDown的源码中我们可以看到，CountDownLatch内部使用了共享模式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中创建了Sync实例;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync继承于AbstractQueuedSynchronizer，在构造方法中将计数器 通过setState方法设置下去了，最终给到了state变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch有个注意事项，当计数器减到0后，便不可以再次使用，需要再次new一个CountDownLatch实例对象。若要强制使用，则需要修改源码，将state值进行重置。此外，有另一个类也实现了CountDownLatch类似的功能，并且是可以重用，那就是CyclicBarrier。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。</p>
<p>例子：</p>
<p><img src="image-20210212160846010.png" alt="image-20210212160846010"></p>
<p>输出：</p>
<p><img src="image-20210212160910543.png" alt="image-20210212160910543"></p>
<p>通过例子，可以看出，CyclicBarrier的效果是和CountDownLatch一致的。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行wait操作时，会将count值进行自减一次，当减到0时，进行触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察其构造函数，可以发现，barrierAction是一个runnable对象，最终在触发的时候被调用了run方法，并没有交给子线程去做，说明还是在主线程中做的事情。</p>
<p>通过观察，我们发现在触发后执行了nextGeneration()方法，一探究竟，发现count值被复原了，这就是为什么CyclicBarrier可以重用的原因了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了CyclicBarrier之外，还有一个和CyclicBarrier类似，且计数可变，那就是Phaser，后面介绍。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 信号量，用于控制在一段时间内，可并发访问执行的线程数量。控制访问特定资源的线程数目，底层依赖AQS的State。Semaphore 在计数器不为 0 的时候对线程就放行，当为0时，所有请求将被阻塞。</p>
<p>Semaphore 有两种模式，<strong>公平模式</strong> 和 <strong>非公平模式</strong> ，默认是非公平模式。</p>
<ul>
<li>公平模式就是调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li>非公平模式是抢占式的；</li>
</ul>
<p>Semaphore的应用场景</p>
<p>可以用来做对公共资源的流量限制，如数据库连接。</p>
<p>释放公共资源许可的时候，有两种方法，一个是release，直接释放；另一个是reducePermits，释放并减少总的许可数量。</p>
<p>例子：</p>
<p><img src="image-20210212163929797.png" alt="image-20210212163929797"></p>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>默认采用非公平锁；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类Sync继承AbstractQueuedSynchronizer；setState和getState对许可数进行设置和访问；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<h3 id="reducePermits方法"><a href="#reducePermits方法" class="headerlink" title="reducePermits方法"></a>reducePermits方法</h3><p>reducePermits可以动态控制总的许可证数量；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p>
<p>想要两个线程之间进行数据交换，必然存在一个交换的时间点，在代码中用exchange来标记交互数据的位置。当两个线程均执行到exchange点时，便开启线程间数据的交换。“交换”二字也客观说明了执行该动作的是至少是两个线程，成对出现。若一个线程到达交换的时间点，而另一个线程并未到达，则该线程进行等待另一个线程。</p>
<p>其应用场景主要有：遗传算法、多线程数据校对等。</p>
<p>例子：</p>
<p><img src="image-20210212041536863.png" alt="image-20210212041536863"></p>
<p>输出：</p>
<p><img src="image-20210212041847191.png" alt="image-20210212041847191"></p>
<p>注意事项，在多个线程中（大于两个）使用同一个exchange，导致的结果随机选择到达交换时间点的线程进行信息交换，主要影响因素是CPU的线程调度；</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a>exchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x;</span><br><span class="line">    <span class="keyword">long</span> ns = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">         (v = slotExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() ||</span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (v == TIMED_OUT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slotExchange方法"><a href="#slotExchange方法" class="headerlink" title="slotExchange方法"></a>slotExchange方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;</span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个线程到达交换时间点后，进行自选操作，等待另一个线程进行值交换；如果等待时间超时了，那么抛出超时的中断异常。</p>
<p>总之，每个工具类都有自己的优势和劣势，在实际开发场景中，还应根据它们的优缺点进行合适的选择。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
        <tag>Semaphore</tag>
        <tag>Exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>协程详解</title>
    <url>/article/c47eb885/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><code>kotlinx.coroutines</code> 是由 JetBrains 开发的功能丰富的协程库。它涵盖了的很多启用高级协程的原语，包括 <code>launch</code>、 <code>async</code> 等等。</p>
<p>本质上，协程是轻量级的线程。 它们在某些 <strong>CoroutineScope</strong>上下文中与 <strong>launch</strong> <em>协程构建器</em> 一起启动。</p>
<p>当我们在 <strong>GlobalScope</strong> 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。</p>
<p> <strong>delay</strong>是一个特殊的 <strong><em>挂起函数</em></strong> ，它不会造成线程阻塞，但是会 <strong><em>挂起</em></strong> 协程，并且只能在协程中使用。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul>
<li><em>非阻塞的</em> <code>delay(……)</code> </li>
<li><em>阻塞的</em> <code>Thread.sleep(……)</code></li>
<li><em>阻塞的</em>runBlocking{..delay(….)..}  </li>
</ul>
<p>注意： runBlocking会阻塞主线程，直到内部执行完成</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// 开始执行主协程</span></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// 在后台启动一个新的协程并继续，这与局部启动（launch &#123;&#125;）不同</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 主协程在这里会立即执行</span></span><br><span class="line">    delay(<span class="number">2000L</span>)      <span class="comment">// 延迟 2 秒来保证 JVM 存活,或者使用 job.join() </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>挂起函数单元测试</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testMySuspendingFunction</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里我们可以使用任何喜欢的断言风格来使用挂起函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h3><ul>
<li>runBlocking 方法会阻塞当前线程来等待；</li>
<li>coroutineScope 只是挂起，会释放底层线程用于其他用途。</li>
</ul>
<p>runBlocking 是常规函数，而 coroutineScope 是挂起函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">"Task from runBlocking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; <span class="comment">// 创建一个协程作用域</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>) </span><br><span class="line">            println(<span class="string">"Task from nested launch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">"Task from coroutine scope"</span>) <span class="comment">// 这一行会在内嵌 launch 之前输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"Coroutine scope is over"</span>) <span class="comment">// 这一行在内嵌 launch 执行完毕后才输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Task <span class="keyword">from</span> coroutine scope</span><br><span class="line">Task <span class="keyword">from</span> runBlocking</span><br><span class="line">Task <span class="keyword">from</span> nested launch</span><br><span class="line">Coroutine scope <span class="keyword">is</span> over</span><br></pre></td></tr></table></figure>



<h3 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是你的第一个挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hello,</span></span><br><span class="line">World!</span><br></pre></td></tr></table></figure>

<p>注意：在 GlobalScope 中启动的活动协程并不会使进程保活。它们就像守护线程。</p>
<h2 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"job: I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">    println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">    job.cancel() <span class="comment">// 取消该作业</span></span><br><span class="line">    job.join() <span class="comment">// 等待作业执行结束；可以用cancelAndJoin 取代上面两行</span></span><br><span class="line">    println(<span class="string">"main: Now I can quit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">0</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">1</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">2</span> <span class="string">...</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">I'm</span> <span class="string">tired</span> <span class="string">of</span> <span class="string">waiting!</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">Now</span> <span class="string">I</span> <span class="string">can</span> <span class="string">quit.</span></span><br></pre></td></tr></table></figure>

<p>如果协程正在执行计算任务，并且没有检查取消的话，那么它是不能被取消的</p>
<p>有两种方法来使执行计算的代码可以被取消。第一种方法是定期调用挂起函数来检查取消。对于这种目的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html" target="_blank" rel="noopener">yield</a> 是一个好的选择。 另一种方法是显式的检查取消状态。</p>
<p>isActive 是一个可以被使用在 CoroutineScope 中的扩展属性。</p>
<h3 id="运行不能取消的代码块"><a href="#运行不能取消的代码块" class="headerlink" title="运行不能取消的代码块"></a>运行不能取消的代码块</h3><p>所有良好的关闭操作（关闭一个文件、取消一个作业、或是关闭任何一种通信通道）通常都是非阻塞的，并且不会调用任何挂起函数。</p>
<p>当你需要挂起一个被取消的协程，你可以将相应的代码包装在 withContext(NonCancellable) {……} 中，并使用 withContext 函数以及 NonCancellable 上下文</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"job: I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        withContext(NonCancellable) &#123;</span><br><span class="line">            println(<span class="string">"job: I'm running finally"</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">"job: And I've just delayed for 1 sec because I'm non-cancellable"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">job.cancelAndJoin() <span class="comment">// 取消该作业并等待它结束</span></span><br><span class="line">println(<span class="string">"main: Now I can quit."</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">0</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">1</span> <span class="string">...</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">2</span> <span class="string">...</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">I'm</span> <span class="string">tired</span> <span class="string">of</span> <span class="string">waiting!</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">I'm</span> <span class="string">running</span> <span class="string">finally</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">And</span> <span class="string">I've</span> <span class="string">just</span> <span class="string">delayed</span> <span class="string">for</span> <span class="number">1</span> <span class="string">sec</span> <span class="string">because</span> <span class="string">I'm</span> <span class="string">non-cancellable</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">Now</span> <span class="string">I</span> <span class="string">can</span> <span class="string">quit.</span></span><br></pre></td></tr></table></figure>



<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>例子1</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">        println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">        delay(<span class="number">500L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"Done"</span> <span class="comment">// 在它运行得到结果之前取消它</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Result is <span class="variable">$result</span>"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">0</span> <span class="string">...</span></span><br><span class="line"><span class="string">I'm</span> <span class="string">sleeping</span> <span class="number">1</span> <span class="string">...</span></span><br><span class="line"><span class="string">Result</span> <span class="string">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> acquired = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123; acquired++ &#125; <span class="comment">// Acquire the resource</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123; acquired-- &#125; <span class="comment">// Release the resource</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">100_000</span>) &#123; <span class="comment">// Launch 100K coroutines</span></span><br><span class="line">            launch &#123; </span><br><span class="line">                <span class="keyword">var</span> resource: Resource? = <span class="literal">null</span> <span class="comment">// Not acquired yet</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    withTimeout(<span class="number">60</span>) &#123; <span class="comment">// Timeout of 60 ms</span></span><br><span class="line">                        delay(<span class="number">50</span>) <span class="comment">// Delay for 50 ms</span></span><br><span class="line">                        resource = Resource() <span class="comment">// Store a resource to the variable if acquired      </span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// We can do something else with the resource here</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                    resource?.close() <span class="comment">// Release the resource if it was acquired</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Outside of runBlocking all coroutines have completed</span></span><br><span class="line">    println(acquired) <span class="comment">// Print the number of resources still acquired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：该例子是安全的，因为都在同一个线程中。</p>
<h3 id="async-并发"><a href="#async-并发" class="headerlink" title="async 并发"></a>async 并发</h3><p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>
<p>请注意，使用协程进行并发总是显式的。</p>
<p>async 可以通过将 start 参数设置为 CoroutineStart.LAZY 而变为惰性的。 在这个模式下，只有结果通过 await 获取的时候协程才会启动，或者在 Job 的 start 函数调用的时候。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        <span class="comment">// 执行一些计算</span></span><br><span class="line">        one.start() <span class="comment">// 启动第一个</span></span><br><span class="line">        two.start() <span class="comment">// 启动第二个</span></span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里也做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="协程上下文与调度器"><a href="#协程上下文与调度器" class="headerlink" title="协程上下文与调度器"></a>协程上下文与调度器</h2><p>所有的协程构建器诸如 launch 和 async 接收一个可选的 CoroutineContext 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。</p>
<p>newSingleThreadContext 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。</p>
<p><code>launch(Dispatchers.Default) { …… }</code> 与 <code>GlobalScope.launch { …… }</code> 使用相同的调度器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch &#123; <span class="comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class="line">    println(<span class="string">"main runBlocking      : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">launch(Dispatchers.Unconfined) &#123; <span class="comment">// 不受限的——将工作在主线程中</span></span><br><span class="line">    println(<span class="string">"Unconfined            : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">launch(Dispatchers.Default) &#123; <span class="comment">// 将会获取默认调度器</span></span><br><span class="line">    println(<span class="string">"Default               : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">launch(newSingleThreadContext(<span class="string">"MyOwnThread"</span>)) &#123; <span class="comment">// 将使它获得一个新的线程</span></span><br><span class="line">    println(<span class="string">"newSingleThreadContext: I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Unconfined            </span>: I'm working in thread main <span class="variable">@coroutine</span><span class="number">#3</span></span><br><span class="line"><span class="attribute">Default               </span>: I'm working in thread DefaultDispatcher-worker-<span class="number">1</span> <span class="variable">@coroutine</span><span class="number">#4</span></span><br><span class="line">main <span class="attribute">runBlocking      </span>: I'm working in thread main <span class="variable">@coroutine</span><span class="number">#2</span></span><br><span class="line"><span class="attribute">newSingleThreadContext</span>: I'm working in thread MyOwnThread <span class="variable">@coroutine</span><span class="number">#5</span></span><br></pre></td></tr></table></figure>



<h3 id="非受限调度器-vs-受限调度器"><a href="#非受限调度器-vs-受限调度器" class="headerlink" title="非受限调度器 vs 受限调度器"></a>非受限调度器 vs 受限调度器</h3><p>Dispatchers.Unconfined 协程调度器在调用它的线程启动了一个协程，但它仅仅只是运行到第一个挂起点。挂起后，它恢复线程中的协程，而这完全由被调用的挂起函数来决定。非受限的调度器非常适用于执行不消耗 CPU 时间的任务，以及不更新局限于特定线程的任何共享数据（如UI）的协程。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Zygote详解</title>
    <url>/article/8b3b35/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p>Zygote进程通过克隆的方式创建子进程，使用fork方法，会从父进程进行资源的继承；并且在启动的时候会创建 Java ART虚拟机，加载java进程所需的所有系统资源。</p>
<h2 id="App-main-gt-main"><a href="#App-main-gt-main" class="headerlink" title="App_main -&gt; main()"></a>App_main -&gt; main()</h2><p>App_main.cpp    cmds\App_process</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!LOG_NDEBUG) &#123;</span><br><span class="line">      String8 argv_String;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        argv_String.append(<span class="string">"\""</span>);</span><br><span class="line">        argv_String.append(argv[i]);</span><br><span class="line">        argv_String.append(<span class="string">"\" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ALOGV(<span class="string">"app_process main with argv: %s"</span>, argv_String.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// argv[0] = "/system/bin/app_process"</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments；</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* spaced_commands[] = &#123; <span class="string">"-cp"</span>, <span class="string">"-classpath"</span> &#125;;</span><br><span class="line">    <span class="comment">// Allow "spaced commands" to be succeeded by exactly 1 argument (regardless of -s).</span></span><br><span class="line">    <span class="keyword">bool</span> known_command = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (known_command == <span class="literal">true</span>) &#123;</span><br><span class="line">          runtime.addOption(strdup(argv[i]));</span><br><span class="line">          <span class="comment">// The static analyzer gets upset that we don't ever free the above</span></span><br><span class="line">          <span class="comment">// string. Since the allocation is from main, leaking it doesn't seem</span></span><br><span class="line">          <span class="comment">// problematic. NOLINTNEXTLINE</span></span><br><span class="line">          ALOGV(<span class="string">"app_process main add known option '%s'"</span>, argv[i]);</span><br><span class="line">          known_command = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">             j &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">sizeof</span>(spaced_commands) / <span class="keyword">sizeof</span>(spaced_commands[<span class="number">0</span>]));</span><br><span class="line">             ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], spaced_commands[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">            known_command = <span class="literal">true</span>;</span><br><span class="line">            ALOGV(<span class="string">"app_process main found known command '%s'"</span>, argv[i]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">        ALOGV(<span class="string">"app_process main add option '%s'"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zygote判断</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 不在zygote模式, 我们需要传递给RuntimeInit的唯一参数是应用程序参数。</span></span><br><span class="line">        <span class="comment">// 剩余的args传递给启动类main()。 在使用进程名称覆盖它们之前，对其进行复制。</span></span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!LOG_NDEBUG) &#123;</span><br><span class="line">          String8 restOfArgs;</span><br><span class="line">          <span class="keyword">char</span>* <span class="keyword">const</span>* argv_new = argv + i;</span><br><span class="line">          <span class="keyword">int</span> argc_new = argc - i;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; argc_new; ++k) &#123;</span><br><span class="line">            restOfArgs.append(<span class="string">"\""</span>);</span><br><span class="line">            restOfArgs.append(argv_new[k]);</span><br><span class="line">            restOfArgs.append(<span class="string">"\" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ALOGV(<span class="string">"Class name = %s, args = %s"</span>, className.<span class="built_in">string</span>(), restOfArgs.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在zygote模式</span></span><br><span class="line">        <span class="comment">// 创建 /data/dalvik-cache/ 目录</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        <span class="comment">// 获取支持的 abi 列表</span></span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 zygote 模式下，将所有剩余参数传递给 zygote 的 main() 方法。</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 设置进程名字</span></span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>App_main主要工作：</p>
<ol>
<li>创建了 ART对象，传入虚拟机所需的选项；</li>
<li>解析 <code>zygote</code> 启动参数；</li>
<li>调用 <code>runtime.start</code> 函数，根据启动 zygote 还是命令行（<code>className</code>），进入 <code>ZygoteInit</code> 或者 <code>RuntimeInit</code> 参数分支。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<blockquote>
<ul>
<li><code>app_process</code> 可使用命令行调用，启动一个 Java 类，并调用 <code>main</code> 方法；</li>
<li>argc：参数个数，argv[ ]：参数指针数组; </li>
<li><code>className</code>为空才在zygote模式下</li>
</ul>
</blockquote>
<h2 id="ZygoteInit开始"><a href="#ZygoteInit开始" class="headerlink" title="ZygoteInit开始"></a>ZygoteInit开始</h2><p>开机一般会打印这行日志</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">D</span> <span class="selector-tag">AndroidRuntime</span>: &gt;&gt;&gt;&gt;&gt;&gt; <span class="selector-tag">START</span> <span class="selector-tag">com</span><span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span><span class="selector-class">.ZygoteInit</span> <span class="selector-tag">uid</span> 0 &lt;&lt;&lt;&lt;&lt;&lt;</span><br></pre></td></tr></table></figure>

<p>如果遇到不能开机的情况，这行Log没有打开，极有可能是底层的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGD(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</span><br><span class="line">            className != <span class="literal">NULL</span> ? className : <span class="string">"(unknown)"</span>, getuid());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line">    <span class="comment">//这是否是主要的zygote，意味着zygote将要fork system server。</span></span><br><span class="line">    <span class="keyword">bool</span> primary_zygote = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 'startSystemServer == true' means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">            primary_zygote = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">"/system"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /system does not exist."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* artRootDir = getenv(<span class="string">"ANDROID_ART_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (artRootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"No ART directory specified with ANDROID_ART_ROOT environment variable."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* i18nRootDir = getenv(<span class="string">"ANDROID_I18N_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (i18nRootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"No runtime directory specified with ANDROID_I18N_ROOT environment variable."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* tzdataRootDir = getenv(<span class="string">"ANDROID_TZDATA_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (tzdataRootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"No tz data directory specified with ANDROID_TZDATA_ROOT environment variable."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></span><br><span class="line">    <span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//调用startVm开启虚拟机</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 调用startReg注册JNI方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 启动VM。 该线程成为VM的主线程，并将在虚拟机退出之前不返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>当启动一个Activity的时候，发现Activity所在进程没有被创建，就会调用这个API进程进行创建。Process.start()方法是阻塞操作，等待直到进程创建完成并返回相应的新进程pid，才完成该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(@NonNull <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, @Nullable <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @NonNull String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">boolean</span> isTopApp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          pkgDataInfoMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          whitelistedDataInfoMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">boolean</span> bindMountAppsData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">boolean</span> bindMountAppStorageDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @Nullable String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO (chriswailes): Is there a better place to check this value?</span></span><br><span class="line">        <span class="keyword">if</span> (fetchUsapPoolEnabledPropWithMinInterval()) &#123;</span><br><span class="line">            informZygotesOfUsapPoolStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="comment">/*startChildZygote=*/</span> <span class="keyword">false</span>,</span><br><span class="line">                    packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges,</span><br><span class="line">                    pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,</span><br><span class="line">                    bindMountAppStorageDirs, zygoteArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,</span><br><span class="line">                    <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="startViaZygote"><a href="#startViaZygote" class="headerlink" title="startViaZygote"></a>startViaZygote</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Starts a new process via the zygote mechanism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processClass Class name whose static main() to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> niceName 'nice' process name to appear in ps</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid a POSIX uid that the new process should setuid() to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gid a POSIX gid that the new process shuold setgid() to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gids null-ok; a list of supplementary group IDs that the</span></span><br><span class="line"><span class="comment">     * new process should setgroup() to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runtimeFlags Additional flags for the runtime.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetSdkVersion The target SDK version for the app.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seInfo null-ok SELinux information for the new process.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> abi the ABI the process should use.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instructionSet null-ok the instruction set to use.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appDataDir null-ok the data directory of the app.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startChildZygote Start a sub-zygote. This creates a new zygote process</span></span><br><span class="line"><span class="comment">     * that has its state cloned from this zygote process.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName null-ok the name of the package this process belongs to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zygotePolicyFlags Flags used to determine how to launch the application.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isTopApp Whether the process starts for high priority application.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> disabledCompatChanges a list of disabled compat changes for the process being started.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pkgDataInfoMap Map from related package names to private data directory volume UUID</span></span><br><span class="line"><span class="comment">     *                       and inode number.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> whitelistedDataInfoMap Map from allowlisted package names to private data directory</span></span><br><span class="line"><span class="comment">     *                       volume UUID and inode number.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bindMountAppsData whether zygote needs to mount CE and DE data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bindMountAppStorageDirs whether zygote needs to mount Android/obb and Android/data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extraArgs Additional arguments to supply to the zygote process.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> An object that describes the result of the attempt to start the process.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZygoteStartFailedEx if process start failed for any reason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(@NonNull <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @NonNull String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> isTopApp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              pkgDataInfoMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              whitelistedDataInfoMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> bindMountAppsData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> bindMountAppStorageDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      @Nullable String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-flags="</span> + runtimeFlags);</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-read"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-write"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_FULL) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-full"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-installer"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_LEGACY) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-legacy"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-pass-through"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-android-writable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(gids[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--invoke-with"</span>);</span><br><span class="line">            argsForZygote.add(invokeWith);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startChildZygote) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--start-child-zygote"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--package-name="</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isTopApp) &#123;</span><br><span class="line">            argsForZygote.add(Zygote.START_AS_TOP_APP_ARG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkgDataInfoMap != <span class="keyword">null</span> &amp;&amp; pkgDataInfoMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(Zygote.PKG_DATA_INFO_MAP);</span><br><span class="line">            sb.append(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : pkgDataInfoMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (started) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                started = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(entry.getKey());</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">                sb.append(entry.getValue().first);</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">                sb.append(entry.getValue().second);</span><br><span class="line">            &#125;</span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (whitelistedDataInfoMap != <span class="keyword">null</span> &amp;&amp; whitelistedDataInfoMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(Zygote.WHITELISTED_DATA_INFO_MAP);</span><br><span class="line">            sb.append(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : whitelistedDataInfoMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (started) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                started = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(entry.getKey());</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">                sb.append(entry.getValue().first);</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">                sb.append(entry.getValue().second);</span><br><span class="line">            &#125;</span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bindMountAppStorageDirs) &#123;</span><br><span class="line">            argsForZygote.add(Zygote.BIND_MOUNT_APP_STORAGE_DIRS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bindMountAppsData) &#123;</span><br><span class="line">            argsForZygote.add(Zygote.BIND_MOUNT_APP_DATA_DIRS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (disabledCompatChanges != <span class="keyword">null</span> &amp;&amp; disabledCompatChanges.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--disabled-compat-changes="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = disabledCompatChanges.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(disabledCompatChanges[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Collections.addAll(argsForZygote, extraArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="comment">// The USAP pool can not be used if the application will not use the systems graphics</span></span><br><span class="line">            <span class="comment">// driver.  If that driver is requested use the Zygote application start path.</span></span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                              zygotePolicyFlags,</span><br><span class="line">                                              argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="zygoteSendArgsAndGetResult"><a href="#zygoteSendArgsAndGetResult" class="headerlink" title="zygoteSendArgsAndGetResult"></a>zygoteSendArgsAndGetResult</h3><p>将参数列表发送到Zygote进程，这将<strong>启动一个新的子进程</strong>，并返回孩子的pid。</p>
<p>@如果流程由于任何原因启动失败，则抛出ZygoteStartFailedEx</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sends an argument list to the zygote process, which starts a new child</span></span><br><span class="line"><span class="comment">     * and returns the child's pid. Please note: the present implementation</span></span><br><span class="line"><span class="comment">     * replaces newlines in the argument list with spaces.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZygoteStartFailedEx if process start failed for any reason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, <span class="keyword">int</span> zygotePolicyFlags, @NonNull ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        <span class="comment">// Throw early if any of the arguments are malformed. This means we can</span></span><br><span class="line">        <span class="comment">// avoid writing a partial response to the zygote.</span></span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="comment">// Making two indexOf calls here is faster than running a manually fused loop due</span></span><br><span class="line">            <span class="comment">// to the fact that indexOf is a optimized intrinsic.</span></span><br><span class="line">            <span class="keyword">if</span> (arg.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Embedded newlines not allowed"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.indexOf(<span class="string">'\r'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Embedded carriage returns not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * See com.android.internal.os.ZygoteArguments.parseArgs()</span></span><br><span class="line"><span class="comment">         * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">         * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">         * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">         * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">         * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String msgStr = args.size() + <span class="string">"\n"</span> + String.join(<span class="string">"\n"</span>, args) + <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="comment">// If there was an IOException using the USAP pool we will log the error and</span></span><br><span class="line">                <span class="comment">// attempt to start the process through the Zygote.</span></span><br><span class="line">                Log.e(LOG_TAG, <span class="string">"IO Exception while communicating with USAP pool - "</span></span><br><span class="line">                        + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="attemptZygoteSendArgsAndGetResult"><a href="#attemptZygoteSendArgsAndGetResult" class="headerlink" title="attemptZygoteSendArgsAndGetResult"></a>attemptZygoteSendArgsAndGetResult</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">            <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">            zygoteWriter.write(msgStr);</span><br><span class="line">            zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">            <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">            <span class="comment">// upon.</span></span><br><span class="line">            Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">            result.pid = zygoteInputStream.readInt();</span><br><span class="line">            result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">"IO Exception while communicating with Zygote - "</span></span><br><span class="line">                    + ex.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="zygote-进程-main"><a href="#zygote-进程-main" class="headerlink" title="zygote 进程 main"></a>zygote 进程 main</h2><p>zygote 进程采用socket通信机制，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ **</span><br><span class="line">   *这是Zygote流程的入口点。 它创建Zygote服务器，加载资源，</span><br><span class="line">   *并处理与准备分支到应用程序的过程有关的其他任务。</span><br><span class="line">   *</span><br><span class="line">   *此过程以-<span class="number">20</span>的最佳值（最高优先级）开始。 所有流动的路径</span><br><span class="line">   *需要将新的进程设置为默认值或终止优先级</span><br><span class="line">   *在执行任何非系统代码之前。 本机端发生在SpecializeCommon中，</span><br><span class="line">   *在ZygoteInit.handleSystemServerProcess中更改Java语言优先级时，</span><br><span class="line">   * ZygoteConnection.handleChildProc和Zygote.usapMain。</span><br><span class="line">   *</span><br><span class="line">   * <span class="meta">@param</span> argv用于指定Zygote的配置的命令行参数。</span><br><span class="line">   * /</span><br><span class="line"> <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">     ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 标记zygote开始。 这样可以确保线程创建将引发错误。</span></span><br><span class="line">     ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Zygote 进入自己的进程组。</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Runnable caller;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 立即存储以供以后进行StatsLogging。</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isRuntimeRestarted = <span class="string">"1"</span>.equals(</span><br><span class="line">                 SystemProperties.get(<span class="string">"sys.boot_completed"</span>));</span><br><span class="line"></span><br><span class="line">         String bootTimeTag = Process.is64Bit() ? <span class="string">"Zygote64Timing"</span> : <span class="string">"Zygote32Timing"</span>;</span><br><span class="line">         TimingsTraceLog bootTimingsTraceLog = <span class="keyword">new</span> TimingsTraceLog(bootTimeTag,</span><br><span class="line">                 Trace.TRACE_TAG_DALVIK);</span><br><span class="line">         bootTimingsTraceLog.traceBegin(<span class="string">"ZygoteInit"</span>);</span><br><span class="line">         RuntimeInit.preForkInit();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">         String zygoteSocketName = <span class="string">"zygote"</span>;</span><br><span class="line">         String abiList = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//解析app_main.cpp传来的参数</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                 startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                 enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                 abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                 zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">         <span class="keyword">if</span> (!isRuntimeRestarted) &#123;</span><br><span class="line">             <span class="keyword">if</span> (isPrimaryZygote) &#123;</span><br><span class="line">                 FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,</span><br><span class="line">                         BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__ZYGOTE_INIT_START,</span><br><span class="line">                         startTime);</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zygoteSocketName.equals(Zygote.SECONDARY_SOCKET_NAME)) &#123;</span><br><span class="line">                 FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,</span><br><span class="line">                         BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SECONDARY_ZYGOTE_INIT_START,</span><br><span class="line">                         startTime);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (abiList == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No ABI list supplied."</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在某些配置中，我们避免过早预加载资源和类。</span></span><br><span class="line">         <span class="comment">// 在这种情况下，我们会在第一个fork之前预装东西。</span></span><br><span class="line">         <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">             bootTimingsTraceLog.traceBegin(<span class="string">"ZygotePreload"</span>);</span><br><span class="line">             EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                     SystemClock.uptimeMillis());</span><br><span class="line">             preload(bootTimingsTraceLog);</span><br><span class="line">             EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                     SystemClock.uptimeMillis());</span><br><span class="line">             bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 启动后进行初始gc清理</span></span><br><span class="line">         bootTimingsTraceLog.traceBegin(<span class="string">"PostZygoteInitGC"</span>);</span><br><span class="line">         gcAndFinalize();</span><br><span class="line">         bootTimingsTraceLog.traceEnd(); <span class="comment">// PostZygoteInitGC</span></span><br><span class="line"></span><br><span class="line">         bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygoteInit</span></span><br><span class="line"></span><br><span class="line">         Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">         ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//创建ZygoteServer</span></span><br><span class="line">         zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">             Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">             <span class="comment">// child (system_server) process.</span></span><br><span class="line">             <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 r.run();</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 启动一个死循环监听来自Client端的消息</span></span><br><span class="line">         caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">             zygoteServer.closeServerSocket();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 我们在子进程中，已经退出选择循环。 继续执行命令 </span></span><br><span class="line">     <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">         caller.run();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="attemptUsapSendArgsAndGetResult方法"><a href="#attemptUsapSendArgsAndGetResult方法" class="headerlink" title="attemptUsapSendArgsAndGetResult方法"></a>attemptUsapSendArgsAndGetResult方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">Process</span>.<span class="function">ProcessStartResult <span class="title">attemptUsapSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, <span class="keyword">String</span> msgStr)</span></span></span><br><span class="line">            throws ZygoteStartFailedEx, IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (LocalSocket usapSessionSocket = zygoteState.getUsapSessionSocket()) &#123;</span><br><span class="line">            <span class="keyword">final</span> BufferedWriter usapWriter =</span><br><span class="line">                    <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                            <span class="keyword">new</span> OutputStreamWriter(usapSessionSocket.getOutputStream()),</span><br><span class="line">                            Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">final</span> DataInputStream usapReader =</span><br><span class="line">                    <span class="keyword">new</span> DataInputStream(usapSessionSocket.getInputStream());</span><br><span class="line"></span><br><span class="line">            usapWriter.<span class="built_in">write</span>(msgStr);</span><br><span class="line">            usapWriter.<span class="built_in">flush</span>();</span><br><span class="line">            <span class="comment">//创建Process.ProcessStartResult用于存放fork进程的返回结果</span></span><br><span class="line">            <span class="built_in">Process</span>.ProcessStartResult result = <span class="keyword">new</span> <span class="built_in">Process</span>.ProcessStartResult();</span><br><span class="line">            result.pid = usapReader.readInt();</span><br><span class="line">            <span class="comment">// USAPs can't be used to spawn processes that need wrappers.</span></span><br><span class="line">            result.usingWrapper = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"USAP specialization failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="image-20210203235817212.png" alt="image-20210203235817212"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Zygote</tag>
      </tags>
  </entry>
  <entry>
    <title>DecorView介绍</title>
    <url>/article/603b68b6/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>DecorView</strong>: 该类继承自<strong>FrameLayout</strong>，实现了<strong>RootViewSurfaceTaker</strong>, <strong>WindowCallbacks</strong>接口。它是所有应用窗口的根View,PhoneWindow设置DecorView为应用窗口的根视图。</p>
<p><strong>PhoneWindow</strong>: 该类在setContentView时，帮我们创建了一个<strong>DecorView</strong>（父类为FrameLayout）窗口顶层视图</p>
<p><strong>ViewRootImpl</strong>: 是连接WindowManager与DecorView的纽带，View的整个绘制流程的三大步（measure、layout、draw）以及我们一些addView()的操作，都是通过ViewRootImpl完成的。</p>
<p><strong>WindowManager</strong>: 应用程序界面和窗口管理器</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Activity的的<strong>setContentView</strong>方法调用，首先进入installDecor方法，进行decorView的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里开始创建decorview</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>generateDecor</strong>方法为decorview的主要创建方法,参数为featureId，默认值为-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//decorview的主要创建方法</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>generateDecor</strong>方法主要是对decorview的上下文进行创建，当拿到context、featureId、phonewindow以及windowmanage的布局参数后，便开始真正的new DecorView 对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn't have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don't cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>DecorView</strong>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    DecorView(Context context, <span class="keyword">int</span> featureId, PhoneWindow window,</span><br><span class="line">            WindowManager.LayoutParams params) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        updateAvailableWidth();</span><br><span class="line"></span><br><span class="line">        setWindow(window);</span><br><span class="line"></span><br><span class="line">        updateLogTag(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>setWindow</strong>方法设置DecorView的mWindow变量，若当前上下文是DecorContext，也更新decorContext的mPhoneWindow值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">        mWindow = phoneWindow;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> DecorContext) &#123;</span><br><span class="line">            DecorContext decorContext = (DecorContext) context;</span><br><span class="line">            decorContext.setPhoneWindow(mWindow);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在<strong>DecorContext.java</strong>中,设置mPhoneWindow的值，同时从phoneWindow中获取上下文，取得context的弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPhoneWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">    mPhoneWindow = phoneWindow;</span><br><span class="line">    <span class="keyword">final</span> Context context = phoneWindow.getContext();</span><br><span class="line">    mContext = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">    mResources = context.getResources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="image-20210319102418129.png" alt="image-20210319102418129"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="View-提供的获取坐标方法"><a href="#View-提供的获取坐标方法" class="headerlink" title="View 提供的获取坐标方法"></a>View 提供的获取坐标方法</h3><p><strong>getTop</strong>： View 自身的顶边到父View顶边的距离</p>
<p><strong>getLeft</strong>： View 自身的左边到父View左边的距离</p>
<p><strong>getRight</strong>： View 自身的右边到父View左边的距离</p>
<p><strong>getBottom</strong>： View 自身的底边到父View上边的距离</p>
<h3 id="MotionEvent-提供的获取坐标方法"><a href="#MotionEvent-提供的获取坐标方法" class="headerlink" title="MotionEvent 提供的获取坐标方法"></a>MotionEvent 提供的获取坐标方法</h3><p><strong>getX</strong> : 触摸点到当前控件左边缘的距离</p>
<p><strong>getY</strong> : 触摸点当前控件顶边缘的距离</p>
<p><strong>getRawX</strong> : 触摸点屏幕左边缘的距离</p>
<p><strong>getRawY</strong> : 触摸点到屏幕顶边缘的距离</p>
<h3 id="MeasureSpec的三种类型"><a href="#MeasureSpec的三种类型" class="headerlink" title="MeasureSpec的三种类型"></a>MeasureSpec的三种类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MeasureSpecMode &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UNSPECIFIED</strong>:父级没有对子级施加任何约束。</p>
<p><strong>EXACTLY</strong>:父级已确定子级的确切大小</p>
<p><strong>AT_MOST</strong>:子级可以根据需要的大小而定，最大可以达到指定的大小。</p>
<h3 id="onFinishInflate-调用时机"><a href="#onFinishInflate-调用时机" class="headerlink" title="onFinishInflate 调用时机"></a>onFinishInflate 调用时机</h3><p>setContentView &gt; onFinishInflate &gt; view绘制流程（performMeasure、performLayout、performDraw）</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>DecorView</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/article/7cab1e06/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 二叉树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉搜索树 </span>&#123;</span><br><span class="line">    <span class="comment">//    是否有效的二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(Node node, <span class="keyword">int</span> minVal, <span class="keyword">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.data &lt;= minVal || node.data &gt;= maxVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, minVal, node.data)</span><br><span class="line">                &amp;&amp; isValidBST(node.right, node.data, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    打印二叉树每层节点;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeBFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                linkedList.add(node.data);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;res&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    之字形打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeBFS_zhi</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    linkedList.addLast(node.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    linkedList.addFirst(node.data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;res&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, Node root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height &gt;= list.size()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; temp = list.get(height);</span><br><span class="line">        temp.add(root.data);</span><br><span class="line">        dfs(list, root.left, height + <span class="number">1</span>);</span><br><span class="line">        dfs(list, root.right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    打印二叉树每层节点;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTreeDFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(list, root, <span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(data[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    任意方式创建二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">insertSearchTree</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.data) &#123;</span><br><span class="line">            root.left = insertSearchTree(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.data) &#123;</span><br><span class="line">            root.right = insertSearchTree(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    搜索二叉树遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchTree</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == temp.data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; temp.data) &#123;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础操作</title>
    <url>/article/bb06284f/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="二叉树基础操作"><a href="#二叉树基础操作" class="headerlink" title="二叉树基础操作"></a>二叉树基础操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 二叉树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉树基础操作 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">422</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">55</span>, <span class="number">64</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfsSearch</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; re : res) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(re.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height == res.size()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(height).add(node.data);</span><br><span class="line">        dfs(node.left, res, height + <span class="number">1</span>);</span><br><span class="line">        dfs(node.right, res, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfsSearch</span><span class="params">(Node tree)</span></span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= bfs(tree);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; re : res) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(re.toArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; bfs(Node root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node node= queue.poll();</span><br><span class="line">                <span class="keyword">assert</span> node != <span class="keyword">null</span>;</span><br><span class="line">                list.add(node.data);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            insert(root, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">insert</span><span class="params">(Node node, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data &lt;= node.data) &#123;</span><br><span class="line">            node.left= insert(node.left, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right= insert(node.right, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        printTree(node.left);</span><br><span class="line">        printTree(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=node.left;</span><br><span class="line">        node.left=node.right;</span><br><span class="line">        node.right=temp;</span><br><span class="line">        invert(node.left);</span><br><span class="line">        invert(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=searchMax(node.left);</span><br><span class="line">        <span class="keyword">int</span> right= searchMax(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(node.data,Math.max(left,right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDeep</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=maxDeep(node.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxDeep(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> balance(node)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">balance</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=balance(node.left);</span><br><span class="line">        <span class="keyword">int</span> right=balance(node.right);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>||right==-<span class="number">1</span>||Math.abs(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node tree = createTree(a2);</span><br><span class="line">        printTree(tree);</span><br><span class="line">        dfsSearch(tree);</span><br><span class="line">        bfsSearch(tree);</span><br><span class="line">        invert(tree);</span><br><span class="line">        bfsSearch(tree);</span><br><span class="line">        System.out.println(searchMax(tree));</span><br><span class="line">        System.out.println(maxDeep(tree));</span><br><span class="line">        System.out.println(isBalance(tree));</span><br><span class="line">        <span class="comment">//        System.out.println(Arrays.toString(qsort(arr, 0, arr.length - 1)));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树非递归遍历</title>
    <url>/article/1062d183/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历_非递归"></a>前序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 前序遍历<span class="title">_</span>非递归 </span>&#123;</span><br><span class="line">    <span class="comment">//    非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                list.add(root.data);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更简洁的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            list.add(node.data);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历_非递归"></a>中序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mid</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        list.add(node.data);</span><br><span class="line">        root=node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(<span class="keyword">new</span> List[] &#123;list&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历_非递归"></a>后序遍历_非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 后序遍历<span class="title">_</span>非递归 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(<span class="number">0</span>, root.data);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle命令</title>
    <url>/article/dda7bba2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="gradlew-命令详解"><a href="#gradlew-命令详解" class="headerlink" title="gradlew 命令详解"></a>gradlew 命令详解</h2><p>gradlew tasks –all：查看所有任务，包括缓存任务等；</p>
<p>gradlew clean：清除工程目录下的build文件夹；</p>
<p>gradlew build： 检查依赖并编译打包，debug、release环境的包都会打出来；</p>
<p>gradlew assemble：编译指定的包：如Debug包（gradlew assembleDebug）、Release包（gradlew assembleRelease）、渠道包（gradlew assembleOemRelease/assembleOemDebug）、定制的版本等等；</p>
<p>gradlew install：编译并安装指定的包。如Debug包（gradlew installDebug）、Release包（gradlew installOemRelease/installOemDebug）、定制的版本等等；</p>
<p>gradlew uninstall：卸载已安装的指定模式的包：如Debug包（gradlew uninstallDebug）、Release包（gradlew uninstallRelease）、渠道包（gradlew uninstallOemRelease/uninstallOemDebug）、定制的版本等等；</p>
<p>gradlew :模块名称:dependencies   ，如gradlew :app:dependencies，作用：查看包依赖关系；</p>
<p>gradlew build -i/–info -d/–debug -s/–stacktrace：编译并打印debug模式和info等级的日志及所用异常的堆栈信息(–stacktrace)；</p>
<p>gradlew clean build –refresh-dependencies：组合指令，清除构建并重新构建，同时强制刷新依赖(gradlew –refresh-dependencies)；</p>
<p>gradlew –offline：离线模式，即让Gradle只使用本地cache里的依赖，如果cache中没有也不会更新依赖，而是提示编译失败；</p>
<p>gradlew –refresh-dependencies：强制刷新依赖，即检查依赖是否有更新比如动态版本、SHA1进行本地cache和远程仓库散列码的对比等，有更新则下载更新进行构建；使用这种方式可以避免手动删除cache；–info：打印堆栈信息；</p>
<p>gradlew –daemon：守护进程，使用Gradle的守护进程构建，能够提高构建效率，如果守护进程没启动或现有的都处于忙碌状态，就启动一个守护进程；</p>
<p>守护进程和守护线程的区别：</p>
<ul>
<li>守护进程 :只会守护到主进程的代码结束</li>
<li>守护线程 :会守护所有其他非守护线程的结束</li>
</ul>
<p>gradlew –no-daemon：如果你已经配置为使用守护进程构建，可以使用该选项本次不用守护进程构建；</p>
<p>gradlew –continuous：连续构建，即任务队列中即使某个任务失败，不会终止执行，而是会继续执行下一个任务；<br>gradlew –parallel –parallel-threads=N：并行编译；</p>
<p>gradlew –configure-on-demand：按需编译；</p>
<h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>implementation：gradle会将依赖项添加到编译类路径，并将依赖项打包到编译输出。且其他模块只有在运行时才能使用该依赖项。</p>
<p>api：gradle会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项。</p>
<p>compileOnly：gradle只会将依赖项添加到编译类路径，不会将其添加到编译输出。</p>
<p>runtimeOnly：gradle只会将依赖项添加到编译输出，以便在运行时使用。即，不会将其添加到编译类路径。</p>
<p>annotationProcessor：要添加对作为注解处理器的库的依赖关系，必须使用 annotationProcessor 配置将其添加到注解处理器类路径。 </p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池原理</title>
    <url>/article/335c74d5/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>优点：</p>
<ul>
<li>能够实现复用</li>
<li>线程统一管理</li>
</ul>
<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>提交任务》核心线程是否已满》阻塞队里是否已满》线程池是否已满》拒绝策略</strong></p>
<p>拒绝策略</p>
<p><code>AbortPolicy</code>： 直接拒绝所提交的任务，并抛出<code>RejectedExecutionException</code>异常。</p>
<p><code>CallerRunsPolicy</code>：只用调用者所在的线程来执行任务。</p>
<p><code>DiscardPolicy</code>：不处理直接丢弃掉任务。</p>
<p><code>DiscardOldestPolicy</code>：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。</p>
<h3 id="延时任务与定时任务"><a href="#延时任务与定时任务" class="headerlink" title="延时任务与定时任务"></a>延时任务与定时任务</h3><p>线程池可以处理延时任务，设置延迟时间执行任务</p>
<p>通过execute执行<strong>无返回值</strong>，而submit提交则有<strong>Future的返回值</strong>，其中get方法可以设置timeout时间，若deadline到达，还没有get到结果，则抛出异常。通过这个方法可以处理定时任务。但是值得注意的是，<strong>该方法会直接阻塞get所在线程！！</strong>若是在主线程中直接引起ui卡住，长时间超过5s则ANR。若想不卡主线程，而设置定时任务可以<strong>采用timer方式</strong>，除了这种方式外还可以采用<strong>开启守护线程</strong>方式来解决。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当需要频繁创建线程来执行任务的时候</p>
<p>需要延迟执行任务</p>
<p>多线程&amp;多任务场景以及单线程场景</p>
<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>例如协程。协程（kotlin）的执行环境也是线程池的应用之一。当在主线程中使用协程提交任务，<strong>这些任务会被调度到线程池的各个线程中</strong>，虽然不在同一个线程，但是能够保证一定的执行顺序。通过自定义协程调度器可以设置其执行的指定线程池。总的来说，依靠的还是线程池。</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorDispatcher</span></span></span><br><span class="line">    : AbstractCoroutineContextElement(ContinuationInterceptor),</span><br><span class="line">        ContinuationInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executorService = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">        Thread(it, <span class="string">"SingleThreadExecutor"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> MyContinuation(continuation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContinuation</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> origin: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = origin.context</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            executorService.submit &#123;</span><br><span class="line">                origin.resumeWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        executorService.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> dispatcher = SingleThreadExecutorDispatcher()</span><br><span class="line">    log(<span class="string">"AA"</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">"BB"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    dispatcher.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">main</span>] AA</span><br><span class="line">[<span class="meta">SingleThreadExecutor</span>] BB</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp框架分析</title>
    <url>/article/cec99305/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>基于Socket， 和HttpUrlConnection同级但并不属于HttpUrlConnection（断点续传的关键）</p>
<p>目前相对主流的框架Retrofit，Glide中都是内置了OkHttp</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();<span class="comment">// 调度者</span></span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;<span class="comment">// 传输层版本和连接协议</span></span><br><span class="line">  eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">  &#125;</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;<span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;<span class="comment">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;<span class="comment">// 代理身份验证</span></span><br><span class="line">  authenticator = Authenticator.NONE;<span class="comment">// 身份验证</span></span><br><span class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();<span class="comment">// 连接池，最大连接数量为5，空闲时间上限为5分钟；</span></span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="keyword">true</span>;<span class="comment">// 安全套接层重定向</span></span><br><span class="line">  followRedirects = <span class="keyword">true</span>;<span class="comment">// 本地重定向</span></span><br><span class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;<span class="comment">// 重试连接失败</span></span><br><span class="line">  callTimeout = <span class="number">0</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="获取拦截器链"><a href="#获取拦截器链" class="headerlink" title="获取拦截器链"></a>获取拦截器链</h2><p>添加各种拦截器，然后建立拦截器链，来处理对请求对象的拦截操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>关键类为RealInterceptorChain。</p>
<p>一个具体的拦截器链，包含整个拦截器链：所有应用程序拦截器，OkHttp核心，所有网络拦截器，最后是网络调用者。如果该链用于应用程序拦截器，则connection必须为空。如果它是用于网络拦截器的，则connection必须为非空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> exchange != <span class="keyword">null</span> ? exchange.connection() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>包括常见异常日志打印；拦截器的链式调用；责任链模式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">  calls++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用链中的下一个拦截器。</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">      index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call); <span class="comment">//准备好异步调用的运行顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对AsyncCall进行突变，以使其将现有正在运行的调用的AtomicInteger共享给同一主机。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">      AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="相关异步回调"><a href="#相关异步回调" class="headerlink" title="相关异步回调"></a>相关异步回调</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备好异步调用的运行顺序。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行异步调用。包括尚未结束的已取消呼叫。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行同步呼叫。包括尚未结束的已取消呼叫。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="promoteAndExecute"><a href="#promoteAndExecute" class="headerlink" title="promoteAndExecute"></a>promoteAndExecute</h3><p>将合格的回调从readyAsyncCalls更新到runningAsyncCalls，并在执行程序服务上运行它们。</p>
<p>不能以同步方式调用，因为执行调用可以调用用户代码。</p>
<p>@return如果调度程序当前正在运行回调，则为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove();</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
</search>
